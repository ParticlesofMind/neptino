import { Container } from "pixi.js";
import { TextRenderer } from "../utils/TextRenderer.js";
import { HeaderRenderer } from "./HeaderRenderer.js";

export interface LayoutNode {
  id: string;
  role?: "header" | "body" | "footer" | "template-block" | "placeholder";
  type: string;
  templateBlock?: {
    id: string;
    type: string;
    order: number;
    config: Record<string, unknown>;
    content: string;
  };
  data?: Record<string, unknown>;
}

export interface RenderContext {
  teacherName?: string | null;
  courseTitle?: string | null;
  courseCode?: string | null;
  pageNumber?: number;
  generatedAt?: string;
}

export class FooterRenderer {
  /**
   * Render structured footer fields
   */
  static renderStructured(
    container: Container,
    fields: Record<string, unknown>,
    activeFields: Array<{ key: string; label: string }>,
    width: number,
    bottomMargin: number,
  ): void {
    const textStyle = TextRenderer.createTextStyle(12, 0x6b7280, false);

    const fieldValues: string[] = [];
    
    activeFields.forEach((field) => {
      const value = fields[field.key];
      if (value !== undefined && value !== null) {
        fieldValues.push(String(value));
      }
    });

    if (fieldValues.length === 0) return;

    const totalGap = (fieldValues.length - 1) * 24;
    const availableWidth = width - 32 - totalGap;
    const itemWidth = Math.max(availableWidth / fieldValues.length, 60);

    let currentX = 16;

    fieldValues.forEach((value) => {
      const itemText = TextRenderer.createText(
        value,
        textStyle,
        0,
        { wordWrapWidth: itemWidth }
      );
      
      itemText.anchor.set(0, 0.5);
      itemText.position.set(currentX, bottomMargin / 2);
      
      container.addChild(itemText);
      
      currentX += itemWidth + 24;
    });
  }

  /**
   * Render legacy footer content
   */
  static renderLegacy(
    container: Container,
    footerNode: LayoutNode | null,
    context: RenderContext,
    width: number,
  ): void {
    const templateBlock = footerNode?.templateBlock;
    const blockConfig = templateBlock?.config as Record<string, unknown> | undefined;
    
    const entries: Array<{ label: string; value: string }> = [];

    if (blockConfig?.showCredits !== false) {
      entries.push({
        label: "Credits",
        value: "Generated by Neptino",
      });
    }

    if (blockConfig?.showDate !== false) {
      entries.push({
        label: "Created",
        value: context.generatedAt || new Date().toLocaleDateString(),
      });
    }

    if (blockConfig?.showContact !== false && context.teacherName) {
      entries.push({
        label: "Contact",
        value: context.teacherName,
      });
    }

    if (templateBlock?.content && !this.isHtmlTemplateString(templateBlock.content)) {
      entries.push({
        label: "Notes",
        value: String(templateBlock.content),
      });
    }

    if (entries.length > 0) {
      const footerValues = entries.map(entry => entry.value);
      const footerText = footerValues.join(" | ");
      
      const footerDisplayText = TextRenderer.createText(
        footerText,
        TextRenderer.createTextStyle(12, 0x6b7280, false),
        0,
        { wordWrapWidth: width - 32 }
      );
      
      footerDisplayText.anchor.set(0.5, 0.5);
      footerDisplayText.position.set(width / 2, 30);
      
      container.addChild(footerDisplayText);
    }
  }

  /**
   * Check if content is an HTML template string
   */
  private static isHtmlTemplateString(content: string): boolean {
    if (!content || typeof content !== 'string') return false;
    
    const htmlTemplatePattern = /<[^>]*>\s*\{\{[^}]+\}\}\s*<\/[^>]*>/;
    const templateVariablePattern = /^\s*\{\{[^}]+\}\}\s*$/;
    
    return htmlTemplatePattern.test(content) || templateVariablePattern.test(content);
  }
}

