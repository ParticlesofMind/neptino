/**
 * Type definitions for spectorjs
 * WebGL debugger and profiler
 */

declare module "spectorjs" {
  export class Spector {
    constructor();

    /**
     * Start capturing WebGL commands
     */
    startCapture(): void;

    /**
     * Stop capturing WebGL commands
     */
    stopCapture(): void;

    /**
     * Clear capture data
     */
    clearCapture(): void;

    /**
     * Get capture data
     */
    getCaptureData(): any;

    /**
     * Display capture in UI
     */
    displayUI(): void;

    /**
     * Set capture options
     */
    setCaptureOptions(options: any): void;
  }

  export default Spector;
}

// Global Spector declaration
declare global {
  interface Window {
    spector?: any;
  }

  const Spector: any;
}

export {};
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_SUPABASE_URL: string;
  readonly VITE_SUPABASE_ANON_KEY: string;
  readonly VITE_APP_ENV: string;
  readonly VITE_APP_NAME: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
/**
 * Application Entry Point
 * Single Responsibility: Bootstrap the entire application
 * - Initialize authentication
 * - Detect page type and initialize appropriate components
 * - Handle form submissions
 */

import { signIn, signUp, signOut, initAuth } from "./backend/auth/auth";
import { supabase } from "./backend/supabase";
import { createAsideNavigation, createCourseBuilderNavigation } from "./navigation/index";

// Page type detection
function getPageType(): 'coursebuilder' | 'protected' | 'public' {
  const path = window.location.pathname;
  
  if (path.includes('/pages/teacher/coursebuilder.html')) {
    return 'coursebuilder';
  }
  
  if (path.includes('/pages/student/') || 
      path.includes('/pages/teacher/') || 
      path.includes('/pages/admin/')) {
    return 'protected';
  }
  
  return 'public';
}

// Initialize CourseBuilder page components
async function initializeCourseBuilderPage(): Promise<void> {
  try {
    // Import CourseBuilder
    const { CourseBuilder } = await import("./coursebuilder/coursebuilder.js");
    
    // Create CourseBuilder instance
    const courseBuilder = new CourseBuilder();
    
    // Set course ID from session if available
    const courseId = sessionStorage.getItem("currentCourseId");
    if (courseId) {
      courseBuilder.setCourseId(courseId);
    }
    
    // Create CourseBuilder navigation and pass the instance
    const navigation = createCourseBuilderNavigation(courseBuilder);
    
    // Create aside navigation for setup section
    const asideNav = createAsideNavigation();
    
    // Handle section changes
    const handleSectionChange = () => {
      const hash = window.location.hash.substring(1);
      if (hash === 'setup' || !hash) {
        asideNav.show();
      } else {
        asideNav.hide();
      }
    };
    
    // Listen for section changes
    window.addEventListener('hashchange', handleSectionChange);
    handleSectionChange(); // Initial check
    
    // Expose for debugging
    (window as any).courseBuilder = courseBuilder;
    (window as any).courseBuilderNavigation = navigation;
    
  } catch (error) {
    console.error("‚ùå Failed to initialize CourseBuilder page:", error);
  }
}

// Initialize protected page (with aside navigation only)
async function initializeProtectedPage(): Promise<void> {
  try {
    createAsideNavigation();
  } catch (error) {
    console.error("‚ùå Failed to initialize protected page:", error);
  }
}

// Check authentication for protected pages
async function checkAuthForProtectedPages(): Promise<boolean> {
  const { data: { session } } = await supabase.auth.getSession();
  
  if (!session?.user) {
    window.location.href = "/src/pages/shared/signin.html";
    return false;
  }
  
  return true;
}

// Main application initialization
async function initializeApplication(): Promise<void> {
  // Always initialize authentication first
  initAuth();
  
  const pageType = getPageType();
  
  switch (pageType) {
    case 'coursebuilder':
      if (await checkAuthForProtectedPages()) {
        await initializeCourseBuilderPage();
      }
      break;
      
    case 'protected':
      if (await checkAuthForProtectedPages()) {
        await initializeProtectedPage();
      }
      break;
      
    case 'public':
      // No additional initialization needed
      break;
  }
  
  // Initialize form handlers for all pages
  initializeFormHandlers();
}

// Form handlers
function initializeFormHandlers(): void {
  handleSignInForm();
  handleSignUpForm();
  handleLogout();
}

// Handle logout functionality
function handleLogout(): void {
  const logoutBtn = document.getElementById("logout-btn");
  if (!logoutBtn) return;

  logoutBtn.addEventListener("click", async (e) => {
    e.preventDefault();

    try {
      const result = await signOut();
      if (result.success) {
        window.location.href = "/src/pages/shared/signin.html";
      } else {
        console.error("Logout failed:", result.error);
        window.location.href = "/src/pages/shared/signin.html";
      }
    } catch (error) {
      console.error("Logout error:", error);
      window.location.href = "/src/pages/shared/signin.html";
    }
  });
}

// Handle sign-in form
function handleSignInForm(): void {
  const form = document.getElementById("signin-form") as HTMLFormElement;
  if (!form) return;

  form.addEventListener("submit", async (e) => {
    e.preventDefault();

    const emailInput = document.getElementById("email") as HTMLInputElement;
    const passwordInput = document.getElementById("password") as HTMLInputElement;
    const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement;

    if (!emailInput || !passwordInput) return;

    const email = emailInput.value.trim();
    const password = passwordInput.value;

    if (!email || !password) {
      showError("Please fill in all fields");
      return;
    }

    submitButton.disabled = true;
    submitButton.textContent = "Signing in...";

    try {
      const result = await signIn(email, password);

      if (result.success) {
        showSuccess("Sign in successful! Redirecting...");
      } else {
        showError(result.error || "Sign in failed");
      }
    } catch (error) {
      showError("An unexpected error occurred");
    } finally {
      submitButton.disabled = false;
      submitButton.textContent = "Sign In";
    }
  });
}

// Handle sign-up form
function handleSignUpForm(): void {
  const form = document.getElementById("signup-form") as HTMLFormElement;
  if (!form) return;

  form.addEventListener("submit", async (e) => {
    e.preventDefault();

    const firstNameInput = document.getElementById("first-name") as HTMLInputElement;
    const lastNameInput = document.getElementById("last-name") as HTMLInputElement;
    const emailInput = document.getElementById("email") as HTMLInputElement;
    const passwordInput = document.getElementById("password") as HTMLInputElement;
    const roleInput = document.getElementById("role") as HTMLSelectElement;
    const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement;

    if (!firstNameInput || !emailInput || !passwordInput || !roleInput) return;

    const firstName = firstNameInput.value.trim();
    const lastName = lastNameInput?.value.trim() || "";
    const email = emailInput.value.trim();
    const password = passwordInput.value;
    const role = roleInput.value;

    if (!firstName || !email || !password || !role) {
      showError("Please fill in all required fields");
      return;
    }

    if (password.length < 6) {
      showError("Password must be at least 6 characters long");
      return;
    }

    submitButton.disabled = true;
    submitButton.textContent = "Creating Account...";

    try {
      const fullName = lastName ? `${firstName} ${lastName}` : firstName;
      const result = await signUp(email, password, fullName, role);

      if (result.success) {
        showSuccess("Account created successfully! Please check your email to verify your account.");
        form.reset();
      } else {
        showError(result.error || "Sign up failed");
      }
    } catch (error) {
      showError("An unexpected error occurred");
    } finally {
      submitButton.disabled = false;
      submitButton.textContent = "Create Account";
    }
  });
}

// Utility functions for showing messages
function showError(message: string): void {
  showMessage(message, "error");
}

function showSuccess(message: string): void {
  showMessage(message, "success");
}

function showMessage(message: string, type: "error" | "success"): void {
  // Remove existing messages
  const existingMessages = document.querySelectorAll(".alert");
  existingMessages.forEach((msg) => msg.remove());

  // Create message element
  const messageEl = document.createElement("div");
  messageEl.className = `alert alert--${type}`;
  messageEl.textContent = message;

  // Find form to append to
  const form = document.querySelector(".form");
  if (form) {
    form.insertBefore(messageEl, form.firstChild);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      messageEl.remove();
    }, 5000);
  }
}

// Initialize when DOM is loaded
document.addEventListener("DOMContentLoaded", initializeApplication);
/**
 * Tool State Manager
 * Manages tool selection, settings, and state for the coursebuilder
 * Single Responsibility: Tool management only
 */

interface ToolSettings {
  pen: {
    color: string;
    size: number;
  };
  text: {
    fontFamily: string;
    fontSize: number;
    color: string;
  };
  highlighter: {
    color: string;
    opacity: number;
    size: number;
  };
  shapes: {
    color: string;
    strokeWidth: number;
    fillColor?: string;
    shapeType: "rectangle" | "triangle" | "circle";
  };
  eraser: {
    size: number;
  };
}

export class ToolStateManager {
  private currentTool: string = "selection";
  private selectedMedia: string | null = null;
  private toolSettings: ToolSettings;

  constructor() {
    this.toolSettings = {
      pen: {
        color: "#000000",
        size: 2,
      },
      text: {
        fontFamily: "Arial",
        fontSize: 16,
        color: "#000000",
      },
      highlighter: {
        color: "#ffff00",
        opacity: 0.3,
        size: 20,
      },
      shapes: {
        color: "#000000",
        strokeWidth: 2,
        shapeType: "rectangle",
      },
      eraser: {
        size: 20,
      },
    };
  }

  /**
   * Set current tool
   */
  setTool(toolName: string): void {
    this.currentTool = toolName;
    this.updateToolUI(toolName);
  }

  /**
   * Get current tool
   */
  getCurrentTool(): string {
    return this.currentTool;
  }

  /**
   * Update tool settings
   */
  updateToolSettings(
    toolName: string,
    settings: Partial<ToolSettings[keyof ToolSettings]>,
  ): void {
    if (toolName in this.toolSettings) {
      Object.assign(
        this.toolSettings[toolName as keyof ToolSettings],
        settings,
      );
    }
  }

  /**
   * Get tool settings
   */
  getToolSettings(): ToolSettings {
    return { ...this.toolSettings };
  }

  /**
   * Set selected media
   */
  setSelectedMedia(mediaId: string | null): void {
    this.selectedMedia = mediaId;
  }

  /**
   * Get selected media
   */
  getSelectedMedia(): string | null {
    return this.selectedMedia;
  }

  /**
   * Update tool UI to reflect current selection
   */
  private updateToolUI(toolName: string): void {
    // Remove active class from all tools
    document
      .querySelectorAll(".tool")
      .forEach((t) => t.classList.remove("tool--selected"));

    // Add active class to selected tool
    const selectedTool = document.querySelector(`[data-tool="${toolName}"]`);
    if (selectedTool) {
      selectedTool.classList.add("tool--selected");
    }

    // Hide all tool settings
    document.querySelectorAll(".tool-settings").forEach((settings) => {
      settings.classList.remove("tool-settings--active");
    });

    // Show settings for current tool - look for the div with data-tool attribute matching the tool name
    const toolSettings = document.querySelector(
      `.tool-settings[data-tool="${toolName}"]`,
    );
    if (toolSettings) {
      toolSettings.classList.add("tool-settings--active");
    }
  }

  /**
   * Update canvas cursor based on current tool
   */
  updateCanvasCursor(): void {
    const canvas = document.querySelector("#pixi-canvas") as HTMLElement;
    if (!canvas) return;

    // Remove all cursor classes
    canvas.classList.remove(
      "cursor-pen",
      "cursor-eraser",
      "cursor-text",
      "cursor-highlighter",
      "cursor-selection",
    );

    // Add cursor class for current tool
    switch (this.currentTool) {
      case "pen":
        canvas.classList.add("cursor-pen");
        break;
      case "eraser":
        canvas.classList.add("cursor-eraser");
        break;
      case "text":
        canvas.classList.add("cursor-text");
        break;
      case "highlighter":
        canvas.classList.add("cursor-highlighter");
        break;
      default:
        canvas.classList.add("cursor-selection");
    }
  }
}
/**
 * UI Event Handler
 * Manages DOM events and user interactions for the coursebuilder interface
 * Single Responsibility: Event handling and UI interactions only
 */

import { ToolStateManager } from "./ToolStateManager";

export class UIEventHandler {
  private toolStateManager: ToolStateManager;
  private onToolChangeCallback: ((toolName: string) => void) | null = null;
  private onColorChangeCallback: ((color: string) => void) | null = null;

  constructor(toolStateManager: ToolStateManager) {
    this.toolStateManager = toolStateManager;
    this.bindEvents();
  }

  /**
   * Set callback for tool changes
   */
  setOnToolChange(callback: (toolName: string) => void): void {
    this.onToolChangeCallback = callback;
  }

  /**
   * Set callback for color changes
   */
  setOnColorChange(callback: (color: string) => void): void {
    this.onColorChangeCallback = callback;
  }

  /**
   * Bind all UI events
   */
  private bindEvents(): void {
    document.addEventListener("click", this.handleGlobalClick.bind(this));

    // Tool selection events
    document.querySelectorAll("[data-tool]").forEach((button) => {
      button.addEventListener("click", this.handleToolSelection.bind(this));
    });

    // Color palette events
    document.querySelectorAll(".color-palette__color").forEach((color) => {
      color.addEventListener("click", this.handleColorSelection.bind(this));
    });

    // Shape tool events
    document.querySelectorAll(".shape-btn").forEach((button) => {
      button.addEventListener("click", this.handleShapeSelection.bind(this));
    });

    // Slider events for tool settings
    document
      .querySelectorAll('input[type="range"][data-setting]')
      .forEach((slider) => {
        slider.addEventListener("input", this.handleSliderChange.bind(this));
      });

    // Select dropdown events for font settings
    document.querySelectorAll("select[data-setting]").forEach((select) => {
      select.addEventListener("change", this.handleSelectChange.bind(this));
    });

    // Canvas actions
    this.bindCanvasActions();
  }

  /**
   * Handle global click events
   */
  private handleGlobalClick(event: Event): void {
    const target = event.target as HTMLElement;

    // Handle color selection
    if (target.classList.contains("color-palette__color")) {
      this.handleColorSelection(event);
      return;
    }

    // Handle shape selection
    if (
      target.classList.contains("shape-btn") ||
      target.closest(".shape-btn")
    ) {
      this.handleShapeSelection(event);
      return;
    }
  }

  /**
   * Handle tool selection
   */
  private handleToolSelection(event: Event): void {
    event.preventDefault();
    const button = event.currentTarget as HTMLElement;
    const toolName = button.dataset.tool;

    if (!toolName) return;

    this.toolStateManager.setTool(toolName);
    this.toolStateManager.updateCanvasCursor();

    // Trigger callback
    if (this.onToolChangeCallback) {
      this.onToolChangeCallback(toolName);
    }
  }

  /**
   * Handle color selection
   */
  private handleColorSelection(event: Event): void {
    event.preventDefault();
    const colorSquare = event.currentTarget as HTMLElement;
    const colorValue = colorSquare.dataset.color;

    if (!colorValue) {
      console.warn("üé® Color selection failed: no color data found");
      return;
    }

    // Update UI - find the parent color palette and update active state
    const parentPalette = colorSquare.closest(".color-palette");
    if (parentPalette) {
      parentPalette
        .querySelectorAll(".color-palette__color")
        .forEach((color) => {
          color.classList.remove("color-palette__color--active");
        });
      colorSquare.classList.add("color-palette__color--active");
    }

    // Update tool settings based on currently active tool
    const currentTool = this.toolStateManager.getCurrentTool();
    if (currentTool === "pen") {
      this.toolStateManager.updateToolSettings("pen", { color: colorValue });
    } else if (currentTool === "text") {
      this.toolStateManager.updateToolSettings("text", { color: colorValue });
    } else if (currentTool === "highlighter") {
      this.toolStateManager.updateToolSettings("highlighter", {
        color: colorValue,
      });
    } else if (currentTool === "shapes") {
      this.toolStateManager.updateToolSettings("shapes", { color: colorValue });
    }

    // Trigger callback
    if (this.onColorChangeCallback) {
      this.onColorChangeCallback(colorValue);
    }
  }

  /**
   * Handle slider changes for tool settings
   */
  private handleSliderChange(event: Event): void {
    const slider = event.currentTarget as HTMLInputElement;
    const setting = slider.dataset.setting;
    const value = slider.value;

    if (!setting) return;

    // Update the displayed value
    const valueDisplay = slider.parentElement?.querySelector(
      ".size-slider__value",
    );
    if (valueDisplay) {
      if (setting === "opacity") {
        const percentage = Math.round(parseFloat(value) * 100);
        valueDisplay.textContent = `${percentage}%`;
      } else {
        valueDisplay.textContent = `${value}px`;
      }
    }

    // Update tool settings based on currently active tool
    const currentTool = this.toolStateManager.getCurrentTool();
    const numericValue =
      setting === "opacity" ? parseFloat(value) : parseInt(value);

    if (currentTool === "pen" && setting === "size") {
      this.toolStateManager.updateToolSettings("pen", {
        [setting]: numericValue,
      });
    } else if (currentTool === "text" && setting === "fontSize") {
      this.toolStateManager.updateToolSettings("text", {
        [setting]: numericValue,
      });
    } else if (
      currentTool === "highlighter" &&
      (setting === "size" || setting === "opacity")
    ) {
      this.toolStateManager.updateToolSettings("highlighter", {
        [setting]: numericValue,
      });
    } else if (currentTool === "shapes" && setting === "strokeWidth") {
      this.toolStateManager.updateToolSettings("shapes", {
        [setting]: numericValue,
      });
    } else if (currentTool === "eraser" && setting === "size") {
      this.toolStateManager.updateToolSettings("eraser", {
        [setting]: numericValue,
      });
    }
  }

  /**
   * Handle select changes for tool settings
   */
  private handleSelectChange(event: Event): void {
    const select = event.currentTarget as HTMLSelectElement;
    const setting = select.dataset.setting;
    const value = select.value;

    if (!setting) return;

    // Update tool settings based on currently active tool
    const currentTool = this.toolStateManager.getCurrentTool();

    if (currentTool === "text" && setting === "fontFamily") {
      this.toolStateManager.updateToolSettings("text", { [setting]: value });
    }
  }

  /**
   * Handle shape selection
   */
  private handleShapeSelection(event: Event): void {
    event.preventDefault();
    const button = event.currentTarget as HTMLElement;
    const shapeType = button.dataset.shape;

    if (!shapeType) return;

    // Update UI - set active state for shape buttons
    const parentShapeButtons = button.closest(".shape-buttons");
    if (parentShapeButtons) {
      parentShapeButtons.querySelectorAll(".shape-btn").forEach((btn) => {
        btn.classList.remove("shape-btn--active");
      });
      button.classList.add("shape-btn--active");
    }

    // Set tool to shapes and update shape type
    this.toolStateManager.setTool("shapes");
    this.toolStateManager.updateToolSettings("shapes", {
      shapeType: shapeType as "rectangle" | "triangle" | "circle",
    });
    this.toolStateManager.updateCanvasCursor();


    // Trigger tool change callback
    if (this.onToolChangeCallback) {
      this.onToolChangeCallback("shapes");
    }
  }

  /**
   * Bind canvas action events
   */
  private bindCanvasActions(): void {
    // Clear canvas button
    const clearBtn = document.getElementById("clear-canvas");
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        const event = new CustomEvent("clearCanvas");
        document.dispatchEvent(event);
      });
    }

    // Clear all button
    const clearAllBtn = document.getElementById("clear-all");
    if (clearAllBtn) {
      clearAllBtn.addEventListener("click", () => {
        const event = new CustomEvent("clearAll");
        document.dispatchEvent(event);
      });
    }

    // Add page button
    const addPageBtn = document.getElementById("add-page");
    if (addPageBtn) {
      addPageBtn.addEventListener("click", () => {
        const event = new CustomEvent("addPage");
        document.dispatchEvent(event);
      });
    }

    // Layout toggle button
    const layoutToggleBtn = document.getElementById("toggle-layout");
    if (layoutToggleBtn) {
      layoutToggleBtn.addEventListener("click", () => {
        const event = new CustomEvent("toggleLayout");
        document.dispatchEvent(event);
      });
    }
  }

  /**
   * Cleanup event listeners
   */
  destroy(): void {
    document.removeEventListener("click", this.handleGlobalClick);
    // Additional cleanup as needed
  }
}
/**
 * Shapes Tool
 * Multi-geometry creation with professional styling and advanced shape options
 */

import { FederatedPointerEvent, Container, Graphics, Point } from "pixi.js";
import { BaseTool } from "./ToolInterface";
import {
  PROFESSIONAL_COLORS,
  STROKE_SIZES,
  hexToNumber,
} from "./SharedResources";

interface ShapesSettings {
  color: string;
  strokeWidth: number;
  fillColor?: string;
  fillEnabled: boolean;
  shapeType:
    | "rectangle"
    | "triangle"
    | "circle"
    | "ellipse"
    | "line"
    | "arrow"
    | "polygon";
  cornerRadius?: number; // For rounded rectangles
  sides?: number; // For polygons
}

export class ShapesTool extends BaseTool {
  private isDrawing: boolean = false;
  private currentShape: Graphics | null = null;
  private startPoint: Point = new Point(0, 0);
  private currentPoint: Point = new Point(0, 0);

  constructor() {
    super("shapes", "crosshair");
    this.settings = {
      color: PROFESSIONAL_COLORS[0], // Dark charcoal stroke
      strokeWidth: STROKE_SIZES.SHAPES[2], // 4px stroke
      fillColor: PROFESSIONAL_COLORS[13], // Light gray fill
      fillEnabled: false,
      shapeType: "rectangle",
      cornerRadius: 0,
      sides: 6, // For hexagon default
    };
  }

  onPointerDown(event: FederatedPointerEvent, container: Container): void {
    this.isDrawing = true;
      `üî∂ SHAPES: Started drawing ${this.settings.shapeType} at (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
    );
      `üî∂ SHAPES: Settings - Color: ${this.settings.color}, Stroke: ${this.settings.strokeWidth}px, Fill: ${this.settings.fillEnabled ? this.settings.fillColor : "none"}`,
    );

    // Use local coordinates relative to the container
    const localPoint = container.toLocal(event.global);
    this.startPoint.copyFrom(localPoint);
    this.currentPoint.copyFrom(localPoint);

    // Create new graphics object with professional styling
    this.currentShape = new Graphics();
    this.currentShape.eventMode = "static";

    container.addChild(this.currentShape);
      `üî∂ SHAPES: Professional ${this.settings.shapeType} graphics object created`,
    );
  }

  onPointerMove(event: FederatedPointerEvent, container: Container): void {
    if (!this.isDrawing || !this.currentShape) return;

    // Use local coordinates relative to the container
    const localPoint = container.toLocal(event.global);
    this.currentPoint.copyFrom(localPoint);

    this.drawShape();
  }

  onPointerUp(): void {
    if (this.isDrawing) {
        `üî∂ SHAPES: Finished drawing professional ${this.settings.shapeType}`,
      );
    }
    this.isDrawing = false;
    this.currentShape = null;
  }

  private drawShape(): void {
    if (!this.currentShape) return;

    // Clear previous drawing
    this.currentShape.clear();

    const strokeColor = hexToNumber(this.settings.color);
    const width = this.currentPoint.x - this.startPoint.x;
    const height = this.currentPoint.y - this.startPoint.y;

    // Apply stroke style
    const strokeStyle = {
      width: this.settings.strokeWidth,
      color: strokeColor,
      cap: "round" as const,
      join: "round" as const,
    };

    // Apply fill if enabled
    let fillStyle = undefined;
    if (this.settings.fillEnabled && this.settings.fillColor) {
      fillStyle = { color: hexToNumber(this.settings.fillColor) };
    }

    switch (this.settings.shapeType) {
      case "rectangle":
        this.drawRectangle(width, height, strokeStyle, fillStyle);
        break;

      case "triangle":
        this.drawTriangle(width, height, strokeStyle, fillStyle);
        break;

      case "circle":
        this.drawCircle(width, height, strokeStyle, fillStyle);
        break;

      case "ellipse":
        this.drawEllipse(width, height, strokeStyle, fillStyle);
        break;

      case "line":
        this.drawLine(strokeStyle);
        break;

      case "arrow":
        this.drawArrow(strokeStyle);
        break;

      case "polygon":
        this.drawPolygon(width, height, strokeStyle, fillStyle);
        break;
    }
  }

  private drawRectangle(
    width: number,
    height: number,
    strokeStyle: any,
    fillStyle: any,
  ): void {
    if (!this.currentShape) return;

    if (this.settings.cornerRadius && this.settings.cornerRadius > 0) {
      // Rounded rectangle
      this.currentShape.roundRect(
        this.startPoint.x,
        this.startPoint.y,
        width,
        height,
        this.settings.cornerRadius,
      );
    } else {
      // Standard rectangle
      this.currentShape.rect(
        this.startPoint.x,
        this.startPoint.y,
        width,
        height,
      );
    }

    if (fillStyle) this.currentShape.fill(fillStyle);
    this.currentShape.stroke(strokeStyle);
  }

  private drawTriangle(
    width: number,
    height: number,
    strokeStyle: any,
    fillStyle: any,
  ): void {
    if (!this.currentShape) return;

    // Equilateral triangle pointing up
    const topX = this.startPoint.x + width / 2;
    const topY = this.startPoint.y;
    const bottomLeftX = this.startPoint.x;
    const bottomLeftY = this.startPoint.y + height;
    const bottomRightX = this.startPoint.x + width;
    const bottomRightY = this.startPoint.y + height;

    this.currentShape
      .moveTo(topX, topY)
      .lineTo(bottomLeftX, bottomLeftY)
      .lineTo(bottomRightX, bottomRightY)
      .closePath();

    if (fillStyle) this.currentShape.fill(fillStyle);
    this.currentShape.stroke(strokeStyle);
  }

  private drawCircle(
    width: number,
    height: number,
    strokeStyle: any,
    fillStyle: any,
  ): void {
    if (!this.currentShape) return;

    // Perfect circle using the larger dimension
    const radius = Math.max(Math.abs(width), Math.abs(height)) / 2;
    const centerX = this.startPoint.x + width / 2;
    const centerY = this.startPoint.y + height / 2;

    this.currentShape.circle(centerX, centerY, radius);

    if (fillStyle) this.currentShape.fill(fillStyle);
    this.currentShape.stroke(strokeStyle);
  }

  private drawEllipse(
    width: number,
    height: number,
    strokeStyle: any,
    fillStyle: any,
  ): void {
    if (!this.currentShape) return;

    const centerX = this.startPoint.x + width / 2;
    const centerY = this.startPoint.y + height / 2;
    const radiusX = Math.abs(width) / 2;
    const radiusY = Math.abs(height) / 2;

    this.currentShape.ellipse(centerX, centerY, radiusX, radiusY);

    if (fillStyle) this.currentShape.fill(fillStyle);
    this.currentShape.stroke(strokeStyle);
  }

  private drawLine(strokeStyle: any): void {
    if (!this.currentShape) return;

    this.currentShape
      .moveTo(this.startPoint.x, this.startPoint.y)
      .lineTo(this.currentPoint.x, this.currentPoint.y)
      .stroke(strokeStyle);
  }

  private drawArrow(strokeStyle: any): void {
    if (!this.currentShape) return;

    const dx = this.currentPoint.x - this.startPoint.x;
    const dy = this.currentPoint.y - this.startPoint.y;
    const angle = Math.atan2(dy, dx);
    const length = Math.sqrt(dx * dx + dy * dy);

    // Arrow head size
    const headLength = Math.min(20, length * 0.3);
    const headAngle = Math.PI / 6; // 30 degrees

    // Draw line
    this.currentShape
      .moveTo(this.startPoint.x, this.startPoint.y)
      .lineTo(this.currentPoint.x, this.currentPoint.y)
      .stroke(strokeStyle);

    // Draw arrow head
    const headX1 =
      this.currentPoint.x - headLength * Math.cos(angle - headAngle);
    const headY1 =
      this.currentPoint.y - headLength * Math.sin(angle - headAngle);
    const headX2 =
      this.currentPoint.x - headLength * Math.cos(angle + headAngle);
    const headY2 =
      this.currentPoint.y - headLength * Math.sin(angle + headAngle);

    this.currentShape
      .moveTo(this.currentPoint.x, this.currentPoint.y)
      .lineTo(headX1, headY1)
      .moveTo(this.currentPoint.x, this.currentPoint.y)
      .lineTo(headX2, headY2)
      .stroke(strokeStyle);
  }

  private drawPolygon(
    width: number,
    height: number,
    strokeStyle: any,
    fillStyle: any,
  ): void {
    if (!this.currentShape || !this.settings.sides || this.settings.sides < 3)
      return;

    const centerX = this.startPoint.x + width / 2;
    const centerY = this.startPoint.y + height / 2;
    const radius = Math.max(Math.abs(width), Math.abs(height)) / 2;
    const sides = this.settings.sides;

    // Generate polygon points
    const points: number[] = [];
    for (let i = 0; i < sides; i++) {
      const angle = (i * 2 * Math.PI) / sides - Math.PI / 2; // Start from top
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      points.push(x, y);
    }

    this.currentShape.poly(points);

    if (fillStyle) this.currentShape.fill(fillStyle);
    this.currentShape.stroke(strokeStyle);
  }

  setShapeType(
    shapeType:
      | "rectangle"
      | "triangle"
      | "circle"
      | "ellipse"
      | "line"
      | "arrow"
      | "polygon",
  ): void {
    this.settings.shapeType = shapeType;
  }

  setCornerRadius(radius: number): void {
    this.settings.cornerRadius = Math.max(0, radius);
  }

  setPolygonSides(sides: number): void {
    this.settings.sides = Math.max(3, sides);
  }

  toggleFill(): void {
    this.settings.fillEnabled = !this.settings.fillEnabled;
      `üî∂ SHAPES: Fill ${this.settings.fillEnabled ? "enabled" : "disabled"}`,
    );
  }

  updateSettings(settings: ShapesSettings): void {
    this.settings = { ...this.settings, ...settings };
  }

  // Get available colors for UI
  static getAvailableColors(): string[] {
    return PROFESSIONAL_COLORS;
  }

  // Get available stroke sizes for UI
  static getAvailableStrokeSizes(): number[] {
    return STROKE_SIZES.SHAPES;
  }

  // Get available shape types
  static getShapeTypes(): string[] {
    return [
      "rectangle",
      "triangle",
      "circle",
      "ellipse",
      "line",
      "arrow",
      "polygon",
    ];
  }

  // Get shape type display names
  static getShapeTypeNames(): { [key: string]: string } {
    return {
      rectangle: "Rectangle",
      triangle: "Triangle",
      circle: "Circle",
      ellipse: "Ellipse",
      line: "Line",
      arrow: "Arrow",
      polygon: "Polygon",
    };
  }
}
/**
 * Pen Tool
 * Node-based vector drawing system with professional color palette
 */

import { FederatedPointerEvent, Container, Graphics, Point } from "pixi.js";
import { BaseTool } from "./ToolInterface";
import {
  PROFESSIONAL_COLORS,
  STROKE_SIZES,
  PEN_CONSTANTS,
  hexToNumber,
} from "./SharedResources";

interface PenSettings {
  color: string;
  size: number;
}

interface VectorNode {
  position: Point;
  graphics: Graphics;
}

interface VectorPath {
  nodes: VectorNode[];
  pathGraphics: Graphics;
  isComplete: boolean;
  settings: PenSettings;
}

export class PenTool extends BaseTool {
  public isDrawing: boolean = false;
  private currentPath: VectorPath | null = null;
  private previewLine: Graphics | null = null;
  private lastMousePosition: Point = new Point(0, 0);

  constructor() {
    super("pen", "crosshair");
    this.settings = {
      color: PROFESSIONAL_COLORS[0], // Start with dark charcoal
      size: STROKE_SIZES.PEN[2], // Start with 3px
    };
  }

  onPointerDown(event: FederatedPointerEvent, container: Container): void {
      `‚úèÔ∏è PEN: Node placement at (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
    );
      `‚úèÔ∏è PEN: Settings - Color: ${this.settings.color}, Size: ${this.settings.size}`,
    );

    const localPoint = container.toLocal(event.global);
    this.lastMousePosition.copyFrom(localPoint);

    // Check if we're continuing an existing path or starting a new one
    if (this.currentPath && this.currentPath.nodes.length > 0) {
      // Check if clicking near the first node to close the path
      const firstNode = this.currentPath.nodes[0];
      const distance = Math.sqrt(
        Math.pow(localPoint.x - firstNode.position.x, 2) +
          Math.pow(localPoint.y - firstNode.position.y, 2),
      );

      if (distance <= PEN_CONSTANTS.PATH_CLOSE_TOLERANCE) {
        this.completePath(true);
        return;
      }
    }

    // Add new node to current path or start new path
    this.addNodeToPath(localPoint, container);
  }

  onPointerMove(event: FederatedPointerEvent, container: Container): void {
    const localPoint = container.toLocal(event.global);
    this.lastMousePosition.copyFrom(localPoint);

    // Update preview line if we have an active path
    this.updatePreviewLine(container);
  }

  onPointerUp(_event: FederatedPointerEvent, _container: Container): void {
    // For node-based drawing, we don't need to handle pointer up
    // Nodes are placed on pointer down, path completion happens on double-click or escape
  }

  private addNodeToPath(position: Point, container: Container): void {
    if (!this.currentPath) {
      // Start new path
      this.currentPath = {
        nodes: [],
        pathGraphics: new Graphics(),
        isComplete: false,
        settings: { ...this.settings },
      };

      this.currentPath.pathGraphics.eventMode = "static";
      container.addChild(this.currentPath.pathGraphics);
    }

    // Create node graphics
    const nodeGraphics = new Graphics();
    nodeGraphics.circle(0, 0, PEN_CONSTANTS.NODE_SIZE);
    nodeGraphics.fill({ color: PEN_CONSTANTS.NODE_COLOR });
    nodeGraphics.stroke({
      width: PEN_CONSTANTS.NODE_STROKE_WIDTH,
      color: 0xffffff,
    });
    nodeGraphics.position.set(position.x, position.y);
    nodeGraphics.eventMode = "static";

    container.addChild(nodeGraphics);

    // Create node object
    const node: VectorNode = {
      position: position.clone(),
      graphics: nodeGraphics,
    };

    this.currentPath.nodes.push(node);
      `‚úèÔ∏è PEN: Added node ${this.currentPath.nodes.length} at (${Math.round(position.x)}, ${Math.round(position.y)})`,
    );

    // Update path graphics
    this.updatePathGraphics();

    // Update preview line
    this.updatePreviewLine(container);
  }

  private updatePathGraphics(): void {
    if (!this.currentPath || this.currentPath.nodes.length === 0) return;

    const path = this.currentPath.pathGraphics;
    const color = hexToNumber(this.currentPath.settings.color);

    path.clear();

    if (this.currentPath.nodes.length === 1) {
      // Single node - just show the node
      return;
    }

    // Draw lines between nodes
    const firstNode = this.currentPath.nodes[0];
    path.moveTo(firstNode.position.x, firstNode.position.y);

    for (let i = 1; i < this.currentPath.nodes.length; i++) {
      const node = this.currentPath.nodes[i];
      path.lineTo(node.position.x, node.position.y);
    }

    path.stroke({
      width: this.currentPath.settings.size,
      color: color,
      cap: "round",
      join: "round",
    });

      `‚úèÔ∏è PEN: Updated path graphics with ${this.currentPath.nodes.length} nodes`,
    );
  }

  private updatePreviewLine(container: Container): void {
    if (!this.currentPath || this.currentPath.nodes.length === 0) {
      this.removePreviewLine();
      return;
    }

    if (!this.previewLine) {
      this.previewLine = new Graphics();
      this.previewLine.alpha = PEN_CONSTANTS.PREVIEW_LINE_ALPHA;
      container.addChild(this.previewLine);
    }

    const lastNode = this.currentPath.nodes[this.currentPath.nodes.length - 1];
    const color = hexToNumber(this.currentPath.settings.color);

    this.previewLine.clear();
    this.previewLine.moveTo(lastNode.position.x, lastNode.position.y);
    this.previewLine.lineTo(this.lastMousePosition.x, this.lastMousePosition.y);
    this.previewLine.stroke({
      width: this.currentPath.settings.size,
      color: color,
      cap: "round",
    });
  }

  private removePreviewLine(): void {
    if (this.previewLine && this.previewLine.parent) {
      this.previewLine.parent.removeChild(this.previewLine);
      this.previewLine = null;
    }
  }

  private completePath(closeShape: boolean = false): void {
    if (!this.currentPath) return;

    if (closeShape && this.currentPath.nodes.length >= 3) {
      // Close the shape by connecting last node to first
      const firstNode = this.currentPath.nodes[0];
      const path = this.currentPath.pathGraphics;

      path.lineTo(firstNode.position.x, firstNode.position.y);
      path.stroke({
        width: this.currentPath.settings.size,
        color: hexToNumber(this.currentPath.settings.color),
        cap: "round",
        join: "round",
      });

        `‚úèÔ∏è PEN: Closed shape with ${this.currentPath.nodes.length} nodes`,
      );
    }

    // Remove individual node graphics since the path is complete
    this.currentPath.nodes.forEach((node) => {
      if (node.graphics.parent) {
        node.graphics.parent.removeChild(node.graphics);
      }
    });

    // Mark path as complete
    this.currentPath.isComplete = true;

    // Clean up
    this.removePreviewLine();
    this.currentPath = null;

  }

  // Handle keyboard events for path completion
  public onKeyDown(event: KeyboardEvent): void {
    if (!this.currentPath) return;

    switch (event.key) {
      case "Enter":
        // Complete current path without closing
        this.completePath(false);
        break;
      case "Escape":
        // Cancel current path
        this.cancelPath();
        break;
      case " ": // Spacebar
        // Complete and close current path
        if (this.currentPath.nodes.length >= 3) {
          this.completePath(true);
        }
        event.preventDefault();
        break;
    }
  }

  private cancelPath(): void {
    if (!this.currentPath) return;

    // Remove all node graphics
    this.currentPath.nodes.forEach((node) => {
      if (node.graphics.parent) {
        node.graphics.parent.removeChild(node.graphics);
      }
    });

    // Remove path graphics
    if (this.currentPath.pathGraphics.parent) {
      this.currentPath.pathGraphics.parent.removeChild(
        this.currentPath.pathGraphics,
      );
    }

    // Remove preview line
    this.removePreviewLine();

    this.currentPath = null;
  }

  onActivate(): void {
    super.onActivate();

    // Set up keyboard listeners
    document.addEventListener("keydown", this.handleKeyDown);
  }

  onDeactivate(): void {
    super.onDeactivate();

    // Complete any active path
    if (this.currentPath) {
      this.removePreviewLine();
      this.currentPath = null;
    }

    // Remove keyboard listeners
    document.removeEventListener("keydown", this.handleKeyDown);

    // Clean up preview line
    this.removePreviewLine();
  }

  private handleKeyDown = (event: KeyboardEvent): void => {
    // This would need to be handled by the tool manager to get container reference
  };

  updateSettings(settings: PenSettings): void {
    this.settings = { ...this.settings, ...settings };

    // Update current path settings if drawing
    if (this.currentPath) {
      this.currentPath.settings = { ...this.settings };
      this.updatePathGraphics();
    }
  }

  // Get available colors for UI
  static getAvailableColors(): string[] {
    return PROFESSIONAL_COLORS;
  }

  // Get available stroke sizes for UI
  static getAvailableStrokeSizes(): number[] {
    return STROKE_SIZES.PEN;
  }
}
/**
 * Tool Manager
 * Manages all drawing tools and their interactions with the canvas
 */

import { FederatedPointerEvent, Container } from "pixi.js";
import { Tool, ToolSettings } from "./ToolInterface";
import { SelectionTool } from "./SelectionTool";
import { PenTool } from "./PenTool";
import { HighlighterTool } from "./HighlighterTool";
import { TextTool } from "./TextTool";
import { ShapesTool } from "./ShapesTool";
import { EraserTool } from "./EraserTool";

export class ToolManager {
  private tools: Map<string, Tool> = new Map();
  private activeTool: Tool | null = null;
  private settings: ToolSettings;

  constructor() {
    this.settings = {
      pen: {
        color: "#000000", // Black for good visibility
        size: 4, // Increased size for better visibility
      },
      text: {
        fontFamily: "Arial",
        fontSize: 16,
        color: "#000000",
      },
      highlighter: {
        color: "#ffff00", // Bright yellow
        opacity: 0.8, // Increased opacity for better visibility
        size: 20, // Larger size for better visibility
      },
      shapes: {
        color: "#000000",
        strokeWidth: 2,
        fillColor: undefined,
        shapeType: "rectangle",
      },
      eraser: {
        size: 20,
      },
    };

    this.initializeTools();
  }

  private initializeTools(): void {
    // Register all tools
    this.tools.set("selection", new SelectionTool());
    this.tools.set("pen", new PenTool());
    this.tools.set("highlighter", new HighlighterTool());
    this.tools.set("text", new TextTool());
    this.tools.set("shapes", new ShapesTool());
    this.tools.set("eraser", new EraserTool());

    // Set default tool
    this.activeTool = this.tools.get("selection") || null;
    if (this.activeTool) {
      this.activeTool.onActivate();
    }
  }

  public setActiveTool(toolName: string): boolean {
    const newTool = this.tools.get(toolName);
    if (!newTool) {
      console.warn(`‚ùå Tool '${toolName}' not found`);
      return false;
    }

    // Deactivate current tool
    if (this.activeTool) {
      this.activeTool.onDeactivate();
    }

    // Activate new tool
    this.activeTool = newTool;
    this.activeTool.onActivate();

    // Update tool settings
    this.updateToolSettings(toolName);

      `üîß Tool settings:`,
      this.settings[toolName as keyof ToolSettings],
    );
    return true;
  }

  public getActiveTool(): Tool | null {
    return this.activeTool;
  }

  public getActiveToolName(): string {
    return this.activeTool?.name || "none";
  }

  public onPointerDown(
    event: FederatedPointerEvent,
    container: Container,
  ): void {
    if (this.activeTool) {
        `üëÜ Pointer DOWN - Tool: ${this.activeTool.name}, Position: (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
      );
      this.activeTool.onPointerDown(event, container);
    }
  }

  public onPointerMove(
    event: FederatedPointerEvent,
    container: Container,
  ): void {
    if (this.activeTool) {
      // Only log move events for drawing tools when they're actually drawing
      if (this.shouldLogMove()) {
          `üëà Pointer MOVE [DRAWING] - Tool: ${this.activeTool.name}, Position: (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
        );
      }
      this.activeTool.onPointerMove(event, container);
    }
  }

  public onPointerUp(event: FederatedPointerEvent, container: Container): void {
    if (this.activeTool) {
        `üëÜ Pointer UP - Tool: ${this.activeTool.name}, Position: (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
      );
      this.activeTool.onPointerUp(event, container);
    }
  }

  private shouldLogMove(): boolean {
    if (!this.activeTool) return false;

    // Only log move events for drawing tools when they're actively drawing
    const toolName = this.activeTool.name;

    // Check if the tool is actively drawing
    if (toolName === "pen" || toolName === "highlighter") {
      // Only log if the tool is currently drawing (we need to check the tool's state)
      const tool = this.activeTool as any;
      return tool.isDrawing === true;
    }

    if (toolName === "selection") {
      // Only log for selection tool when dragging
      const tool = this.activeTool as any;
      return tool.isDragging === true;
    }

    return false;
  }

  public updateToolSettings(toolName: string, newSettings?: any): void {
    const tool = this.tools.get(toolName);
    if (!tool) return;

    // Update settings for the specific tool
    let toolSettings = this.settings[toolName as keyof ToolSettings];
    if (newSettings) {
      toolSettings = { ...toolSettings, ...newSettings };
      this.settings[toolName as keyof ToolSettings] = toolSettings as any;
    }

    tool.updateSettings(toolSettings);
  }

  public updateColorForCurrentTool(color: string): void {
    if (!this.activeTool) return;

    const toolName = this.activeTool.name;

    switch (toolName) {
      case "pen":
        this.updateToolSettings("pen", { color });
        break;
      case "highlighter":
        this.updateToolSettings("highlighter", { color });
        break;
      case "text":
        this.updateToolSettings("text", { color });
        break;
      case "shapes":
        this.updateToolSettings("shapes", { color });
        break;
    }
  }

  public getToolSettings(): ToolSettings {
    return this.settings;
  }

  public getCursor(): string {
    return this.activeTool?.cursor || "default";
  }

  public destroy(): void {
    // Deactivate current tool
    if (this.activeTool) {
      this.activeTool.onDeactivate();
    }

    // Clear all tools
    this.tools.clear();
    this.activeTool = null;
  }
}
/**
 * Highlighter Tool
 * Authentic marker experience with professional colors and realistic behavior
 */

import { FederatedPointerEvent, Container, Graphics, Point } from "pixi.js";
import { BaseTool } from "./ToolInterface";
import {
  HIGHLIGHTER_COLORS,
  STROKE_SIZES,
  HIGHLIGHTER_CONSTANTS,
  hexToNumber,
} from "./SharedResources";

interface HighlighterSettings {
  color: string;
  size: number;
}

export class HighlighterTool extends BaseTool {
  public isDrawing: boolean = false;
  private currentStroke: Graphics | null = null;
  private lastPoint: Point = new Point(0, 0);
  private strokePoints: Point[] = [];

  constructor() {
    super("highlighter", "crosshair");
    this.settings = {
      color: HIGHLIGHTER_COLORS[0], // Start with classic yellow
      size: STROKE_SIZES.HIGHLIGHTER[1], // Start with 12px
    };
  }

  onPointerDown(event: FederatedPointerEvent, container: Container): void {
    this.isDrawing = true;
      `üñçÔ∏è HIGHLIGHTER: Started highlighting at (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
    );
      `üñçÔ∏è HIGHLIGHTER: Settings - Color: ${this.settings.color}, Size: ${this.settings.size}`,
    );

    // Create new graphics object for this stroke with authentic marker properties
    this.currentStroke = new Graphics();
    this.currentStroke.eventMode = "static";
    this.currentStroke.alpha = HIGHLIGHTER_CONSTANTS.FIXED_OPACITY; // Fixed opacity like real markers

    // Use local coordinates relative to the container
    const localPoint = container.toLocal(event.global);
    this.lastPoint.copyFrom(localPoint);
    this.strokePoints = [localPoint.clone()];

      `üñçÔ∏è HIGHLIGHTER: Container local point: (${Math.round(localPoint.x)}, ${Math.round(localPoint.y)})`,
    );

    // Set stroke style with authentic marker characteristics
    const color = hexToNumber(this.settings.color);
      `üñçÔ∏è HIGHLIGHTER: Setting authentic marker stroke - color: ${color} (from ${this.settings.color}), width: ${this.settings.size}`,
    );

    // Start the drawing path with marker-style properties
    this.currentStroke.moveTo(localPoint.x, localPoint.y).stroke({
      width: this.settings.size,
      color,
      cap: "round", // Authentic marker tip
      join: "round", // Smooth joins like real markers
    });

    // Add to container
    container.addChild(this.currentStroke);
      `üñçÔ∏è HIGHLIGHTER: Marker stroke started with authentic properties`,
    );
  }

  onPointerMove(event: FederatedPointerEvent, container: Container): void {
    // Only respond to move events when actively drawing
    if (!this.isDrawing || !this.currentStroke) return;

    // Use local coordinates relative to the container
    const localPoint = container.toLocal(event.global);

    // Implement stroke smoothing for authentic marker feel
    if (HIGHLIGHTER_CONSTANTS.STROKE_SMOOTHING) {
      const distance = Math.sqrt(
        Math.pow(localPoint.x - this.lastPoint.x, 2) +
          Math.pow(localPoint.y - this.lastPoint.y, 2),
      );

      // Only draw if we've moved a minimum distance (reduces jitter)
      if (distance < HIGHLIGHTER_CONSTANTS.MIN_DISTANCE) return;
    }

      `üñçÔ∏è HIGHLIGHTER: Highlighting to (${Math.round(localPoint.x)}, ${Math.round(localPoint.y)})`,
    );

    // Add slight texture variation for authentic marker feel
    const opacityVariation =
      1 + (Math.random() - 0.5) * HIGHLIGHTER_CONSTANTS.TEXTURE_VARIATION;
    const adjustedOpacity = Math.max(
      0.3,
      Math.min(1, HIGHLIGHTER_CONSTANTS.FIXED_OPACITY * opacityVariation),
    );

    // Continue the stroke with authentic marker characteristics
    this.currentStroke.lineTo(localPoint.x, localPoint.y).stroke({
      width: this.settings.size,
      color: hexToNumber(this.settings.color),
      cap: "round",
      join: "round",
    });

    // Apply subtle opacity variation
    this.currentStroke.alpha = adjustedOpacity;

    // Update tracking
    this.lastPoint.copyFrom(localPoint);
    this.strokePoints.push(localPoint.clone());
  }

  onPointerUp(): void {
    if (this.isDrawing) {
        `üñçÔ∏è HIGHLIGHTER: Finished marker stroke with ${this.strokePoints.length} points`,
      );

      // Apply final authentic marker properties
      if (this.currentStroke) {
        this.currentStroke.alpha = HIGHLIGHTER_CONSTANTS.FIXED_OPACITY;
      }
    }

    this.isDrawing = false;
    this.currentStroke = null;
    this.strokePoints = [];
  }

  updateSettings(settings: HighlighterSettings): void {
    this.settings = { ...this.settings, ...settings };
  }

  // Get available highlighter colors for UI
  static getAvailableColors(): string[] {
    return HIGHLIGHTER_COLORS;
  }

  // Get available highlighter sizes for UI
  static getAvailableStrokeSizes(): number[] {
    return STROKE_SIZES.HIGHLIGHTER;
  }

  // Get authentic marker opacity (fixed like real highlighters)
  static getMarkerOpacity(): number {
    return HIGHLIGHTER_CONSTANTS.FIXED_OPACITY;
  }
}
/**
 * Selection Tool
 * Comprehensive selection and transformation system with marquee selection
 */

import {
  FederatedPointerEvent,
  Container,
  Graphics,
  Point,
  Rectangle,
} from "pixi.js";
import { BaseTool } from "./ToolInterface";
import { SELECTION_CONSTANTS } from "./SharedResources";

interface SelectionSettings {
  // Selection settings can be expanded as needed
}

interface TransformHandle {
  type: "corner" | "edge";
  position: "tl" | "tr" | "bl" | "br" | "t" | "r" | "b" | "l";
  graphics: Graphics;
  bounds: Rectangle;
}

interface SelectionGroup {
  objects: any[];
  bounds: Rectangle;
  transformHandles: TransformHandle[];
  selectionBox: Graphics;
}

export class SelectionTool extends BaseTool {
  private isSelecting: boolean = false;
  private marqueeStart: Point = new Point(0, 0);
  private marqueeGraphics: Graphics | null = null;
  private selectedObjects: any[] = [];
  private selectionGroup: SelectionGroup | null = null;
  private isTransforming: boolean = false;
  private activeHandle: TransformHandle | null = null;
  private transformStart: Point = new Point(0, 0);

  constructor() {
    super("selection", "default");
    this.settings = {};
  }

  onPointerDown(event: FederatedPointerEvent, container: Container): void {
      `üéØ SELECTION: Starting selection at (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
    );

    const localPoint = container.toLocal(event.global);
    this.marqueeStart.copyFrom(localPoint);

    // Check if clicking on a transform handle
    if (this.selectionGroup) {
      const clickedHandle = this.getHandleAtPoint(localPoint);
      if (clickedHandle) {
        this.startTransform(clickedHandle, localPoint);
        return;
      }
    }

    // Check if clicking on a selected object (for dragging)
    const clickedObject = this.getObjectAtPoint(localPoint, container);
    if (clickedObject && this.selectedObjects.includes(clickedObject)) {
      this.isTransforming = true;
      this.transformStart.copyFrom(localPoint);
      return;
    }

    // Start new marquee selection
    this.clearSelection();
    this.startMarqueeSelection(localPoint, container);
  }

  onPointerMove(event: FederatedPointerEvent, container: Container): void {
    const localPoint = container.toLocal(event.global);

    if (this.isTransforming && this.activeHandle) {
      // Handle transformation
      this.updateTransform(localPoint);
    } else if (this.isTransforming && this.selectedObjects.length > 0) {
      // Handle dragging
      this.updateDrag(localPoint);
    } else if (this.isSelecting && this.marqueeGraphics) {
      // Update marquee selection
      this.updateMarqueeSelection(localPoint);
    }
  }

  onPointerUp(event: FederatedPointerEvent, container: Container): void {
    const localPoint = container.toLocal(event.global);

    if (this.isTransforming) {
      this.isTransforming = false;
      this.activeHandle = null;
    } else if (this.isSelecting) {
      // Complete marquee selection
      this.completeMarqueeSelection(container);
    } else {
      // Single click selection
      this.handleSingleClick(localPoint, container, event.shiftKey);
    }
  }

  private startMarqueeSelection(
    _startPoint: Point,
    container: Container,
  ): void {
    this.isSelecting = true;

    // Create marquee graphics
    this.marqueeGraphics = new Graphics();
    this.marqueeGraphics.alpha = SELECTION_CONSTANTS.MARQUEE_FILL_ALPHA;
    container.addChild(this.marqueeGraphics);

  }

  private updateMarqueeSelection(currentPoint: Point): void {
    if (!this.marqueeGraphics) return;

    const x = Math.min(this.marqueeStart.x, currentPoint.x);
    const y = Math.min(this.marqueeStart.y, currentPoint.y);
    const width = Math.abs(currentPoint.x - this.marqueeStart.x);
    const height = Math.abs(currentPoint.y - this.marqueeStart.y);

    this.marqueeGraphics.clear();

    // Fill
    this.marqueeGraphics.rect(x, y, width, height);
    this.marqueeGraphics.fill({
      color: SELECTION_CONSTANTS.SELECTION_COLOR,
      alpha: SELECTION_CONSTANTS.MARQUEE_FILL_ALPHA,
    });

    // Border
    this.marqueeGraphics.stroke({
      width: SELECTION_CONSTANTS.SELECTION_LINE_WIDTH,
      color: SELECTION_CONSTANTS.SELECTION_COLOR,
      alpha: SELECTION_CONSTANTS.MARQUEE_STROKE_ALPHA,
    });
  }

  private completeMarqueeSelection(container: Container): void {
    this.isSelecting = false;

    if (this.marqueeGraphics) {
      const bounds = this.marqueeGraphics.getBounds();
      const rect = new Rectangle(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height,
      );

      // Find objects within the marquee
      const objectsInMarquee = this.findObjectsInBounds(rect, container);

        `üéØ SELECTION: Marquee selection found ${objectsInMarquee.length} objects`,
      );

      if (objectsInMarquee.length > 0) {
        this.selectObjects(objectsInMarquee);
      }

      // Remove marquee graphics
      container.removeChild(this.marqueeGraphics);
      this.marqueeGraphics = null;
    }
  }

  private handleSingleClick(
    point: Point,
    container: Container,
    shiftKey: boolean,
  ): void {
    const clickedObject = this.getObjectAtPoint(point, container);

    if (clickedObject) {
      if (shiftKey) {
        // Add to selection
        this.toggleObjectSelection(clickedObject);
      } else {
        // Replace selection
        this.selectObjects([clickedObject]);
      }
        `üéØ SELECTION: Single click selected object, total selected: ${this.selectedObjects.length}`,
      );
    } else if (!shiftKey) {
      // Clear selection if not holding shift
      this.clearSelection();
    }
  }

  private selectObjects(objects: any[]): void {
    this.clearSelection();
    this.selectedObjects = [...objects];
    this.createSelectionGroup();
  }

  private toggleObjectSelection(object: any): void {
    const index = this.selectedObjects.indexOf(object);
    if (index >= 0) {
      this.selectedObjects.splice(index, 1);
    } else {
      this.selectedObjects.push(object);
    }
    this.createSelectionGroup();
  }

  private createSelectionGroup(): void {
    // Remove existing selection group
    this.removeSelectionGroup();

    if (this.selectedObjects.length === 0) return;

    // Calculate combined bounds
    const bounds = this.calculateCombinedBounds(this.selectedObjects);

    // Create selection box
    const selectionBox = new Graphics();
    selectionBox.rect(bounds.x, bounds.y, bounds.width, bounds.height);
    selectionBox.stroke({
      width: SELECTION_CONSTANTS.SELECTION_LINE_WIDTH,
      color: SELECTION_CONSTANTS.SELECTION_COLOR,
      alpha: SELECTION_CONSTANTS.SELECTION_ALPHA,
    });

    // Create transform handles
    const handles = this.createTransformHandles(bounds);

    this.selectionGroup = {
      objects: this.selectedObjects,
      bounds,
      transformHandles: handles,
      selectionBox,
    };

    // Add to container (assuming first object's parent)
    if (this.selectedObjects[0] && this.selectedObjects[0].parent) {
      const container = this.selectedObjects[0].parent;
      container.addChild(selectionBox);
      handles.forEach((handle) => container.addChild(handle.graphics));
    }

      `üéØ SELECTION: Created selection group with ${handles.length} transform handles`,
    );
  }

  private createTransformHandles(bounds: Rectangle): TransformHandle[] {
    const handles: TransformHandle[] = [];
    const size = SELECTION_CONSTANTS.HANDLE_SIZE;

    // Corner handles
    const positions = [
      {
        type: "corner" as const,
        position: "tl" as const,
        x: bounds.x,
        y: bounds.y,
      },
      {
        type: "corner" as const,
        position: "tr" as const,
        x: bounds.x + bounds.width,
        y: bounds.y,
      },
      {
        type: "corner" as const,
        position: "bl" as const,
        x: bounds.x,
        y: bounds.y + bounds.height,
      },
      {
        type: "corner" as const,
        position: "br" as const,
        x: bounds.x + bounds.width,
        y: bounds.y + bounds.height,
      },
      {
        type: "edge" as const,
        position: "t" as const,
        x: bounds.x + bounds.width / 2,
        y: bounds.y,
      },
      {
        type: "edge" as const,
        position: "r" as const,
        x: bounds.x + bounds.width,
        y: bounds.y + bounds.height / 2,
      },
      {
        type: "edge" as const,
        position: "b" as const,
        x: bounds.x + bounds.width / 2,
        y: bounds.y + bounds.height,
      },
      {
        type: "edge" as const,
        position: "l" as const,
        x: bounds.x,
        y: bounds.y + bounds.height / 2,
      },
    ];

    positions.forEach((pos) => {
      const graphics = new Graphics();
      graphics.rect(-size / 2, -size / 2, size, size);
      graphics.fill({ color: 0xffffff });
      graphics.stroke({ width: 1, color: SELECTION_CONSTANTS.HANDLE_COLOR });
      graphics.position.set(pos.x, pos.y);
      graphics.eventMode = "static";

      const handle: TransformHandle = {
        type: pos.type,
        position: pos.position,
        graphics,
        bounds: new Rectangle(pos.x - size / 2, pos.y - size / 2, size, size),
      };

      handles.push(handle);
    });

    return handles;
  }

  private getHandleAtPoint(point: Point): TransformHandle | null {
    if (!this.selectionGroup) return null;

    for (const handle of this.selectionGroup.transformHandles) {
      const bounds = handle.bounds;
      // Use manual bounds checking for consistency
      if (
        point.x >= bounds.x &&
        point.x <= bounds.x + bounds.width &&
        point.y >= bounds.y &&
        point.y <= bounds.y + bounds.height
      ) {
        return handle;
      }
    }

    return null;
  }

  private startTransform(handle: TransformHandle, point: Point): void {
    this.isTransforming = true;
    this.activeHandle = handle;
    this.transformStart.copyFrom(point);
      `üéØ SELECTION: Started transform with ${handle.position} handle`,
    );
  }

  private updateTransform(currentPoint: Point): void {
    if (!this.activeHandle || !this.selectionGroup) return;

    const dx = currentPoint.x - this.transformStart.x;
    const dy = currentPoint.y - this.transformStart.y;

    // Simple scaling for now (can be enhanced with more complex transforms)
    if (this.activeHandle.type === "corner") {
      this.scaleSelection(dx, dy, this.activeHandle.position);
    }

    this.transformStart.copyFrom(currentPoint);
  }

  private updateDrag(currentPoint: Point): void {
    if (this.selectedObjects.length === 0) return;

    const dx = currentPoint.x - this.transformStart.x;
    const dy = currentPoint.y - this.transformStart.y;

    // Move all selected objects
    this.selectedObjects.forEach((obj) => {
      if (obj.position) {
        obj.position.x += dx;
        obj.position.y += dy;
      }
    });

    // Update selection group
    this.createSelectionGroup();

    this.transformStart.copyFrom(currentPoint);
  }

  private scaleSelection(dx: number, dy: number, _corner: string): void {
    // Simplified scaling - can be enhanced
    const scaleFactor = 1 + Math.max(dx, dy) / 100;

    this.selectedObjects.forEach((obj) => {
      if (obj.scale) {
        obj.scale.x *= scaleFactor;
        obj.scale.y *= scaleFactor;
      }
    });

    this.createSelectionGroup();
  }

  private findObjectsInBounds(bounds: Rectangle, container: Container): any[] {
    const objectsInBounds: any[] = [];

    for (const child of container.children) {
      // Skip selection UI elements
      if (this.isSelectionUIElement(child)) continue;

      try {
        const childBounds = child.getBounds();
        // Manual bounds intersection check since PIXI bounds types might be inconsistent
        if (
          childBounds &&
          typeof childBounds.x === "number" &&
          typeof childBounds.y === "number" &&
          typeof childBounds.width === "number" &&
          typeof childBounds.height === "number"
        ) {
          // Check if rectangles intersect
          if (
            !(
              bounds.x + bounds.width < childBounds.x ||
              childBounds.x + childBounds.width < bounds.x ||
              bounds.y + bounds.height < childBounds.y ||
              childBounds.y + childBounds.height < bounds.y
            )
          ) {
            objectsInBounds.push(child);
          }
        }
      } catch (error) {
        console.warn(
          "üéØ SELECTION: Error checking bounds intersection:",
          error,
        );
        continue;
      }
    }

    return objectsInBounds;
  }

  private getObjectAtPoint(point: Point, container: Container): any | null {
    // Check objects from top to bottom
    for (let i = container.children.length - 1; i >= 0; i--) {
      const child = container.children[i];

      // Skip selection UI elements
      if (this.isSelectionUIElement(child)) continue;

      try {
        const bounds = child.getBounds();
        // Check if bounds is valid and has the required properties
        if (
          bounds &&
          typeof bounds.x === "number" &&
          typeof bounds.y === "number" &&
          typeof bounds.width === "number" &&
          typeof bounds.height === "number"
        ) {
          // Use manual bounds checking since bounds.contains might not work as expected
          if (
            point.x >= bounds.x &&
            point.x <= bounds.x + bounds.width &&
            point.y >= bounds.y &&
            point.y <= bounds.y + bounds.height
          ) {
            return child;
          }
        }
      } catch (error) {
        console.warn("üéØ SELECTION: Error getting bounds for object:", error);
        continue;
      }
    }

    return null;
  }

  private isSelectionUIElement(object: any): boolean {
    // Check if this is part of the selection UI
    if (this.selectionGroup) {
      if (object === this.selectionGroup.selectionBox) return true;
      if (
        this.selectionGroup.transformHandles.some((h) => h.graphics === object)
      )
        return true;
    }
    if (object === this.marqueeGraphics) return true;

    return false;
  }

  private calculateCombinedBounds(objects: any[]): Rectangle {
    if (objects.length === 0) return new Rectangle(0, 0, 0, 0);

    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

    objects.forEach((obj) => {
      try {
        const bounds = obj.getBounds();
        if (
          bounds &&
          typeof bounds.x === "number" &&
          typeof bounds.y === "number" &&
          typeof bounds.width === "number" &&
          typeof bounds.height === "number"
        ) {
          minX = Math.min(minX, bounds.x);
          minY = Math.min(minY, bounds.y);
          maxX = Math.max(maxX, bounds.x + bounds.width);
          maxY = Math.max(maxY, bounds.y + bounds.height);
        }
      } catch (error) {
        console.warn(
          "üéØ SELECTION: Error calculating bounds for object:",
          error,
        );
      }
    });

    // If no valid bounds were found, return a default rectangle
    if (minX === Infinity) {
      return new Rectangle(0, 0, 0, 0);
    }

    return new Rectangle(minX, minY, maxX - minX, maxY - minY);
  }

  private removeSelectionGroup(): void {
    if (this.selectionGroup) {
      // Remove selection box
      if (this.selectionGroup.selectionBox.parent) {
        this.selectionGroup.selectionBox.parent.removeChild(
          this.selectionGroup.selectionBox,
        );
      }

      // Remove transform handles
      this.selectionGroup.transformHandles.forEach((handle) => {
        if (handle.graphics.parent) {
          handle.graphics.parent.removeChild(handle.graphics);
        }
      });

      this.selectionGroup = null;
    }
  }

  private clearSelection(): void {
    this.selectedObjects = [];
    this.removeSelectionGroup();
  }

  onDeactivate(): void {
    super.onDeactivate();
    this.clearSelection();

    // Remove marquee if active
    if (this.marqueeGraphics && this.marqueeGraphics.parent) {
      this.marqueeGraphics.parent.removeChild(this.marqueeGraphics);
      this.marqueeGraphics = null;
    }

    this.isSelecting = false;
    this.isTransforming = false;
  }

  updateSettings(settings: SelectionSettings): void {
    this.settings = { ...this.settings, ...settings };
  }

  // Get currently selected objects
  getSelectedObjects(): any[] {
    return [...this.selectedObjects];
  }

  // Select specific objects programmatically
  selectSpecificObjects(objects: any[]): void {
    this.selectObjects(objects);
  }

  // Clear selection programmatically
  clearSelectionProgrammatically(): void {
    this.clearSelection();
  }
}
/**
 * Tool Interface and Base Classes
 * Defines the structure for all drawing tools
 */

import { FederatedPointerEvent, Container } from "pixi.js";

export interface ToolSettings {
  pen: {
    color: string;
    size: number;
  };
  text: {
    fontFamily: string;
    fontSize: number;
    color: string;
  };
  highlighter: {
    color: string;
    opacity: number;
    size: number;
  };
  shapes: {
    color: string;
    strokeWidth: number;
    fillColor?: string;
    shapeType: "rectangle" | "triangle" | "circle";
  };
  eraser: {
    size: number;
  };
}

export interface Tool {
  name: string;
  cursor: string;

  onPointerDown(event: FederatedPointerEvent, container: Container): void;
  onPointerMove(event: FederatedPointerEvent, container: Container): void;
  onPointerUp(event: FederatedPointerEvent, container: Container): void;
  onActivate(): void;
  onDeactivate(): void;
  updateSettings(settings: any): void;
}

export abstract class BaseTool implements Tool {
  public name: string;
  public cursor: string;
  protected isActive: boolean = false;
  protected settings: any;

  constructor(name: string, cursor: string = "default") {
    this.name = name;
    this.cursor = cursor;
  }

  abstract onPointerDown(
    event: FederatedPointerEvent,
    container: Container,
  ): void;
  abstract onPointerMove(
    event: FederatedPointerEvent,
    container: Container,
  ): void;
  abstract onPointerUp(
    event: FederatedPointerEvent,
    container: Container,
  ): void;

  onActivate(): void {
    this.isActive = true;
  }

  onDeactivate(): void {
    this.isActive = false;
  }

  updateSettings(settings: any): void {
    this.settings = { ...this.settings, ...settings };
  }

  protected hexToNumber(hex: string): number {
    return parseInt(hex.replace("#", ""), 16);
  }
}
/**
 * Shared Resources for Drawing Tools
 * Contains color palettes, stroke sizes, and other shared constants
 */

// Beautiful, desaturated color palette extracted from project variables
export const PROFESSIONAL_COLORS = [
  "#1f2937", // Gray-800 - Dark charcoal
  "#4b5563", // Gray-600 - Medium gray
  "#5083f1", // Primary blue - Professional
  "#3b82f6", // Student blue - Clear sky
  "#059669", // Teacher green - Forest
  "#10b981", // Success green - Emerald
  "#f59e0b", // Accent amber - Warm
  "#ef4444", // Error red - Clear red
  "#8b5cf6", // Purple - Creative
  "#06b6d4", // Cyan - Fresh
  "#84cc16", // Lime - Energetic
  "#f97316", // Orange - Vibrant
  "#ec4899", // Pink - Accent
  "#6b7280", // Gray-500 - Neutral
  "#374151", // Gray-700 - Deep gray
  "#d1d5db", // Gray-300 - Light gray
];

// Authentic highlighter colors (marker-style pastels with slight saturation)
export const HIGHLIGHTER_COLORS = [
  "#ffef3e", // Classic highlighter yellow
  "#90ee90", // Light green
  "#ffb3ba", // Light pink
  "#87ceeb", // Sky blue
  "#dda0dd", // Plum
  "#ffd700", // Gold
  "#98fb98", // Pale green
  "#ffa07a", // Light salmon
  "#d3d3d3", // Light gray
  "#f0e68c", // Khaki
];

// Stroke sizes for different tools
export const STROKE_SIZES = {
  PEN: [1, 2, 3, 5, 8, 12],
  HIGHLIGHTER: [8, 12, 16, 24, 32],
  SHAPES: [1, 2, 4, 6, 8, 12],
  ERASER: [10, 15, 20, 30, 40, 60],
};

// Text sizes
export const TEXT_SIZES = [8, 10, 12, 14, 16, 18, 24, 32, 48, 64];

// Font families
export const FONT_FAMILIES = [
  "Inter",
  "Arial",
  "Helvetica",
  "Times New Roman",
  "Georgia",
  "Courier New",
];

/**
 * Convert hex color to PIXI number format
 */
export function hexToNumber(hex: string): number {
  return parseInt(hex.replace("#", ""), 16);
}

/**
 * Get a professional color by index
 */
export function getProfessionalColor(index: number): string {
  return PROFESSIONAL_COLORS[index % PROFESSIONAL_COLORS.length];
}

/**
 * Create a color palette element for UI
 */
export function createColorPaletteElement(
  selectedColor: string,
  onColorSelect: (color: string) => void,
): HTMLElement {
  const palette = document.createElement("div");
  palette.className = "color-palette";

  PROFESSIONAL_COLORS.forEach((color) => {
    const colorElement = document.createElement("div");
    colorElement.className = "color-palette__color";
    if (color === selectedColor) {
      colorElement.classList.add("color-palette__color--active");
    }
    colorElement.style.backgroundColor = color;
    colorElement.title = color;
    colorElement.dataset.color = color;

    colorElement.addEventListener("click", () => {
      // Update active state
      palette.querySelectorAll(".color-palette__color").forEach((el) => {
        el.classList.remove("color-palette__color--active");
      });
      colorElement.classList.add("color-palette__color--active");

      onColorSelect(color);
    });

    palette.appendChild(colorElement);
  });

  return palette;
}

/**
 * Create a stroke size selector
 */
export function createStrokeSizeSelector(
  sizes: number[],
  selectedSize: number,
  onSizeSelect: (size: number) => void,
  unit: string = "px",
): HTMLElement {
  const container = document.createElement("div");
  container.className = "size-slider";

  const slider = document.createElement("input");
  slider.type = "range";
  slider.min = Math.min(...sizes).toString();
  slider.max = Math.max(...sizes).toString();
  slider.value = selectedSize.toString();

  const valueDisplay = document.createElement("span");
  valueDisplay.className = "size-slider__value";
  valueDisplay.textContent = `${selectedSize}${unit}`;

  slider.addEventListener("input", () => {
    const newSize = parseInt(slider.value);
    valueDisplay.textContent = `${newSize}${unit}`;
    onSizeSelect(newSize);
  });

  container.appendChild(slider);
  container.appendChild(valueDisplay);

  return container;
}

/**
 * Selection and transformation constants
 */
export const SELECTION_CONSTANTS = {
  HANDLE_SIZE: 6,
  HANDLE_COLOR: 0x3b82f6, // Brighter blue for handles
  SELECTION_COLOR: 0x3b82f6, // Brighter blue for selection
  SELECTION_ALPHA: 0.9, // More opaque selection outline
  SELECTION_LINE_WIDTH: 2,
  MARQUEE_FILL_ALPHA: 0.25, // Much more visible fill (25% instead of 10%)
  MARQUEE_STROKE_ALPHA: 0.9, // More opaque stroke
  HIT_TOLERANCE: 8,
  SNAP_TOLERANCE: 10,
};

/**
 * Pen tool constants for node-based drawing
 */
export const PEN_CONSTANTS = {
  NODE_SIZE: 4,
  NODE_COLOR: 0x5083f1,
  NODE_STROKE_WIDTH: 1,
  PATH_CLOSE_TOLERANCE: 8,
  PREVIEW_LINE_ALPHA: 0.5,
};

/**
 * Text tool constants
 */
export const TEXT_CONSTANTS = {
  TEXTAREA_BORDER: "2px dashed #5083f1",
  TEXTAREA_BACKGROUND: "rgba(255, 255, 255, 0.9)",
  MIN_TEXT_AREA_SIZE: { width: 100, height: 30 },
};

/**
 * Highlighter tool constants for authentic marker experience
 */
export const HIGHLIGHTER_CONSTANTS = {
  FIXED_OPACITY: 0.4, // Authentic marker transparency
  OVERLAP_OPACITY: 0.6, // When strokes overlap
  MIN_DISTANCE: 3, // Minimum distance between points for smoothing
  TEXTURE_VARIATION: 0.1, // Slight opacity variation for texture
  MARKER_TIP_STYLE: "round", // Always round like real markers
  STROKE_SMOOTHING: true, // Enable stroke smoothing
};
/**
 * Eraser Tool
 * Precision brush-based deletion with professional visual feedback
 */

import { FederatedPointerEvent, Container, Graphics, Point } from "pixi.js";
import { BaseTool } from "./ToolInterface";
import { STROKE_SIZES } from "./SharedResources";

interface EraserSettings {
  size: number;
  mode: "brush" | "object"; // Brush mode for partial deletion, object mode for complete removal
}

export class EraserTool extends BaseTool {
  public isErasing: boolean = false;
  private lastErasePoint: Point = new Point(0, 0);
  private erasePreview: Graphics | null = null;

  constructor() {
    super("eraser", "none"); // Custom cursor
    this.settings = {
      size: STROKE_SIZES.ERASER[2], // Start with 20px
      mode: "brush", // Default to brush mode for precision
    };
  }

  onPointerDown(event: FederatedPointerEvent, container: Container): void {
    this.isErasing = true;
      `üóëÔ∏è ERASER: Started precision erasing at (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
    );
      `üóëÔ∏è ERASER: Settings - Size: ${this.settings.size}px, Mode: ${this.settings.mode}`,
    );

    const localPoint = container.toLocal(event.global);
    this.lastErasePoint.copyFrom(localPoint);

    this.eraseAtPoint(event, container);
  }

  onPointerMove(event: FederatedPointerEvent, container: Container): void {
    this.updateCursorPosition(event);

    // Show preview of what would be erased
    this.showErasePreview(event, container);

    // Only erase if we're actively erasing (mouse button is pressed)
    if (this.isErasing) {
      const localPoint = container.toLocal(event.global);

      // Brush mode: continuous erasing along the path
      if (this.settings.mode === "brush") {
        this.brushErase(this.lastErasePoint, localPoint, container);
      } else {
        this.eraseAtPoint(event, container);
      }

      this.lastErasePoint.copyFrom(localPoint);
    }
  }

  onPointerUp(): void {
    this.isErasing = false;
    this.hideErasePreview();
  }

  onActivate(): void {
    super.onActivate();
    this.createProfessionalEraserCursor();
      `ÔøΩÔ∏è ERASER: Activated precision brush eraser - Size: ${this.settings.size}px, Mode: ${this.settings.mode}`,
    );
  }

  onDeactivate(): void {
    super.onDeactivate();
    this.isErasing = false;
    this.removeEraserCursor();
    this.hideErasePreview();
  }

  private eraseAtPoint(
    event: FederatedPointerEvent,
    container: Container,
  ): void {
    const globalPoint = event.global;
    const eraserRadius = this.settings.size / 2;

      `üóëÔ∏è ERASER: Precision erasing at point (${Math.round(globalPoint.x)}, ${Math.round(globalPoint.y)}) with radius ${eraserRadius}px`,
    );

    // Check all objects in the container
    for (let i = container.children.length - 1; i >= 0; i--) {
      const child = container.children[i];

      // LAYOUT PROTECTION: Skip protected objects
      if (this.isProtectedObject(child)) {
        continue;
      }

      // Get accurate bounds
      const bounds = child.getBounds();

      // Enhanced collision detection for precision
      if (
        this.precisionCollisionDetection(
          globalPoint.x,
          globalPoint.y,
          eraserRadius,
          bounds.x,
          bounds.y,
          bounds.width,
          bounds.height,
        )
      ) {
          `ÔøΩÔ∏è ERASER: Removing object (${child.constructor.name}) at bounds (${Math.round(bounds.x)}, ${Math.round(bounds.y)}, ${Math.round(bounds.width)}x${Math.round(bounds.height)})`,
        );
        container.removeChild(child);
        child.destroy();
      }
    }
  }

  private brushErase(
    fromPoint: Point,
    toPoint: Point,
    container: Container,
  ): void {
    // Create a path between the two points and erase along it
    const distance = Math.sqrt(
      Math.pow(toPoint.x - fromPoint.x, 2) +
        Math.pow(toPoint.y - fromPoint.y, 2),
    );

    // Sample points along the path for smooth erasing
    const steps = Math.max(1, Math.floor(distance / 5)); // Every 5 pixels

    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = fromPoint.x + (toPoint.x - fromPoint.x) * t;
      const y = fromPoint.y + (toPoint.y - fromPoint.y) * t;

      // Convert to global coordinates for erasing
      const globalPoint = container.toGlobal({ x, y });
      const mockEvent = {
        global: globalPoint,
        client: globalPoint,
      } as FederatedPointerEvent;

      this.eraseAtPoint(mockEvent, container);
    }
  }

  private showErasePreview(
    event: FederatedPointerEvent,
    container: Container,
  ): void {
    if (!this.erasePreview) {
      this.erasePreview = new Graphics();
      this.erasePreview.alpha = 0.3;
      container.addChild(this.erasePreview);
    }

    const localPoint = container.toLocal(event.global);
    const radius = this.settings.size / 2;

    this.erasePreview.clear();
    this.erasePreview.circle(localPoint.x, localPoint.y, radius);
    this.erasePreview.fill({ color: 0xff4444 }); // Red preview
    this.erasePreview.stroke({ width: 1, color: 0xff0000 });
  }

  private hideErasePreview(): void {
    if (this.erasePreview && this.erasePreview.parent) {
      this.erasePreview.parent.removeChild(this.erasePreview);
      this.erasePreview = null;
    }
  }

  private isProtectedObject(child: any): boolean {
    // LAYOUT PROTECTION: Skip objects that have layout-related names or are system objects
    if (
      child.name &&
      (child.name.includes("layout-") ||
        child.name.includes("grid-") ||
        child.name.includes("background-") ||
        child.name.includes("system-"))
    ) {
      return true;
    }

    // Skip objects with special tags
    if (child.tag && child.tag.includes("protected")) {
      return true;
    }

    return false;
  }

  private precisionCollisionDetection(
    circleX: number,
    circleY: number,
    radius: number,
    rectX: number,
    rectY: number,
    rectWidth: number,
    rectHeight: number,
  ): boolean {
    // Enhanced collision detection for better precision

    // Handle zero-width or zero-height objects
    if (rectWidth <= 0 || rectHeight <= 0) {
      return false;
    }

    // Find the closest point to the circle within the rectangle
    const closestX = Math.max(rectX, Math.min(circleX, rectX + rectWidth));
    const closestY = Math.max(rectY, Math.min(circleY, rectY + rectHeight));

    // Calculate the distance between the circle's center and this closest point
    const distanceX = circleX - closestX;
    const distanceY = circleY - closestY;

    // If the distance is less than the circle's radius, an intersection occurs
    const distanceSquared = distanceX * distanceX + distanceY * distanceY;
    return distanceSquared <= radius * radius;
  }

  private createProfessionalEraserCursor(): void {
    // Create a professional visual cursor for the eraser
    const cursorElement = document.createElement("div");
    cursorElement.style.position = "fixed";
    cursorElement.style.pointerEvents = "none";
    cursorElement.style.zIndex = "10000";
    cursorElement.style.width = `${this.settings.size}px`;
    cursorElement.style.height = `${this.settings.size}px`;
    cursorElement.style.border = "2px solid #ff6b6b";
    cursorElement.style.borderRadius = "50%";
    cursorElement.style.backgroundColor = "rgba(255, 107, 107, 0.15)";
    cursorElement.style.boxShadow = "0 0 8px rgba(255, 107, 107, 0.3)";
    cursorElement.style.transform = "translate(-50%, -50%)";
    cursorElement.id = "precision-eraser-cursor";

    // Add inner dot for precision
    const innerDot = document.createElement("div");
    innerDot.style.position = "absolute";
    innerDot.style.top = "50%";
    innerDot.style.left = "50%";
    innerDot.style.width = "2px";
    innerDot.style.height = "2px";
    innerDot.style.backgroundColor = "#ff0000";
    innerDot.style.borderRadius = "50%";
    innerDot.style.transform = "translate(-50%, -50%)";
    cursorElement.appendChild(innerDot);

    // Add mode indicator
    cursorElement.title = `üóëÔ∏è Precision Eraser - ${this.settings.mode} mode, ${this.settings.size}px`;

    document.body.appendChild(cursorElement);

    // Hide default cursor
    document.body.style.cursor = "none";
  }

  private updateCursorPosition(event: FederatedPointerEvent): void {
    const cursorElement = document.getElementById("precision-eraser-cursor");
    if (cursorElement) {
      cursorElement.style.left = `${event.client.x}px`;
      cursorElement.style.top = `${event.client.y}px`;
    }
  }

  private removeEraserCursor(): void {
    const cursorElement = document.getElementById("precision-eraser-cursor");
    if (cursorElement) {
      cursorElement.remove();
    }

    // Reset cursor
    document.body.style.cursor = "default";

    const canvasContainer = document.querySelector(
      ".coursebuilder__canvas",
    ) as HTMLElement;
    if (canvasContainer) {
      canvasContainer.style.cursor = "default";
    }
  }

  setMode(mode: "brush" | "object"): void {
    this.settings.mode = mode;

    // Update cursor tooltip
    const cursorElement = document.getElementById("precision-eraser-cursor");
    if (cursorElement) {
      cursorElement.title = `üóëÔ∏è Precision Eraser - ${mode} mode, ${this.settings.size}px`;
    }
  }

  updateSettings(settings: EraserSettings): void {
    this.settings = { ...this.settings, ...settings };

    // Update cursor size if it exists
    const cursorElement = document.getElementById("precision-eraser-cursor");
    if (cursorElement) {
      cursorElement.style.width = `${this.settings.size}px`;
      cursorElement.style.height = `${this.settings.size}px`;
      cursorElement.title = `üóëÔ∏è Precision Eraser - ${this.settings.mode} mode, ${this.settings.size}px`;
    }
  }

  // Get available eraser sizes for UI
  static getAvailableEraserSizes(): number[] {
    return STROKE_SIZES.ERASER;
  }

  // Get available eraser modes
  static getEraserModes(): string[] {
    return ["brush", "object"];
  }

  // Get eraser mode display names
  static getEraserModeNames(): { [key: string]: string } {
    return {
      brush: "Brush Mode (Continuous)",
      object: "Object Mode (Click to Delete)",
    };
  }
}
/**
 * Text Tool
 * Professional text area system with rich formatting and proper canvas integration
 */

import {
  FederatedPointerEvent,
  Container,
  Text,
  TextStyle,
  Point,
} from "pixi.js";
import { BaseTool } from "./ToolInterface";
import {
  PROFESSIONAL_COLORS,
  TEXT_SIZES,
  FONT_FAMILIES,
  TEXT_CONSTANTS,
} from "./SharedResources";

interface TextSettings {
  fontFamily: string;
  fontSize: number;
  color: string;
  fontWeight: string;
  fontStyle: string;
  align: string;
}

export class TextTool extends BaseTool {
  private activeTextArea: HTMLTextAreaElement | null = null;
  private textPosition: Point = new Point(0, 0);
  private canvasContainer: HTMLElement | null = null;

  constructor() {
    super("text", "text");
    this.settings = {
      fontFamily: FONT_FAMILIES[0], // Start with Inter
      fontSize: TEXT_SIZES[4], // Start with 16px
      color: PROFESSIONAL_COLORS[0], // Start with dark charcoal
      fontWeight: "normal",
      fontStyle: "normal",
      align: "left",
    };
  }

  onPointerDown(event: FederatedPointerEvent, container: Container): void {
      `üìù TEXT: Text placement at (${Math.round(event.global.x)}, ${Math.round(event.global.y)})`,
    );
      `üìù TEXT: Settings - Font: ${this.settings.fontFamily}, Size: ${this.settings.fontSize}px, Color: ${this.settings.color}`,
    );

    const localPoint = container.toLocal(event.global);
    this.textPosition.copyFrom(localPoint);

    // Find canvas container for proper positioning
    this.findCanvasContainer();

    this.createTextArea(event.global.x, event.global.y, container);
  }

  onPointerMove(): void {
    // Text tool doesn't need move events for placement
  }

  onPointerUp(): void {
    // Text tool doesn't need up events for placement
  }

  private findCanvasContainer(): void {
    // Try to find the canvas container element for proper positioning
    const canvasElement = document.querySelector("canvas");
    if (canvasElement) {
      this.canvasContainer = canvasElement.parentElement || document.body;
    } else {
      this.canvasContainer = document.body;
    }
  }

  private createTextArea(x: number, y: number, container: Container): void {
    // Remove any existing text area
    this.removeTextArea();

      `üìù TEXT: Creating professional text area at global (${Math.round(x)}, ${Math.round(y)})`,
    );

    // Create HTML textarea for professional text entry
    this.activeTextArea = document.createElement("textarea");

    // Professional styling
    this.activeTextArea.style.position = "absolute";
    this.activeTextArea.style.left = `${x}px`;
    this.activeTextArea.style.top = `${y}px`;
    this.activeTextArea.style.minWidth = `${TEXT_CONSTANTS.MIN_TEXT_AREA_SIZE.width}px`;
    this.activeTextArea.style.minHeight = `${TEXT_CONSTANTS.MIN_TEXT_AREA_SIZE.height}px`;
    this.activeTextArea.style.fontSize = `${this.settings.fontSize}px`;
    this.activeTextArea.style.fontFamily = this.settings.fontFamily;
    this.activeTextArea.style.fontWeight = this.settings.fontWeight;
    this.activeTextArea.style.fontStyle = this.settings.fontStyle;
    this.activeTextArea.style.color = this.settings.color;
    this.activeTextArea.style.textAlign = this.settings.align as any;
    this.activeTextArea.style.background = TEXT_CONSTANTS.TEXTAREA_BACKGROUND;
    this.activeTextArea.style.border = TEXT_CONSTANTS.TEXTAREA_BORDER;
    this.activeTextArea.style.outline = "none";
    this.activeTextArea.style.resize = "both";
    this.activeTextArea.style.zIndex = "1000";
    this.activeTextArea.style.padding = "8px";
    this.activeTextArea.style.borderRadius = "4px";
    this.activeTextArea.style.boxShadow = "0 2px 8px rgba(0,0,0,0.15)";
    this.activeTextArea.placeholder = "Enter your text here...";

    // Professional interaction
    this.activeTextArea.rows = 3;
    this.activeTextArea.cols = 30;

    // Add to appropriate container
    this.canvasContainer?.appendChild(this.activeTextArea);
    this.activeTextArea.focus();
    this.activeTextArea.select(); // Select all text for immediate editing


    // Handle text completion with improved events
    this.activeTextArea.addEventListener("blur", () => {
      // Small delay to allow other interactions
      setTimeout(() => {
        if (this.activeTextArea) {
          this.finalizeText(container);
        }
      }, 100);
    });

    this.activeTextArea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        // Ctrl+Enter or Cmd+Enter to finalize
        e.preventDefault();
        this.finalizeText(container);
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.removeTextArea();
      }
      // Allow normal Enter for line breaks
    });

    // Auto-resize textarea as user types
    this.activeTextArea.addEventListener("input", () => {
      this.autoResizeTextArea();
    });
  }

  private autoResizeTextArea(): void {
    if (!this.activeTextArea) return;

    // Reset height to auto to get proper scrollHeight
    this.activeTextArea.style.height = "auto";

    // Set height to scrollHeight with some padding
    const newHeight = Math.max(
      TEXT_CONSTANTS.MIN_TEXT_AREA_SIZE.height,
      this.activeTextArea.scrollHeight + 4,
    );

    this.activeTextArea.style.height = `${newHeight}px`;
  }

  private finalizeText(container: Container): void {
    if (!this.activeTextArea) return;

    const textContent = this.activeTextArea.value.trim();


    if (textContent) {
      // Create professional PixiJS text object
      const style = new TextStyle({
        fontFamily: this.settings.fontFamily,
        fontSize: this.settings.fontSize,
        fontWeight: this.settings.fontWeight,
        fontStyle: this.settings.fontStyle,
        fill: this.settings.color,
        align: this.settings.align as any,
        wordWrap: true,
        wordWrapWidth: 400, // Reasonable wrap width
        lineHeight: this.settings.fontSize * 1.2, // Professional line spacing
        padding: 4, // Prevent text clipping
      });

      const textObject = new Text({ text: textContent, style });
      textObject.position.set(this.textPosition.x, this.textPosition.y);
      textObject.eventMode = "static"; // Make it selectable for future tools

      container.addChild(textObject);

        `üìù TEXT: Professional text object created and added to canvas`,
      );
    }

    this.removeTextArea();
  }

  private removeTextArea(): void {
    if (this.activeTextArea && this.activeTextArea.parentNode) {
      this.activeTextArea.parentNode.removeChild(this.activeTextArea);
      this.activeTextArea = null;
    }
  }

  onDeactivate(): void {
    super.onDeactivate();
    this.removeTextArea();
  }

  updateSettings(settings: TextSettings): void {
    this.settings = { ...this.settings, ...settings };

    // Update active text area if it exists
    if (this.activeTextArea) {
      this.activeTextArea.style.fontSize = `${this.settings.fontSize}px`;
      this.activeTextArea.style.fontFamily = this.settings.fontFamily;
      this.activeTextArea.style.fontWeight = this.settings.fontWeight;
      this.activeTextArea.style.fontStyle = this.settings.fontStyle;
      this.activeTextArea.style.color = this.settings.color;
      this.activeTextArea.style.textAlign = this.settings.align as any;
    }
  }

  // Get available fonts for UI
  static getAvailableFonts(): string[] {
    return FONT_FAMILIES;
  }

  // Get available text sizes for UI
  static getAvailableTextSizes(): number[] {
    return TEXT_SIZES;
  }

  // Get available colors for UI
  static getAvailableColors(): string[] {
    return PROFESSIONAL_COLORS;
  }

  // Get text alignment options
  static getAlignmentOptions(): string[] {
    return ["left", "center", "right", "justify"];
  }

  // Get font weight options
  static getFontWeights(): string[] {
    return [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
    ];
  }

  // Get font style options
  static getFontStyles(): string[] {
    return ["normal", "italic", "oblique"];
  }
}
/**
 * Course Builder Main Controller
 * Coordinates all coursebuilder components using modern modular architecture
 * Single Responsibility: Component coordination and initialization only
 */

import { PixiCanvas } from "./canvas/PixiCanvas";
import { ToolStateManager } from "./ui/ToolStateManager";
import { UIEventHandler } from "./ui/UIEventHandler";
import { MarginSettingsManager } from "./managers/MarginSettingsManager";
import { PageManager } from "./managers/PageManager";
import { MediaManagerRefactored as MediaManager } from "./media/MediaManagerRefactored";
import { FontManager } from "./font/FontManager";
import { CommandManager } from "./commands/CommandManager";

export class CourseBuilder {
  private pixiCanvas: PixiCanvas | null = null;
  private toolStateManager: ToolStateManager;
  private uiEventHandler: UIEventHandler;
  private marginSettings: MarginSettingsManager;
  private pageManager: PageManager;
  private mediaManager: MediaManager;
  private fontManager: FontManager;
  private commandManager: CommandManager;
  private canvasContainer: HTMLElement | null = null;
  private currentCourseId: string | null = null;

  constructor() {
    // Don't look for canvas container immediately - wait until needed
    this.canvasContainer = null;

    // Initialize all managers
    this.commandManager = new CommandManager();
    this.toolStateManager = new ToolStateManager();
    this.marginSettings = new MarginSettingsManager();
    this.pageManager = new PageManager();
    this.mediaManager = new MediaManager();
    this.fontManager = new FontManager();
    this.uiEventHandler = new UIEventHandler(this.toolStateManager);

    this.init();
  }

  /**
   * Initialize the coursebuilder
   */
  private async init(): Promise<void> {

    // Only initialize PIXI canvas if we're on the create section or if create section is active
    const currentHash = window.location.hash.substring(1);
    const createSection = document.getElementById("create");
    const isCreateActive = createSection?.classList.contains("section--active");
    
    if (currentHash === "create" || isCreateActive) {
      await this.initializePixiCanvas();
    } else {
    }

    this.setupComponentCallbacks();
    this.bindGlobalEvents();


    // Dispatch a ready event to let other components know CourseBuilder is available
    const readyEvent = new CustomEvent("coursebuilder:ready", {
      detail: { courseBuilder: this },
    });
    window.dispatchEvent(readyEvent);
  }

  /**
   * Initialize PIXI canvas
   */
  private async initializePixiCanvas(): Promise<void> {
    // Find canvas container when we actually need it
    this.canvasContainer = document.getElementById("canvas-container");
    
    if (!this.canvasContainer) {
      console.error("‚ùå Canvas container not found");
      return;
    }

    try {
      this.pixiCanvas = new PixiCanvas("canvas-container");
      await this.pixiCanvas.init();

    } catch (error) {
      console.error("‚ùå Failed to initialize PIXI Canvas:", error);
    }
  }

  /**
   * Setup callbacks between components
   */
  private setupComponentCallbacks(): void {
    // Tool state changes
    this.uiEventHandler.setOnToolChange((toolName: string) => {
      if (this.pixiCanvas) {
        this.pixiCanvas.setTool(toolName);
      }
    });

    // Color changes
    this.uiEventHandler.setOnColorChange((color: string) => {
      if (this.pixiCanvas) {
        this.pixiCanvas.updateToolColor(color);
      }
    });

    // Page changes
    this.pageManager.setOnPageChange((page: any) => {
      // Handle page change logic here
    });

    // Margin changes
    this.marginSettings.setOnMarginChange((margins) => {
      // Handle margin changes here
    });

    // Font changes
    this.fontManager.setOnFontChange((fontFamily: string) => {
      // Handle font changes here
    });

    // Media selection
    this.mediaManager.setOnMediaSelection((mediaType: string) => {
      // Handle media selection here
    });
  }

  /**
   * Bind global events
   */
  private bindGlobalEvents(): void {
    // Canvas actions
    document.addEventListener("clearCanvas", () => this.clearCanvas());
    document.addEventListener("clearAll", () => this.clearAll());
    document.addEventListener("addPage", () => this.addNewPage());
    document.addEventListener("toggleLayout", () => this.toggleLayout());

    // Media integration
    document.addEventListener("addMediaToCanvas", (event: any) => {
      this.addMediaToCanvas(event.detail.url, event.detail.type);
    });

    // Keyboard shortcuts for undo/redo
    document.addEventListener("keydown", (event) => {
      const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
      const undoKeyPressed =
        (isMac ? event.metaKey : event.ctrlKey) && event.key === "z";
      const redoKeyPressed =
        (isMac ? event.metaKey : event.ctrlKey) && event.key === "y";

      if (undoKeyPressed) {
        event.preventDefault();
        this.undo();
      } else if (redoKeyPressed) {
        event.preventDefault();
        this.redo();
      }
    });
  }

  /**
   * Undo the last command
   */
  public undo(): void {
    this.commandManager.undo();
  }

  /**
   * Redo the last undone command
   */
  public redo(): void {
    this.commandManager.redo();
  }

  /**
   * Set the current course ID and pass it to margin settings
   */
  public setCourseId(courseId: string): void {
    this.currentCourseId = courseId;

    // Pass the course ID to margin settings so it can load/save to database
    this.marginSettings.setCourseId(courseId);
  }

  /**
   * Initialize canvas specifically for the create section (called when section becomes active)
   */
  public async initializeCanvasForCreateSection(): Promise<void> {
    if (this.pixiCanvas) {
      return;
    }
    
    await this.initializePixiCanvas();
    
    // Reapply any settings that might have been set before canvas was ready
    if (this.currentCourseId) {
      this.marginSettings.setCourseId(this.currentCourseId);
    }
  }

  /**
   * Reinitialize PIXI canvas (useful when switching to create section)
   */
  public async reinitializeCanvas(): Promise<void> {
    
    // Destroy existing canvas if it exists
    if (this.pixiCanvas) {
      this.pixiCanvas.destroy();
      this.pixiCanvas = null;
    }
    
    // Clear the canvas container
    const canvasContainer = document.getElementById("canvas-container");
    if (canvasContainer) {
      canvasContainer.innerHTML = "";
    }
    
    // Reinitialize
    await this.initializePixiCanvas();
    
    // Reapply tool states and settings
    this.setupComponentCallbacks();
    
  }

  /**
   * Get the current course ID
   */
  public getCourseId(): string | null {
    return this.currentCourseId;
  }

  /**
   * Clear canvas content
   */
  public clearCanvas(): void {
    if (this.pixiCanvas) {
      this.pixiCanvas.clearCanvas();
    }
  }

  /**
   * Clear all content
   */
  public clearAll(): void {
    if (this.pixiCanvas) {
      this.pixiCanvas.clearAll();
    }
  }

  /**
   * Add new page
   */
  private addNewPage(): void {
    this.pageManager.addNewPage();
  }

  /**
   * Toggle layout visibility
   */
  private toggleLayout(): void {
    if (this.pixiCanvas) {
      // PIXI.js doesn't have the same layout visibility concept
      // This could be implemented as layer visibility in PIXI
    }
  }

  /**
   * Add media to canvas
   */
  private addMediaToCanvas(url: string, type: string): void {
    if (this.pixiCanvas) {
      // Add media to canvas (implement based on media type)
    }
  }

  /**
   * Resize canvas
   */
  public resizeCanvas(width: number, height: number): void {
    if (this.pixiCanvas) {
      this.pixiCanvas.resize(width, height);
    }
  }

  /**
   * Get current tool
   */
  public getCurrentTool(): string {
    return this.toolStateManager.getCurrentTool();
  }

  /**
   * Get tool settings
   */
  public getToolSettings(): any {
    return this.toolStateManager.getToolSettings();
  }

  /**
   * Get page manager
   */
  public getPageManager(): PageManager {
    return this.pageManager;
  }

  /**
   * Get PIXI canvas instance
   */
  public getPixiCanvas(): PixiCanvas | null {
    return this.pixiCanvas;
  }

  /**
   * Get command manager
   */
  public getCommandManager(): CommandManager {
    return this.commandManager;
  }

  /**
   * Cleanup
   */
  public destroy(): void {
    // Only destroy components that have destroy methods
    this.uiEventHandler.destroy();
    if (this.pixiCanvas) {
      this.pixiCanvas.destroy();
    }
    this.marginSettings.destroy();
    this.pageManager.destroy();
    this.mediaManager.destroy();
    this.fontManager.destroy();

    if (this.pixiCanvas) {
      this.pixiCanvas.destroy();
    }

  }
}

// Global debug helper
(window as any).courseBuilderDebug = {
  getInstance: () => {
    return (window as any).courseBuilder;
  },
  getState: () => {
    const instance = (window as any).courseBuilder;
    if (!instance) return null;

    return {
      currentTool: instance.getCurrentTool(),
      toolSettings: instance.getToolSettings(),
      pageCount: instance.getPageManager().getPageCount(),
      currentPage: instance.getPageManager().getCurrentPageIndex(),
    };
  },
};
/**
 * Layout Renderer
 * Handles PixiJS rendering of layout structures
 * Focused on visual rendering only
 */

import { Container, Graphics, Text, TextStyle } from "pixi.js";
import type { RenderedBlock, RenderedArea } from "./LayoutTypes";

export class LayoutRenderer {
  private layoutContainer: Container;

  constructor(layoutContainer: Container) {
    this.layoutContainer = layoutContainer;
  }

  /**
   * Render complete layout structure
   */
  renderLayoutStructure(
    renderedBlocks: RenderedBlock[],
    showLabels: boolean = true,
  ): void {
    // Clear previous rendering
    this.layoutContainer.removeChildren();

      `üé® Rendering ${renderedBlocks.length} blocks with labels: ${showLabels}`,
    );

    // Render each block
    renderedBlocks.forEach((block) => {
      this.renderBlock(block, showLabels);
    });
  }

  /**
   * Render individual block
   */
  private renderBlock(block: RenderedBlock, showLabels: boolean): void {
    // Block background
    const blockGraphics = new Graphics();
    blockGraphics.rect(block.x, block.y, block.width, block.height);
    blockGraphics.fill({
      color: this.getBlockColor(block.blockId),
      alpha: 0.1,
    });
    blockGraphics.stroke({
      width: 2,
      color: this.getBlockColor(block.blockId),
      alpha: 0.8,
    });

    blockGraphics.label = `layout-block-${block.blockId}`;
    blockGraphics.interactive = false; // Prevent user interaction
    this.layoutContainer.addChild(blockGraphics);

    // Block label
    if (showLabels) {
      const blockLabel = new Text({
        text: this.getBlockDisplayName(block.blockId),
        style: new TextStyle({
          fontSize: 16,
          fill: this.getBlockColor(block.blockId),
          fontWeight: "bold",
          fontFamily: "Arial",
        }),
      });

      blockLabel.position.set(block.x + 10, block.y + 5);
      blockLabel.label = `layout-block-label-${block.blockId}`;
      blockLabel.interactive = false;
      this.layoutContainer.addChild(blockLabel);
    }

    // Render areas within the block
    block.areas.forEach((area) => {
      this.renderArea(area, showLabels);
    });
  }

  /**
   * Render individual area
   */
  private renderArea(area: RenderedArea, showLabels: boolean): void {
    // Area background
    const areaGraphics = new Graphics();
    areaGraphics.rect(area.x, area.y, area.width, area.height);
    areaGraphics.fill({ color: 0xffffff, alpha: 0.5 });
    areaGraphics.stroke({ width: 1, color: 0x999999, alpha: 0.4 });

    areaGraphics.label = `layout-area-${area.areaId}`;
    areaGraphics.interactive = false; // Prevent user interaction
    this.layoutContainer.addChild(areaGraphics);

    // Area label
    if (showLabels) {
      const areaLabel = new Text({
        text: this.getAreaDisplayName(area.areaId),
        style: new TextStyle({
          fontSize: 12,
          fill: 0x666666,
          fontFamily: "Arial",
        }),
      });

      areaLabel.position.set(area.x + 5, area.y + 5);
      areaLabel.label = `layout-area-label-${area.areaId}`;
      areaLabel.interactive = false;
      this.layoutContainer.addChild(areaLabel);
    }
  }

  /**
   * Get block color for visual distinction
   */
  private getBlockColor(blockId: string): number {
    const colors: Record<string, number> = {
      header: 0x4a90e2,
      program: 0x7ed321,
      resources: 0xf5a623,
      content: 0xd0021b,
      assignment: 0x9013fe,
      footer: 0x50e3c2,
    };
    return colors[blockId] || 0x999999;
  }

  /**
   * Get block display name
   */
  private getBlockDisplayName(blockId: string): string {
    const names: Record<string, string> = {
      header: "Header",
      program: "Program",
      resources: "Resources",
      content: "Content",
      assignment: "Assignment",
      footer: "Footer",
    };
    return names[blockId] || blockId;
  }

  /**
   * Get area display name
   */
  private getAreaDisplayName(areaId: string): string {
    // Convert kebab-case to Title Case
    return areaId
      .split("-")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");
  }

  /**
   * Clear all rendered content
   */
  clear(): void {
    this.layoutContainer.removeChildren();
  }

  /**
   * Update layout container
   */
  setLayoutContainer(container: Container): void {
    this.layoutContainer = container;
  }
}
/**
 * Layout Calculator
 * Handles mathematical calculations for layout positioning and sizing
 * Pure functions - no state, no side effects
 */

import type {
  LayoutBlock,
  RenderedBlock,
  RenderedArea,
  LessonDuration,
} from "./LayoutTypes";
import { LESSON_DURATIONS } from "./LayoutTypes";

export class LayoutCalculator {
  /**
   * Calculate total canvases needed for a course
   */
  static calculateTotalCanvases(
    scheduledSessions: number,
    lessonDurationMinutes: number,
  ): number {
    const lessonDuration = this.determineLessonDuration(lessonDurationMinutes);
    return Math.ceil(scheduledSessions * lessonDuration.canvasMultiplier);
  }

  /**
   * Determine lesson duration type based on minutes
   */
  static determineLessonDuration(minutes: number): LessonDuration {
    return (
      LESSON_DURATIONS.find((duration) => minutes <= duration.maxMinutes) ||
      LESSON_DURATIONS[LESSON_DURATIONS.length - 1]
    );
  }

  /**
   * Calculate block positions within canvas
   */
  static calculateBlockPositions(
    blocks: LayoutBlock[],
    canvasWidth: number,
    canvasHeight: number,
    margins = { top: 40, bottom: 40, left: 60, right: 60 },
  ): RenderedBlock[] {
    const availableWidth = canvasWidth - margins.left - margins.right;
    const availableHeight = canvasHeight - margins.top - margins.bottom;
    let currentY = margins.top;

    return blocks.map((block) => {
      const blockHeight = (availableHeight * block.heightPercentage) / 100;

      // Header and Footer span full width, others use margin constraints
      const isFullWidth = block.id === "header" || block.id === "footer";
      const blockX = isFullWidth ? 0 : margins.left;
      const blockWidth = isFullWidth ? canvasWidth : availableWidth;
      const blockY = isFullWidth
        ? block.id === "header"
          ? 0
          : currentY
        : currentY;

      // Calculate canvas areas within the block
      const areas = this.calculateCanvasAreas(
        block,
        blockX,
        blockY,
        blockWidth,
        blockHeight,
      );

      const renderedBlock: RenderedBlock = {
        blockId: block.id,
        x: blockX,
        y: blockY,
        width: blockWidth,
        height: blockHeight,
        areas,
      };

      // Update Y position for next block
      if (block.id === "header") {
        currentY = blockHeight; // Next block starts after header
      } else if (block.id !== "footer") {
        currentY += blockHeight;
      }

      return renderedBlock;
    });
  }

  /**
   * Calculate canvas areas within a block
   */
  private static calculateCanvasAreas(
    block: LayoutBlock,
    blockX: number,
    blockY: number,
    blockWidth: number,
    blockHeight: number,
  ): RenderedArea[] {
    if (!block.canvasAreas || block.canvasAreas.length === 0) {
      return [];
    }

    const areaHeight = blockHeight / block.canvasAreas.length;

    return block.canvasAreas.map((area, index) => ({
      areaId: area.id,
      x: blockX + 10, // Small padding
      y: blockY + index * areaHeight + 10,
      width: blockWidth - 20,
      height: areaHeight - 20,
    }));
  }

  /**
   * Calculate canvas dimensions based on lesson type
   */
  static calculateCanvasDimensions(lessonDuration: LessonDuration): {
    width: number;
    height: number;
  } {
    // Base A4-like dimensions
    const baseWidth = 794;
    const baseHeight = 1123;

    // Adjust based on lesson duration if needed
    return {
      width: baseWidth,
      height: Math.floor(baseHeight * lessonDuration.canvasMultiplier),
    };
  }
}
/**
 * Unified Layout System Types
 * Combines the best of custom pedagogical layouts with PixiJS Layout v3 integration
 */

export interface LayoutBlock {
  id: string;
  name: string;
  heightPercentage: number;
  isRequired: boolean;
  canvasAreas?: CanvasArea[];
  // PixiJS Layout v3 compatibility
  type?: "header" | "content" | "resources" | "assignment" | "footer";
  styles?: {
    display?: "flex" | "none";
    flexDirection?: "row" | "column";
    justifyContent?:
      | "flex-start"
      | "flex-end"
      | "center"
      | "space-between"
      | "space-around";
    alignItems?: "flex-start" | "flex-end" | "center" | "stretch";
    backgroundColor?: string;
    borderRadius?: number;
    padding?: number;
    gap?: number;
    flex?: number;
    width?: string | number;
    height?: string | number;
  };
}

export interface CanvasArea {
  id: string;
  name: string;
  type: "instruction" | "student" | "teacher";
  allowsDrawing: boolean;
  allowsMedia: boolean;
  allowsText: boolean;
}

export interface LessonDuration {
  type: "mini" | "regular" | "double" | "triple" | "longer";
  maxMinutes: number;
  canvasMultiplier: number;
}

export interface LayoutTemplate {
  id: string;
  name: string;
  blocks: LayoutBlock[];
  socialForm?: string;
  mediaTypes?: string[];
}

export interface CourseLayout {
  id: string;
  courseId: string;
  templateId: string;
  totalCanvases: number;
  scheduledSessions: number;
  lessonDuration: LessonDuration;
  canvases: CanvasLayout[];
}

export interface CanvasLayout {
  id: string;
  sessionNumber: number;
  canvasNumber: number;
  blocks: RenderedBlock[];
}

export interface RenderedBlock {
  blockId: string;
  x: number;
  y: number;
  width: number;
  height: number;
  areas: RenderedArea[];
}

export interface RenderedArea {
  areaId: string;
  x: number;
  y: number;
  width: number;
  height: number;
  content?: any; // Will hold drawings, media, text content
}

// Default layout blocks with their proportions
export const DEFAULT_BLOCKS: LayoutBlock[] = [
  {
    id: "header",
    name: "Header",
    heightPercentage: 8,
    isRequired: true,
    canvasAreas: [
      {
        id: "header-instruction-title",
        name: "Instruction Title",
        type: "instruction",
        allowsDrawing: false,
        allowsMedia: false,
        allowsText: true,
      },
      {
        id: "header-content-area",
        name: "Header Content",
        type: "teacher",
        allowsDrawing: false,
        allowsMedia: false,
        allowsText: true,
      },
    ],
  },
  {
    id: "program",
    name: "Program",
    heightPercentage: 15,
    isRequired: true,
    canvasAreas: [
      {
        id: "program-instruction-area",
        name: "Instruction Area",
        type: "instruction",
        allowsDrawing: true,
        allowsMedia: true,
        allowsText: true,
      },
    ],
  },
  {
    id: "resources",
    name: "Resources",
    heightPercentage: 12,
    isRequired: false,
    canvasAreas: [
      {
        id: "resources-student-title",
        name: "Student Title",
        type: "student",
        allowsDrawing: false,
        allowsMedia: false,
        allowsText: true,
      },
      {
        id: "resources-student-area",
        name: "Student Area",
        type: "student",
        allowsDrawing: true,
        allowsMedia: true,
        allowsText: true,
      },
    ],
  },
  {
    id: "content",
    name: "Content",
    heightPercentage: 50,
    isRequired: true,
    canvasAreas: [
      {
        id: "content-teacher-title",
        name: "Teacher Title",
        type: "teacher",
        allowsDrawing: false,
        allowsMedia: false,
        allowsText: true,
      },
      {
        id: "content-teacher-area",
        name: "Teacher Area",
        type: "teacher",
        allowsDrawing: true,
        allowsMedia: true,
        allowsText: true,
      },
    ],
  },
  {
    id: "assignment",
    name: "Assignment",
    heightPercentage: 10,
    isRequired: false,
    canvasAreas: [
      {
        id: "assignment-instruction-area",
        name: "Instruction Area",
        type: "instruction",
        allowsDrawing: true,
        allowsMedia: true,
        allowsText: true,
      },
    ],
  },
  {
    id: "footer",
    name: "Footer",
    heightPercentage: 5,
    isRequired: true,
    canvasAreas: [
      {
        id: "footer-content-area",
        name: "Footer Content",
        type: "instruction",
        allowsDrawing: false,
        allowsMedia: false,
        allowsText: true,
      },
    ],
  },
];

// Lesson duration configurations
export const LESSON_DURATIONS: LessonDuration[] = [
  { type: "mini", maxMinutes: 30, canvasMultiplier: 1 },
  { type: "regular", maxMinutes: 60, canvasMultiplier: 2 },
  { type: "double", maxMinutes: 120, canvasMultiplier: 4 },
  { type: "triple", maxMinutes: 180, canvasMultiplier: 8 },
  { type: "longer", maxMinutes: 999, canvasMultiplier: 16 },
];
/**
 * Canvas Navigation Manager
 * Handles navigation between multiple canvases, thumbnails, and table of contents
 */

import type { CourseLayout, CanvasLayout } from "./LayoutTypes";

interface CanvasThumbnail {
  id: string;
  sessionNumber: number;
  canvasNumber: number;
  element: HTMLElement;
  isActive: boolean;
}

export class CanvasNavigator {
  private thumbnails: CanvasThumbnail[] = [];
  private currentCanvasIndex: number = 0;
  private tocContainer: HTMLElement | null = null;
  private onCanvasChangeCallback: ((canvasIndex: number) => void) | null = null;

  constructor(tocContainerId: string = "coursebuilder__toc") {
    this.tocContainer = document.getElementById(tocContainerId);
    if (!this.tocContainer) {
      console.warn(`TOC container with id "${tocContainerId}" not found`);
    }
  }

  /**
   * Set callback for canvas change events
   */
  setOnCanvasChange(callback: (canvasIndex: number) => void): void {
    this.onCanvasChangeCallback = callback;
  }

  /**
   * Generate navigation for a course layout
   */
  generateNavigation(courseLayout: CourseLayout): void {
    if (!this.tocContainer) return;

    this.tocContainer.innerHTML = "";
    this.thumbnails = [];

    // Create header with course summary
    this.createNavigationHeader(courseLayout);

    // Create thumbnail for each canvas
    courseLayout.canvases.forEach((canvas, index) => {
      const thumbnail = this.createCanvasThumbnail(canvas, index);
      this.thumbnails.push(thumbnail);
      this.tocContainer!.appendChild(thumbnail.element);
    });

    // Set first canvas as active
    if (this.thumbnails.length > 0) {
      this.setActiveCanvas(0);
    }
  }

  /**
   * Create navigation header with course summary
   */
  private createNavigationHeader(courseLayout: CourseLayout): void {
    const header = document.createElement("div");
    header.className = "canvas-toc__header";
    header.innerHTML = `
      <h3>Course Navigation</h3>
      <div class="canvas-toc__summary">
        Total Sessions: ${courseLayout.scheduledSessions}<br>
        Total Canvases: ${courseLayout.totalCanvases}<br>
        Lesson Duration: ${courseLayout.lessonDuration.type}
      </div>
    `;

    const controls = document.createElement("div");
    controls.className = "canvas-toc__controls";
    controls.innerHTML = `
      <button class="canvas-nav-btn canvas-nav-btn--prev" title="Previous Canvas">
        <span class="canvas-nav-btn__icon">‚Üê</span>
      </button>
      <span class="canvas-nav-current">
        Canvas <span class="current-number">1</span> of ${courseLayout.totalCanvases}
      </span>
      <button class="canvas-nav-btn canvas-nav-btn--next" title="Next Canvas">
        <span class="canvas-nav-btn__icon">‚Üí</span>
      </button>
    `;

    // Add event listeners
    const prevBtn = controls.querySelector(
      ".canvas-nav-btn--prev",
    ) as HTMLElement;
    const nextBtn = controls.querySelector(
      ".canvas-nav-btn--next",
    ) as HTMLElement;

    prevBtn?.addEventListener("click", () =>
      this.navigateToCanvas(this.currentCanvasIndex - 1),
    );
    nextBtn?.addEventListener("click", () =>
      this.navigateToCanvas(this.currentCanvasIndex + 1),
    );

    header.appendChild(controls);
    this.tocContainer!.appendChild(header);
  }

  /**
   * Create thumbnail for a canvas
   */
  private createCanvasThumbnail(
    canvas: CanvasLayout,
    index: number,
  ): CanvasThumbnail {
    const thumbnail = document.createElement("div");
    thumbnail.className = "canvas-thumbnail";
    thumbnail.dataset.canvasIndex = index.toString();

    // Create visual preview of canvas layout
    const preview = document.createElement("div");
    preview.className = "canvas-thumbnail__preview";

    // Add miniature blocks
    canvas.blocks.forEach((block) => {
      const blockElement = document.createElement("div");
      blockElement.className = `canvas-thumbnail__block canvas-thumbnail__block--${block.blockId}`;

      // Scale down the block proportionally
      const scaleX = 0.1; // 10% of original width
      const scaleY = 0.1; // 10% of original height

      blockElement.style.cssText = `
        position: absolute;
        left: ${block.x * scaleX}px;
        top: ${block.y * scaleY}px;
        width: ${block.width * scaleX}px;
        height: ${block.height * scaleY}px;
      `;

      preview.appendChild(blockElement);
    });

    // Create label
    const label = document.createElement("div");
    label.className = "canvas-thumbnail__label";

    const canvasTypeName = this.getCanvasTypeName(
      canvas.sessionNumber,
      canvas.canvasNumber,
    );
    label.innerHTML = `
      <div class="canvas-thumbnail__session">Session ${canvas.sessionNumber}</div>
      <div class="canvas-thumbnail__type">${canvasTypeName}</div>
      <div class="canvas-thumbnail__number">${canvas.canvasNumber}</div>
    `;

    thumbnail.appendChild(preview);
    thumbnail.appendChild(label);

    // Add click handler
    thumbnail.addEventListener("click", () => {
      this.navigateToCanvas(index);
    });

    return {
      id: canvas.id,
      sessionNumber: canvas.sessionNumber,
      canvasNumber: canvas.canvasNumber,
      element: thumbnail,
      isActive: false,
    };
  }

  /**
   * Navigate to specific canvas
   */
  navigateToCanvas(index: number): void {
    if (index < 0 || index >= this.thumbnails.length) return;

    // Update active states
    this.setActiveCanvas(index);

    // Update current canvas counter
    const currentNumberSpan =
      this.tocContainer?.querySelector(".current-number");
    if (currentNumberSpan) {
      currentNumberSpan.textContent = (index + 1).toString();
    }

    // Trigger callback
    if (this.onCanvasChangeCallback) {
      this.onCanvasChangeCallback(index);
    }
  }

  /**
   * Set active canvas
   */
  private setActiveCanvas(index: number): void {
    // Remove active class from all thumbnails
    this.thumbnails.forEach((thumbnail) => {
      thumbnail.isActive = false;
      thumbnail.element.classList.remove("canvas-thumbnail--active");
    });

    // Set new active canvas
    if (this.thumbnails[index]) {
      this.thumbnails[index].isActive = true;
      this.thumbnails[index].element.classList.add("canvas-thumbnail--active");
      this.currentCanvasIndex = index;
    }
  }

  /**
   * Get canvas type name for display
   */
  private getCanvasTypeName(
    _sessionNumber: number,
    canvasNumber: number,
  ): string {
    if (canvasNumber === 1) return "Opening";
    if (canvasNumber === 2) return "Development";
    if (canvasNumber === 3) return "Closing";
    return `Canvas ${canvasNumber}`;
  }

  /**
   * Get current canvas index
   */
  getCurrentCanvasIndex(): number {
    return this.currentCanvasIndex;
  }

  /**
   * Get total canvas count
   */
  getTotalCanvases(): number {
    return this.thumbnails.length;
  }
}
/**
 * Course Layout Factory
 * Orchestrates layout creation by coordinating all layout components
 * This is the main interface that replaces the monolithic LayoutManager
 */

import type { CourseLayout, CanvasLayout, LayoutBlock } from "./LayoutTypes";
import { LayoutCalculator } from "./LayoutCalculator";
import { CanvasNavigator } from "./CanvasNavigator";
import { LayoutRenderer } from "./LayoutRenderer";
import { DEFAULT_BLOCKS } from "./LayoutTypes";
import { Container } from "pixi.js";

export class CourseLayoutFactory {
  private canvasWidth: number;
  private canvasHeight: number;
  private navigator: CanvasNavigator;
  private renderer: LayoutRenderer | null = null;

  constructor(
    canvasWidth: number = 794,
    canvasHeight: number = 1123,
    tocContainerId: string = "coursebuilder__toc",
  ) {
    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;
    this.navigator = new CanvasNavigator(tocContainerId);

      `üè≠ CourseLayoutFactory created with dimensions: ${this.canvasWidth}x${this.canvasHeight}`,
    );
  }

  /**
   * Create complete course layout with all canvases
   */
  createCourseLayout(
    courseId: string,
    templateId: string,
    scheduledSessions: number,
    lessonDurationMinutes: number,
    customBlocks?: LayoutBlock[],
  ): CourseLayout {
    const blocks = customBlocks || DEFAULT_BLOCKS;
    const totalCanvases = LayoutCalculator.calculateTotalCanvases(
      scheduledSessions,
      lessonDurationMinutes,
    );
    const lessonDuration = LayoutCalculator.determineLessonDuration(
      lessonDurationMinutes,
    );

      `üèóÔ∏è Creating course layout: ${totalCanvases} canvases for ${scheduledSessions} sessions`,
    );

    // Create all canvas layouts
    const canvases: CanvasLayout[] = [];
    let sessionNumber = 1;
    let canvasNumber = 1;

    for (let i = 0; i < totalCanvases; i++) {
      const canvas = this.createCanvasLayout(
        `${courseId}-canvas-${i + 1}`,
        sessionNumber,
        canvasNumber,
        blocks,
      );
      canvases.push(canvas);

      // Update session and canvas numbers
      canvasNumber++;
      if (canvasNumber > lessonDuration.canvasMultiplier) {
        sessionNumber++;
        canvasNumber = 1;
      }
    }

    const courseLayout: CourseLayout = {
      id: `course-layout-${courseId}`,
      courseId,
      templateId,
      totalCanvases,
      scheduledSessions,
      lessonDuration,
      canvases,
    };

    // Generate navigation
    this.navigator.generateNavigation(courseLayout);

    return courseLayout;
  }

  /**
   * Create layout for individual canvas
   */
  createCanvasLayout(
    canvasId: string,
    sessionNumber: number,
    canvasNumber: number,
    blocks: LayoutBlock[],
  ): CanvasLayout {
    const renderedBlocks = LayoutCalculator.calculateBlockPositions(
      blocks,
      this.canvasWidth,
      this.canvasHeight,
    );

    return {
      id: canvasId,
      sessionNumber,
      canvasNumber,
      blocks: renderedBlocks,
    };
  }

  /**
   * Initialize renderer with PixiJS container
   */
  initializeRenderer(layoutContainer: Container): void {
    this.renderer = new LayoutRenderer(layoutContainer);
  }

  /**
   * Render layout structure (requires renderer to be initialized)
   */
  renderLayout(canvasLayout: CanvasLayout, showLabels: boolean = true): void {
    if (!this.renderer) {
      throw new Error(
        "Renderer not initialized. Call initializeRenderer() first.",
      );
    }
    this.renderer.renderLayoutStructure(canvasLayout.blocks, showLabels);
  }

  /**
   * Get navigation instance
   */
  getNavigator(): CanvasNavigator {
    return this.navigator;
  }

  /**
   * Get renderer instance
   */
  getRenderer(): LayoutRenderer | null {
    return this.renderer;
  }

  /**
   * Update canvas dimensions
   */
  updateDimensions(width: number, height: number): void {
    this.canvasWidth = width;
    this.canvasHeight = height;
  }

  /**
   * Calculate total canvases (static utility)
   */
  static calculateTotalCanvases(
    scheduledSessions: number,
    lessonDurationMinutes: number,
  ): number {
    return LayoutCalculator.calculateTotalCanvases(
      scheduledSessions,
      lessonDurationMinutes,
    );
  }
}
/**
 * Margin Settings Manager
 * Manages margin controls and settings for the coursebuilder interface
 * Single Responsibility: Margin configuration and UI updates only
 */

import { marginSettingsHandler } from "../../backend/courses/marginSettings";

export class MarginSettingsManager {
  private marginInputs: { [key: string]: HTMLInputElement } = {};
  private marginValues: { [key: string]: number } = {
    top: 20,
    right: 20,
    bottom: 20,
    left: 20,
  };
  private onMarginChangeCallback:
    | ((margins: { [key: string]: number }) => void)
    | null = null;

  constructor() {
    this.initializeMarginInputs();
    this.bindMarginEvents();
  }

  /**
   * Set callback for margin changes
   */
  setOnMarginChange(
    callback: (margins: { [key: string]: number }) => void,
  ): void {
    this.onMarginChangeCallback = callback;
  }

  /**
   * Set course ID for database persistence
   */
  setCourseId(courseId: string): void {
    marginSettingsHandler.setCourseId(courseId);
  }

  /**
   * Initialize margin input elements
   */
  private initializeMarginInputs(): void {
    const marginInputIds = [
      "marginTop",
      "marginRight",
      "marginBottom",
      "marginLeft",
    ];

    marginInputIds.forEach((id) => {
      const input = document.getElementById(id) as HTMLInputElement;
      if (input) {
        const marginKey = id.replace("margin", "").toLowerCase();
        this.marginInputs[marginKey] = input;
        input.value = this.marginValues[marginKey].toString();
      }
    });
  }

  /**
   * Bind margin input events
   */
  private bindMarginEvents(): void {
    Object.entries(this.marginInputs).forEach(([key, input]) => {
      const inputHandler = () => this.handleMarginChange(key, input);
      const changeHandler = () => this.handleMarginChange(key, input);

      input.addEventListener("input", inputHandler);
      input.addEventListener("change", changeHandler);

      // Store handlers for cleanup
      (input as any).__inputHandler = inputHandler;
      (input as any).__changeHandler = changeHandler;
    });
  }

  /**
   * Handle margin input changes
   */
  private handleMarginChange(marginKey: string, input: HTMLInputElement): void {
    const validatedValue = this.validateMarginInput(input.value);
    this.marginValues[marginKey] = validatedValue;

    // Update input value to reflect validated and clamped value
    input.value = this.marginValues[marginKey].toString();


    // Trigger callback
    if (this.onMarginChangeCallback) {
      this.onMarginChangeCallback({ ...this.marginValues });
    }
  }

  /**
   * Get current margin values
   */
  getMargins(): { [key: string]: number } {
    return { ...this.marginValues };
  }

  /**
   * Set margin values programmatically
   */
  setMargins(margins: { [key: string]: number }): void {
    Object.entries(margins).forEach(([key, value]) => {
      if (key in this.marginValues) {
        this.marginValues[key] = Math.max(0, value);

        // Update input if it exists
        if (this.marginInputs[key]) {
          this.marginInputs[key].value = this.marginValues[key].toString();
        }
      }
    });


    // Trigger callback
    if (this.onMarginChangeCallback) {
      this.onMarginChangeCallback({ ...this.marginValues });
    }
  }

  /**
   * Set individual margin
   */
  setMargin(marginKey: string, value: number): void {
    if (marginKey in this.marginValues) {
      this.marginValues[marginKey] = Math.max(0, value);

      // Update input if it exists
      if (this.marginInputs[marginKey]) {
        this.marginInputs[marginKey].value =
          this.marginValues[marginKey].toString();
      }


      // Trigger callback
      if (this.onMarginChangeCallback) {
        this.onMarginChangeCallback({ ...this.marginValues });
      }
    }
  }

  /**
   * Reset margins to default values
   */
  resetMargins(): void {
    const defaultMargins = { top: 20, right: 20, bottom: 20, left: 20 };
    this.setMargins(defaultMargins);
  }

  /**
   * Get margin as CSS string
   */
  getMarginsAsCSS(): string {
    const { top, right, bottom, left } = this.marginValues;
    return `${top}px ${right}px ${bottom}px ${left}px`;
  }

  /**
   * Get margin for specific side
   */
  getMargin(side: string): number {
    return this.marginValues[side] || 0;
  }

  /**
   * Check if margins are uniform
   */
  areMarginosUniform(): boolean {
    const values = Object.values(this.marginValues);
    return values.every((value) => value === values[0]);
  }

  /**
   * Apply margins to element
   */
  applyMarginsToElement(element: HTMLElement): void {
    element.style.margin = this.getMarginsAsCSS();
  }

  /**
   * Remove margins from element
   */
  removeMarginsFromElement(element: HTMLElement): void {
    element.style.margin = "";
  }

  /**
   * Validate margin input
   */
  private validateMarginInput(value: string): number {
    const numValue = parseInt(value);
    if (isNaN(numValue) || numValue < 0) {
      return 0;
    }
    return Math.min(numValue, 200); // Max margin of 200px
  }

  /**
   * Export margins configuration
   */
  exportMargins(): { [key: string]: number } {
    return { ...this.marginValues };
  }

  /**
   * Import margins configuration
   */
  importMargins(margins: { [key: string]: number }): void {
    this.setMargins(margins);
  }

  /**
   * Cleanup
   */
  destroy(): void {
    // Remove event listeners
    Object.values(this.marginInputs).forEach((input) => {
      const inputHandler = (input as any).__inputHandler;
      const changeHandler = (input as any).__changeHandler;

      if (inputHandler) {
        input.removeEventListener("input", inputHandler);
      }
      if (changeHandler) {
        input.removeEventListener("change", changeHandler);
      }
    });

    this.marginInputs = {};
    this.onMarginChangeCallback = null;
  }
}
/**
 * Page Navigation Controller
 * Handles page navigation, UI updates, and page switching logic
 * Single Responsibility: Page navigation and navigation UI only
 */

export class PageNavigationController {
  private currentPageIndex: number = 0;
  private totalPages: number = 1;
  private onPageChangeCallback: ((pageIndex: number) => void) | null = null;

  constructor() {
    this.bindNavigationEvents();
  }

  /**
   * Set callback for page changes
   */
  setOnPageChange(callback: (pageIndex: number) => void): void {
    this.onPageChangeCallback = callback;
  }

  /**
   * Bind navigation events
   */
  private bindNavigationEvents(): void {
    // Previous page button
    const prevPageBtn = document.getElementById("prev-page");
    if (prevPageBtn) {
      prevPageBtn.addEventListener("click", this.goToPreviousPage.bind(this));
    }

    // Next page button
    const nextPageBtn = document.getElementById("next-page");
    if (nextPageBtn) {
      nextPageBtn.addEventListener("click", this.goToNextPage.bind(this));
    }

    // Page selector dropdown
    const pageSelector = document.getElementById(
      "page-selector",
    ) as HTMLSelectElement;
    if (pageSelector) {
      pageSelector.addEventListener(
        "change",
        this.handlePageSelection.bind(this),
      );
    }

    // Keyboard navigation
    document.addEventListener(
      "keydown",
      this.handleKeyboardNavigation.bind(this),
    );
  }

  /**
   * Handle keyboard navigation
   */
  private handleKeyboardNavigation(event: KeyboardEvent): void {
    // Only handle navigation if no input elements are focused
    if (
      document.activeElement?.tagName === "INPUT" ||
      document.activeElement?.tagName === "TEXTAREA"
    ) {
      return;
    }

    if (event.ctrlKey || event.metaKey) {
      switch (event.key) {
        case "ArrowLeft":
          event.preventDefault();
          this.goToPreviousPage();
          break;
        case "ArrowRight":
          event.preventDefault();
          this.goToNextPage();
          break;
      }
    }
  }

  /**
   * Go to previous page
   */
  goToPreviousPage(): void {
    if (this.currentPageIndex > 0) {
      this.setCurrentPage(this.currentPageIndex - 1);
    }
  }

  /**
   * Go to next page
   */
  goToNextPage(): void {
    if (this.currentPageIndex < this.totalPages - 1) {
      this.setCurrentPage(this.currentPageIndex + 1);
    }
  }

  /**
   * Handle page selection from dropdown
   */
  private handlePageSelection(event: Event): void {
    const select = event.target as HTMLSelectElement;
    const selectedIndex = parseInt(select.value);

    if (selectedIndex >= 0 && selectedIndex < this.totalPages) {
      this.setCurrentPage(selectedIndex);
    }
  }

  /**
   * Set current page index
   */
  setCurrentPage(pageIndex: number): void {
    if (pageIndex >= 0 && pageIndex < this.totalPages) {
      this.currentPageIndex = pageIndex;
      this.updateNavigationUI();

      // Trigger callback
      if (this.onPageChangeCallback) {
        this.onPageChangeCallback(pageIndex);
      }
    }
  }

  /**
   * Set total pages count
   */
  setTotalPages(count: number): void {
    this.totalPages = Math.max(1, count);

    // Adjust current page if necessary
    if (this.currentPageIndex >= this.totalPages) {
      this.currentPageIndex = this.totalPages - 1;
    }

    this.updateNavigationUI();
  }

  /**
   * Update page selector with page names
   */
  updatePageSelector(pages: Array<{ name: string }>): void {
    const pageSelector = document.getElementById(
      "page-selector",
    ) as HTMLSelectElement;
    if (!pageSelector) return;

    pageSelector.innerHTML = pages
      .map(
        (page, index) =>
          `<option value="${index}" ${index === this.currentPageIndex ? "selected" : ""}>${page.name}</option>`,
      )
      .join("");
  }

  /**
   * Update navigation UI elements
   */
  private updateNavigationUI(): void {
    // Update navigation buttons
    const prevBtn = document.getElementById("prev-page") as HTMLButtonElement;
    const nextBtn = document.getElementById("next-page") as HTMLButtonElement;

    if (prevBtn) {
      prevBtn.disabled = this.currentPageIndex === 0;
      prevBtn.title =
        this.currentPageIndex === 0 ? "First page" : "Previous page";
    }

    if (nextBtn) {
      nextBtn.disabled = this.currentPageIndex === this.totalPages - 1;
      nextBtn.title =
        this.currentPageIndex === this.totalPages - 1
          ? "Last page"
          : "Next page";
    }

    // Update page counter
    const pageCounter = document.getElementById("page-counter");
    if (pageCounter) {
      pageCounter.textContent = `${this.currentPageIndex + 1} / ${this.totalPages}`;
    }

    // Update progress indicator
    this.updateProgressIndicator();
  }

  /**
   * Update progress indicator
   */
  private updateProgressIndicator(): void {
    const progressBar = document.getElementById("page-progress");
    if (progressBar) {
      const progressPercentage =
        this.totalPages > 1
          ? (this.currentPageIndex / (this.totalPages - 1)) * 100
          : 100;
      progressBar.style.width = `${progressPercentage}%`;
    }
  }

  /**
   * Get current page index
   */
  getCurrentPageIndex(): number {
    return this.currentPageIndex;
  }

  /**
   * Get total pages count
   */
  getTotalPages(): number {
    return this.totalPages;
  }

  /**
   * Check if can go to previous page
   */
  canGoToPrevious(): boolean {
    return this.currentPageIndex > 0;
  }

  /**
   * Check if can go to next page
   */
  canGoToNext(): boolean {
    return this.currentPageIndex < this.totalPages - 1;
  }

  /**
   * Reset to first page
   */
  resetToFirstPage(): void {
    this.setCurrentPage(0);
  }

  /**
   * Go to last page
   */
  goToLastPage(): void {
    this.setCurrentPage(this.totalPages - 1);
  }

  /**
   * Cleanup
   */
  destroy(): void {
    document.removeEventListener("keydown", this.handleKeyboardNavigation);
    this.onPageChangeCallback = null;
  }
}
/**
 * Page Manager Core
 * Core page data management and business logic
 * Single Responsibility: Page data structure and core operations only
 */

import { PageSettingsModal } from "../modals/PageSettingsModal";
import { PageNavigationController } from "./PageNavigationController.js";

export class PageManager {
  private pages: Array<{
    id: string;
    name: string;
    content: any;
    description?: string;
  }> = [];
  private pageSettingsModal: PageSettingsModal;
  private navigationController: PageNavigationController;
  private onPageChangeCallback: ((page: any) => void) | null = null;
  private onPageAddCallback: ((page: any) => void) | null = null;

  constructor() {
    this.pageSettingsModal = new PageSettingsModal();
    this.navigationController = new PageNavigationController();

    this.initializeFirstPage();
    this.bindCoreEvents();
    this.setupNavigationCallbacks();
  }

  /**
   * Set callback for page changes
   */
  setOnPageChange(callback: (page: any) => void): void {
    this.onPageChangeCallback = callback;
  }

  /**
   * Set callback for page additions
   */
  setOnPageAdd(callback: (page: any) => void): void {
    this.onPageAddCallback = callback;
  }

  /**
   * Initialize the first page
   */
  private initializeFirstPage(): void {
    const firstPage = {
      id: this.generatePageId(),
      name: "Page 1",
      content: null,
      description: "",
    };

    this.pages.push(firstPage);
    this.navigationController.setTotalPages(1);
  }

  /**
   * Bind core page events
   */
  private bindCoreEvents(): void {
    // Add page button
    const addPageBtn = document.getElementById("add-page");
    if (addPageBtn) {
      addPageBtn.addEventListener("click", this.addNewPage.bind(this));
    }

    // Page settings button
    const pageSettingsBtn = document.getElementById("page-settings");
    if (pageSettingsBtn) {
      pageSettingsBtn.addEventListener(
        "click",
        this.openPageSettings.bind(this),
      );
    }
  }

  /**
   * Setup navigation controller callbacks
   */
  private setupNavigationCallbacks(): void {
    this.navigationController.setOnPageChange((pageIndex: number) => {
      const page = this.pages[pageIndex];
      if (page && this.onPageChangeCallback) {
        this.onPageChangeCallback(page);
      }
    });
  }

  /**
   * Add a new page
   */
  addNewPage(): void {
    const newPage = {
      id: this.generatePageId(),
      name: `Page ${this.pages.length + 1}`,
      content: null,
      description: "",
    };

    this.pages.push(newPage);
    this.navigationController.setTotalPages(this.pages.length);
    this.navigationController.updatePageSelector(this.pages);

    // Switch to new page
    this.navigationController.setCurrentPage(this.pages.length - 1);


    // Trigger callbacks
    if (this.onPageAddCallback) {
      this.onPageAddCallback(newPage);
    }
    if (this.onPageChangeCallback) {
      this.onPageChangeCallback(newPage);
    }
  }

  /**
   * Open page settings modal
   */
  async openPageSettings(): Promise<void> {
    const currentPage = this.getCurrentPage();
    if (!currentPage) return;

    try {
      const updatedPage = await this.pageSettingsModal.show(currentPage);

      // Update page data
      Object.assign(currentPage, updatedPage);
      this.navigationController.updatePageSelector(this.pages);

    } catch (error) {
    }
  }

  /**
   * Generate unique page ID
   */
  private generatePageId(): string {
    return `page_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get current page
   */
  getCurrentPage(): any {
    const currentIndex = this.navigationController.getCurrentPageIndex();
    return this.pages[currentIndex];
  }

  /**
   * Get current page index
   */
  getCurrentPageIndex(): number {
    return this.navigationController.getCurrentPageIndex();
  }

  /**
   * Get all pages
   */
  getAllPages(): Array<any> {
    return [...this.pages];
  }

  /**
   * Get total page count
   */
  getPageCount(): number {
    return this.pages.length;
  }

  /**
   * Remove page by index
   */
  removePage(pageIndex: number): void {
    if (
      pageIndex >= 0 &&
      pageIndex < this.pages.length &&
      this.pages.length > 1
    ) {
      const removedPage = this.pages.splice(pageIndex, 1)[0];

      this.navigationController.setTotalPages(this.pages.length);
      this.navigationController.updatePageSelector(this.pages);

    }
  }

  /**
   * Save page content
   */
  savePageContent(content: any): void {
    const currentPage = this.getCurrentPage();
    if (currentPage) {
      currentPage.content = content;
    }
  }

  /**
   * Get page by ID
   */
  getPageById(pageId: string): any {
    return this.pages.find((page) => page.id === pageId);
  }

  /**
   * Update page name
   */
  updatePageName(pageIndex: number, name: string): void {
    if (pageIndex >= 0 && pageIndex < this.pages.length) {
      this.pages[pageIndex].name = name;
      this.navigationController.updatePageSelector(this.pages);
    }
  }

  /**
   * Cleanup
   */
  destroy(): void {
    this.pageSettingsModal.destroy();
    this.navigationController.destroy();
    this.onPageChangeCallback = null;
    this.onPageAddCallback = null;
  }
}
/**
 * Page Settings Modal
 * Handles page settings modal creation, display, and user interactions
 * Single Responsibility: Page settings modal management only
 */

export class PageSettingsModal {
  private currentModal: HTMLElement | null = null;

  /**
   * Show page settings modal for a specific page
   */
  show(page: any): Promise<any> {
    return new Promise((resolve, reject) => {
      const modal = this.createModal(page);
      document.body.appendChild(modal);
      this.currentModal = modal;

      // Focus on page name input
      const nameInput = modal.querySelector(
        "#page-name-input",
      ) as HTMLInputElement;
      if (nameInput) {
        nameInput.focus();
        nameInput.select();
      }

      // Set up promise resolution
      (modal as any).__resolve = resolve;
      (modal as any).__reject = reject;
    });
  }

  /**
   * Create page settings modal
   */
  private createModal(page: any): HTMLElement {
    const modal = document.createElement("div");
    modal.className = "modal modal--page-settings";
    modal.innerHTML = `
      <div class="modal__backdrop"></div>
      <div class="modal__content">
        <div class="modal__header">
          <h3>Page Settings</h3>
          <button class="modal__close" aria-label="Close">&times;</button>
        </div>
        <div class="modal__body">
          <div class="form-group">
            <label for="page-name-input">Page Name</label>
            <input type="text" id="page-name-input" value="${page.name}" class="form-control">
          </div>
          <div class="form-group">
            <label for="page-description-input">Description (optional)</label>
            <textarea id="page-description-input" class="form-control" rows="3" placeholder="Page description...">${page.description || ""}</textarea>
          </div>
        </div>
        <div class="modal__footer">
          <button class="button button--secondary modal-cancel">Cancel</button>
          <button class="button button--primary modal-save">Save Changes</button>
        </div>
      </div>
    `;

    this.bindModalEvents(modal, page);
    return modal;
  }

  /**
   * Bind modal events
   */
  private bindModalEvents(modal: HTMLElement, page: any): void {
    const resolve = (modal as any).__resolve;
    const reject = (modal as any).__reject;

    // Close button
    const closeBtn = modal.querySelector(".modal__close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        this.close();
        reject(new Error("Modal cancelled"));
      });
    }

    // Cancel button
    const cancelBtn = modal.querySelector(".modal-cancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => {
        this.close();
        reject(new Error("Modal cancelled"));
      });
    }

    // Save button
    const saveBtn = modal.querySelector(".modal-save");
    if (saveBtn) {
      saveBtn.addEventListener("click", () => {
        const result = this.collectFormData(modal, page);
        if (result) {
          this.close();
          resolve(result);
        }
      });
    }

    // Backdrop click
    const backdrop = modal.querySelector(".modal__backdrop");
    if (backdrop) {
      backdrop.addEventListener("click", () => {
        this.close();
        reject(new Error("Modal cancelled"));
      });
    }

    // Escape key
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        this.close();
        reject(new Error("Modal cancelled"));
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
  }

  /**
   * Collect form data from modal
   */
  private collectFormData(modal: HTMLElement, page: any): any | null {
    const nameInput = modal.querySelector(
      "#page-name-input",
    ) as HTMLInputElement;
    const descriptionInput = modal.querySelector(
      "#page-description-input",
    ) as HTMLTextAreaElement;

    if (!nameInput || !nameInput.value.trim()) {
      alert("Page name is required");
      nameInput?.focus();
      return null;
    }

    return {
      ...page,
      name: nameInput.value.trim(),
      description: descriptionInput?.value.trim() || "",
    };
  }

  /**
   * Close modal
   */
  close(): void {
    if (this.currentModal) {
      this.currentModal.remove();
      this.currentModal = null;
    }
  }

  /**
   * Check if modal is open
   */
  isOpen(): boolean {
    return this.currentModal !== null;
  }

  /**
   * Cleanup
   */
  destroy(): void {
    this.close();
  }
}
/**
 * Canvas Manager
 * Manages canvas state, rendering pipeline, and coordinate transformations
 * Single Responsibility: Canvas lifecycle and state management only
 */

import * as PIXI from "pixi.js";
import { LayoutRenderer } from "../layout/LayoutRenderer";

export class CanvasManager {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private pixiApp: any; // PIXI.Application
  private layoutRenderer: LayoutRenderer | null = null;
  private currentTemplate: any = null;
  private isLayoutVisible: boolean = true;

  constructor(canvasId: string = "canvas") {
    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
    if (!this.canvas) {
      throw new Error(`Canvas element with id '${canvasId}' not found`);
    }

    this.ctx = this.canvas.getContext("2d")!;
    this.initializeCanvas();
  }

  /**
   * Initialize canvas and PIXI application
   */
  private initializeCanvas(): void {
    // Set canvas size
    this.resizeCanvas();

    // Initialize PIXI if available
    if (typeof PIXI !== "undefined") {
      this.initializePixi();
    }

    // Bind resize events
    window.addEventListener("resize", this.resizeCanvas.bind(this));
  }

  /**
   * Initialize PIXI application
   */
  private initializePixi(): void {
    this.pixiApp = new PIXI.Application({
      view: this.canvas,
      width: this.canvas.width,
      height: this.canvas.height,
      backgroundColor: 0xffffff,
      antialias: true,
    });

  }

  /**
   * Resize canvas to container size
   */
  private resizeCanvas(): void {
    const container = this.canvas.parentElement;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    this.canvas.width = rect.width;
    this.canvas.height = rect.height;

    if (this.pixiApp) {
      this.pixiApp.renderer.resize(rect.width, rect.height);
    }

    // Trigger re-render if layout is active
    if (this.layoutRenderer && this.currentTemplate) {
      this.renderLayout();
    }
  }

  /**
   * Set layout renderer
   */
  setLayoutRenderer(renderer: LayoutRenderer): void {
    this.layoutRenderer = renderer;
  }

  /**
   * Load and render template
   */
  async loadTemplate(template: any): Promise<void> {
    this.currentTemplate = template;

    if (this.layoutRenderer) {
      // Note: LayoutRenderer doesn't have renderTemplate method
      // Template data should be processed before calling renderLayoutStructure
      this.renderLayout();
    }
  }

  /**
   * Render current layout
   */
  renderLayout(): void {
    if (!this.layoutRenderer || !this.currentTemplate) return;

    this.clearCanvas();

    if (this.isLayoutVisible) {
      // Use renderLayoutStructure with blocks from template
      const blocks = this.currentTemplate.blocks || [];
      this.layoutRenderer.renderLayoutStructure(blocks, true);
    }
  }

  /**
   * Toggle layout visibility
   */
  toggleLayoutVisibility(): void {
    this.isLayoutVisible = !this.isLayoutVisible;
    this.renderLayout();

  }

  /**
   * Clear entire canvas
   */
  clearCanvas(): void {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    if (this.pixiApp) {
      this.pixiApp.stage.removeChildren();
    }
  }

  /**
   * Clear all content (canvas + layout)
   */
  clearAll(): void {
    this.clearCanvas();
    this.currentTemplate = null;

    if (this.layoutRenderer) {
      this.layoutRenderer.clear();
    }

  }

  /**
   * Add new page to canvas
   */
  addPage(): void {
    if (!this.currentTemplate) {
      console.warn("No template loaded - cannot add page");
      return;
    }

    // Logic for adding new page

    // Trigger re-render with new page
    this.renderLayout();
  }

  /**
   * Get canvas dimensions
   */
  getDimensions(): { width: number; height: number } {
    return {
      width: this.canvas.width,
      height: this.canvas.height,
    };
  }

  /**
   * Get canvas element
   */
  getCanvas(): HTMLCanvasElement {
    return this.canvas;
  }

  /**
   * Get canvas context
   */
  getContext(): CanvasRenderingContext2D {
    return this.ctx;
  }

  /**
   * Get PIXI application
   */
  getPixiApp(): any {
    return this.pixiApp;
  }

  /**
   * Get current template
   */
  getCurrentTemplate(): any {
    return this.currentTemplate;
  }

  /**
   * Check if layout is visible
   */
  isLayoutVisibleState(): boolean {
    return this.isLayoutVisible;
  }

  /**
   * Convert screen coordinates to canvas coordinates
   */
  screenToCanvas(screenX: number, screenY: number): { x: number; y: number } {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: screenX - rect.left,
      y: screenY - rect.top,
    };
  }

  /**
   * Convert canvas coordinates to screen coordinates
   */
  canvasToScreen(canvasX: number, canvasY: number): { x: number; y: number } {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: canvasX + rect.left,
      y: canvasY + rect.top,
    };
  }

  /**
   * Cleanup resources
   */
  destroy(): void {
    window.removeEventListener("resize", this.resizeCanvas);

    if (this.pixiApp) {
      this.pixiApp.destroy();
    }

    this.layoutRenderer = null;
    this.currentTemplate = null;
  }
}
/**
 * Template Renderer
 * Handles loading and applying template configuration to layout blocks
 */

import { supabase } from "../../backend/supabase";
import type { RenderedBlock } from "../layout/LayoutTypes";

export class TemplateRenderer {
  /**
   * Get layout blocks with template configuration applied as field labels
   * Fetches template data directly from Supabase
   */
  static async getConfiguredLayoutBlocks(
    renderedBlocks: RenderedBlock[],
    courseId: string,
  ): Promise<RenderedBlock[]> {
    try {

      const { data: template, error } = await supabase
        .from("templates")
        .select("template_data")
        .eq("course_id", courseId)
        .single();

      if (error && error.code !== "PGRST116") {
        // PGRST116 = no rows found
        console.error("Error loading course template:", error);
        return renderedBlocks; // Return original blocks if error
      }

      if (!template?.template_data) {
          "üìÑ No template found for course, returning default blocks",
        );
        return renderedBlocks;
      }


      const configuredBlocks = renderedBlocks.map((renderedBlock) => {
        // Find matching template block
        const templateBlock = template.template_data.blocks.find(
          (tb: any) => tb.type === renderedBlock.blockId,
        );

        if (!templateBlock) {
          return renderedBlock; // Return original if no template found
        }

        // Generate input field definitions based on configuration
        const inputFields = this.generateInputFields(templateBlock);

        // Update areas with input field information
        // Only assign to content areas (not instruction areas)
        const updatedAreas = renderedBlock.areas.map((area) => {
          const shouldHaveContent =
            area.areaId === "header-content-area" ||
            area.areaId === "footer-content-area" ||
            area.areaId.includes("content-area");

            `üìù Area "${area.areaId}" in block "${renderedBlock.blockId}": shouldHaveContent=${shouldHaveContent}, inputFields=${inputFields.length}`,
          );

          return {
            ...area,
            content:
              shouldHaveContent && inputFields.length > 0
                ? inputFields
                : area.content,
            inputFields: shouldHaveContent ? inputFields : undefined,
          };
        });

        return {
          ...renderedBlock,
          areas: updatedAreas,
        };
      });

      return configuredBlocks;
    } catch (error) {
      console.error("üìÑ Failed to fetch template configuration:", error);
      return renderedBlocks; // Return original blocks on error
    }
  }

  /**
   * Generate input field definitions based on template configuration
   */
  private static generateInputFields(templateBlock: any): any[] {
    const config = templateBlock.config;
    const fields: any[] = [];

    // Convert config keys to input field definitions
    for (const [key, enabled] of Object.entries(config)) {
      if (enabled) {
        const inputType = this.getInputTypeForField(key);
        const label = key
          .replace(/_/g, " ")
          .replace(/\b\w/g, (l) => l.toUpperCase());

        fields.push({
          key: key,
          label: label,
          inputType: inputType,
          placeholder: this.getPlaceholderForField(key),
          required: this.isFieldRequired(key),
        });
      }
    }

    return fields;
  }

  /**
   * Get placeholder text for a field
   */
  private static getPlaceholderForField(fieldKey: string): string {
    const placeholders: Record<string, string> = {
      course_title: "Enter course name...",
      lesson_title: "Enter lesson title...",
      module_title: "Enter module name...",
      teacher_name: "Enter teacher name...",
      lesson_number: "Enter lesson number...",
      institution_name: "Enter school/institution...",
      task: "Describe the main task...",
      topic: "Enter lesson topic...",
      objective: "State learning objective...",
      competence: "Define competence goals...",
      page_number: "Page #",
      copyright: "¬© 2025 Institution Name",
    };

    return placeholders[fieldKey] || `Enter ${fieldKey.replace(/_/g, " ")}...`;
  }

  /**
   * Check if a field is required
   */
  private static isFieldRequired(fieldKey: string): boolean {
    const requiredFields = [
      "course_title",
      "lesson_title",
      "teacher_name",
      "institution_name",
    ];

    return requiredFields.includes(fieldKey);
  }

  /**
   * Determine the input type for a template field
   */
  private static getInputTypeForField(fieldKey: string): string {
    // Text inputs
    const textFields = [
      "course_title",
      "lesson_title",
      "module_title",
      "teacher_name",
      "institution_name",
      "task",
      "topic",
      "objective",
      "competence",
      "type",
      "state",
      "origin",
      "quality",
      "concepts",
      "terminology",
      "historical_figures",
      "student_area",
      "teacher_area",
      "student_title",
      "teacher_title",
      "instruction_area",
      "instruction_title",
      "copyright",
    ];

    // Number inputs
    const numberFields = ["lesson_number", "page_number"];

    // Boolean/checkbox inputs
    const booleanFields = ["include_glossary"];

    // Date inputs
    const dateFields = ["created_at", "updated_at"];

    // Determine input type
    if (textFields.includes(fieldKey)) {
      return "text";
    } else if (numberFields.includes(fieldKey)) {
      return "number";
    } else if (booleanFields.includes(fieldKey)) {
      return "checkbox";
    } else if (dateFields.includes(fieldKey)) {
      return "date";
    } else {
      // Default to text for unknown fields
      return "text";
    }
  }
}
/**
 * Focused PixiJS Canvas Manager
 * Coordinates application, layers, events, and tools
 * Single Responsibility: High-level canvas coordination only (under 250 lines)
 */

import { Application, Container } from "pixi.js";
import { ToolManager } from "../tools/ToolManager";
import { PixiApplicationManager } from "./PixiApplicationManager";
import { CanvasLayerManager } from "./CanvasLayerManager";
import { CanvasEventHandler } from "./CanvasEventHandler";

export class PixiCanvas {
  private appManager: PixiApplicationManager;
  private layerManager: CanvasLayerManager | null = null;
  private eventHandler: CanvasEventHandler | null = null;
  private toolManager: ToolManager;
  private app: Application | null = null;

  constructor(containerSelector: string) {
    this.appManager = new PixiApplicationManager(containerSelector);
    this.toolManager = new ToolManager();
  }

  /**
   * Initialize the complete canvas system
   */
  public async init(): Promise<void> {
    try {
      // Initialize PIXI application
      this.app = await this.appManager.initializeApplication();

      // Initialize layer management
      this.layerManager = new CanvasLayerManager(this.app);
      this.layerManager.initializeLayers();
      this.layerManager.addBackgroundGrid();

      // Initialize event handling
      this.eventHandler = new CanvasEventHandler(this.app, this.toolManager);
      this.eventHandler.setDrawingContainer(
        this.layerManager.getDrawingContainer()!,
      );
      this.eventHandler.setupEvents();

    } catch (error) {
      console.error("‚ùå Failed to initialize PixiCanvas system:", error);
      throw error;
    }
  }

  /**
   * Get the PIXI Application instance
   */
  public getApplication(): Application | null {
    return this.app;
  }

  /**
   * Tool Management
   */
  public setTool(toolName: string): boolean {
    const success = this.toolManager.setActiveTool(toolName);
    if (success && this.eventHandler) {
      this.eventHandler.updateCanvasCursor(toolName);
    }
    return success;
  }

  public updateToolColor(color: string): void {
    this.toolManager.updateColorForCurrentTool(color);
  }

  public updateToolSettings(toolName: string, settings: any): void {
    this.toolManager.updateToolSettings(toolName, settings);
  }

  public getActiveToolName(): string {
    return this.toolManager.getActiveToolName();
  }

  /**
   * Canvas Operations
   */
  public clearCanvas(): void {
    if (this.layerManager) {
      this.layerManager.clearDrawingLayer();
    }
  }

  public clearAll(): void {
    if (this.layerManager) {
      this.layerManager.clearAllLayers();
    }
  }

  public resize(width: number, height: number): void {
    this.appManager.resize(width, height);
  }

  /**
   * Update canvas margins (visual boundaries)
   */
  public updateMargins(margins: {
    top: number;
    right: number;
    bottom: number;
    left: number;
  }): void {
    if (this.layerManager) {
      this.layerManager.updateMarginBoundaries(margins);
    } else {
      console.warn("‚ö†Ô∏è Layer manager not initialized");
    }
  }

  /**
   * Data Access
   */
  public getDimensions(): { width: number; height: number } {
    return this.appManager.getDimensions();
  }

  public getApp(): Application | null {
    return this.app;
  }

  public getDrawingContainer(): Container | null {
    return this.layerManager?.getDrawingContainer() || null;
  }

  public getLayoutContainer(): Container | null {
    return this.layerManager?.getLayoutContainer() || null;
  }

  public getCanvasDimensions(): { width: number; height: number } {
    return this.appManager.getDimensions();
  }

  public getCanvasInfo(): any {
    const appInfo = this.appManager.getCanvasInfo();
    const layerInfo = this.layerManager?.getLayerInfo();
    const eventInfo = this.eventHandler?.getEventInfo();

    return {
      application: appInfo,
      layers: layerInfo,
      events: eventInfo,
      tools: {
        activeTool: this.toolManager.getActiveToolName(),
        toolSettings: this.toolManager.getToolSettings(),
      },
    };
  }

  /**
   * Export functionality
   */
  public async exportAsImage(): Promise<string> {
    return await this.appManager.exportAsImage();
  }

  /**
   * Layout Management
   */
  public addLayoutBlock(block: any): void {
    if (this.layerManager) {
      this.layerManager.addLayoutBlock(block);
    }
  }

  public removeLayoutBlock(blockId: string): void {
    if (this.layerManager) {
      this.layerManager.removeLayoutBlock(blockId);
    }
  }

  public getLayoutBlocks(): any[] {
    return this.layerManager?.getLayoutBlocks() || [];
  }

  /**
   * Event Management
   */
  public setEventsEnabled(enabled: boolean): void {
    if (this.eventHandler) {
      this.eventHandler.setEventsEnabled(enabled);
    }
  }

  /**
   * Cleanup
   */
  public destroy(): void {
    // Destroy in reverse order of creation
    if (this.eventHandler) {
      this.eventHandler.destroy();
      this.eventHandler = null;
    }

    if (this.layerManager) {
      this.layerManager.destroy();
      this.layerManager = null;
    }

    this.toolManager.destroy();
    this.appManager.destroy();
    this.app = null;

  }
}
/**
 * Focused PixiJS Canvas Manager
 * Coordinates application, layers, events, and tools
 * Single Responsibility: High-level canvas coordination only (under 250 lines)
 */

import { Application, Container } from "pixi.js";
import { ToolManager } from "../tools/ToolManager.js";
import { PixiApplicationManager } from "./PixiApplicationManager.js";
import { CanvasLayerManager } from "./CanvasLayerManager.js";
import { CanvasEventHandler } from "./CanvasEventHandler.js";

export class PixiCanvasRefactored {
  private appManager: PixiApplicationManager;
  private layerManager: CanvasLayerManager | null = null;
  private eventHandler: CanvasEventHandler | null = null;
  private toolManager: ToolManager;
  private app: Application | null = null;

  constructor(containerSelector: string) {
    this.appManager = new PixiApplicationManager(containerSelector);
    this.toolManager = new ToolManager();
  }

  /**
   * Initialize the complete canvas system
   */
  public async init(): Promise<void> {
    try {
      // Initialize PIXI application
      this.app = await this.appManager.initializeApplication();

      // Initialize layer management
      this.layerManager = new CanvasLayerManager(this.app);
      this.layerManager.initializeLayers();
      this.layerManager.addBackgroundGrid();

      // Initialize event handling
      this.eventHandler = new CanvasEventHandler(this.app, this.toolManager);
      this.eventHandler.setDrawingContainer(
        this.layerManager.getDrawingContainer()!,
      );
      this.eventHandler.setupEvents();

    } catch (error) {
      console.error("‚ùå Failed to initialize PixiCanvas system:", error);
      throw error;
    }
  }

  /**
   * Tool Management
   */
  public setTool(toolName: string): boolean {
    const success = this.toolManager.setActiveTool(toolName);
    if (success && this.eventHandler) {
      this.eventHandler.updateCanvasCursor(toolName);
    }
    return success;
  }

  public updateToolColor(color: string): void {
    this.toolManager.updateColorForCurrentTool(color);
  }

  public updateToolSettings(toolName: string, settings: any): void {
    this.toolManager.updateToolSettings(toolName, settings);
  }

  public getActiveToolName(): string {
    return this.toolManager.getActiveToolName();
  }

  /**
   * Canvas Operations
   */
  public clearCanvas(): void {
    if (this.layerManager) {
      this.layerManager.clearDrawingLayer();
    }
  }

  public clearAll(): void {
    if (this.layerManager) {
      this.layerManager.clearAllLayers();
    }
  }

  public resize(width: number, height: number): void {
    this.appManager.resize(width, height);
  }

  /**
   * Data Access
   */
  public getDimensions(): { width: number; height: number } {
    return this.appManager.getDimensions();
  }

  public getApp(): Application | null {
    return this.app;
  }

  public getDrawingContainer(): Container | null {
    return this.layerManager?.getDrawingContainer() || null;
  }

  public getLayoutContainer(): Container | null {
    return this.layerManager?.getLayoutContainer() || null;
  }

  public getCanvasDimensions(): { width: number; height: number } {
    return this.appManager.getDimensions();
  }

  public getCanvasInfo(): any {
    const appInfo = this.appManager.getCanvasInfo();
    const layerInfo = this.layerManager?.getLayerInfo();
    const eventInfo = this.eventHandler?.getEventInfo();

    return {
      application: appInfo,
      layers: layerInfo,
      events: eventInfo,
      tools: {
        activeTool: this.toolManager.getActiveToolName(),
        toolSettings: this.toolManager.getToolSettings(),
      },
    };
  }

  /**
   * Export functionality
   */
  public async exportAsImage(): Promise<string> {
    return await this.appManager.exportAsImage();
  }

  /**
   * Layout Management
   */
  public addLayoutBlock(block: any): void {
    if (this.layerManager) {
      this.layerManager.addLayoutBlock(block);
    }
  }

  public removeLayoutBlock(blockId: string): void {
    if (this.layerManager) {
      this.layerManager.removeLayoutBlock(blockId);
    }
  }

  public getLayoutBlocks(): any[] {
    return this.layerManager?.getLayoutBlocks() || [];
  }

  /**
   * Event Management
   */
  public setEventsEnabled(enabled: boolean): void {
    if (this.eventHandler) {
      this.eventHandler.setEventsEnabled(enabled);
    }
  }

  /**
   * Cleanup
   */
  public destroy(): void {
    // Destroy in reverse order of creation
    if (this.eventHandler) {
      this.eventHandler.destroy();
      this.eventHandler = null;
    }

    if (this.layerManager) {
      this.layerManager.destroy();
      this.layerManager = null;
    }

    this.toolManager.destroy();
    this.appManager.destroy();
    this.app = null;

  }
}
/**
 * Canvas Layer Manager
 * Manages PIXI containers and layering system
 * Single Responsibility: Layer creation and management only
 */

import { Application, Container, Graphics } from "pixi.js";

export class CanvasLayerManager {
  private app: Application;
  private layoutContainer: Container | null = null;
  private drawingContainer: Container | null = null;
  private layoutBlocks: any[] = [];
  private marginGraphics: Graphics | null = null;

  constructor(app: Application) {
    this.app = app;
  }

  /**
   * Initialize layered container structure
   */
  public initializeLayers(): void {
    // Create layout container (bottom layer - protected)
    this.layoutContainer = new Container();
    this.layoutContainer.label = "layout-layer";
    this.layoutContainer.zIndex = 0;
    this.app.stage.addChild(this.layoutContainer);

    // Create drawing container (top layer - user editable)
    this.drawingContainer = new Container();
    this.drawingContainer.label = "drawing-layer";
    this.drawingContainer.zIndex = 1;
    this.app.stage.addChild(this.drawingContainer);

    // Enable sorting by zIndex
    this.app.stage.sortableChildren = true;

  }

  /**
   * Add background grid to layout layer
   */
  public addBackgroundGrid(): void {
    if (!this.layoutContainer) {
      console.warn("‚ö†Ô∏è Layout container not initialized");
      return;
    }

    const graphics = new Graphics();
    const gridSize = 20;
    const canvasWidth = this.app.screen.width;
    const canvasHeight = this.app.screen.height;

    // Create a more visible background
    graphics.rect(0, 0, canvasWidth, canvasHeight);
    graphics.fill({ color: 0xffffff, alpha: 1 }); // White background

    // Draw grid lines
    graphics.moveTo(0, 0);

    // Draw vertical lines
    for (let x = 0; x <= canvasWidth; x += gridSize) {
      graphics.moveTo(x, 0);
      graphics.lineTo(x, canvasHeight);
    }

    // Draw horizontal lines
    for (let y = 0; y <= canvasHeight; y += gridSize) {
      graphics.moveTo(0, y);
      graphics.lineTo(canvasWidth, y);
    }

    graphics.stroke({ width: 1, color: 0xe0e0e0, alpha: 0.8 });

    graphics.label = "background-grid";

    this.layoutContainer.addChild(graphics);

  }

  /**
   * Add or update margin boundaries (blue borders)
   */
  public updateMarginBoundaries(margins: {
    top: number;
    right: number;
    bottom: number;
    left: number;
  }): void {
    if (!this.layoutContainer) {
      console.warn("‚ö†Ô∏è Layout container not initialized");
      return;
    }

    // Remove existing margin graphics
    if (this.marginGraphics) {
      this.layoutContainer.removeChild(this.marginGraphics);
      this.marginGraphics.destroy();
    }

    // Create new margin graphics
    this.marginGraphics = new Graphics();
    this.marginGraphics.label = "margin-boundaries";

    const canvasWidth = this.app.screen.width;
    const canvasHeight = this.app.screen.height;

    // Draw margin boundaries with blue color
    const marginColor = 0x3b82f6; // Bright blue
    const marginAlpha = 0.8;
    const lineWidth = 2;

    // Top margin line
    if (margins.top > 0) {
      this.marginGraphics.moveTo(0, margins.top);
      this.marginGraphics.lineTo(canvasWidth, margins.top);
    }

    // Bottom margin line
    if (margins.bottom > 0) {
      this.marginGraphics.moveTo(0, canvasHeight - margins.bottom);
      this.marginGraphics.lineTo(canvasWidth, canvasHeight - margins.bottom);
    }

    // Left margin line
    if (margins.left > 0) {
      this.marginGraphics.moveTo(margins.left, 0);
      this.marginGraphics.lineTo(margins.left, canvasHeight);
    }

    // Right margin line
    if (margins.right > 0) {
      this.marginGraphics.moveTo(canvasWidth - margins.right, 0);
      this.marginGraphics.lineTo(canvasWidth - margins.right, canvasHeight);
    }

    // Style the margin lines
    this.marginGraphics.stroke({
      width: lineWidth,
      color: marginColor,
      alpha: marginAlpha,
    });

    // Add margin area overlay (very subtle fill)
    // Top margin area
    if (margins.top > 0) {
      this.marginGraphics.rect(0, 0, canvasWidth, margins.top);
      this.marginGraphics.fill({ color: marginColor, alpha: 0.05 });
    }

    // Bottom margin area
    if (margins.bottom > 0) {
      this.marginGraphics.rect(
        0,
        canvasHeight - margins.bottom,
        canvasWidth,
        margins.bottom,
      );
      this.marginGraphics.fill({ color: marginColor, alpha: 0.05 });
    }

    // Left margin area
    if (margins.left > 0) {
      this.marginGraphics.rect(0, 0, margins.left, canvasHeight);
      this.marginGraphics.fill({ color: marginColor, alpha: 0.05 });
    }

    // Right margin area
    if (margins.right > 0) {
      this.marginGraphics.rect(
        canvasWidth - margins.right,
        0,
        margins.right,
        canvasHeight,
      );
      this.marginGraphics.fill({ color: marginColor, alpha: 0.05 });
    }

    this.layoutContainer.addChild(this.marginGraphics);

  }

  /**
   * Clear margin boundaries
   */
  public clearMarginBoundaries(): void {
    if (this.marginGraphics && this.layoutContainer) {
      this.layoutContainer.removeChild(this.marginGraphics);
      this.marginGraphics.destroy();
      this.marginGraphics = null;
    }
  }

  /**
   * Clear user drawings (preserve layout)
   */
  public clearDrawingLayer(): void {
    if (this.drawingContainer) {
      this.drawingContainer.removeChildren();
    }
  }

  /**
   * Clear everything including layout
   */
  public clearAllLayers(): void {
    if (this.layoutContainer) {
      this.layoutContainer.removeChildren();
    }
    if (this.drawingContainer) {
      this.drawingContainer.removeChildren();
    }
    this.layoutBlocks = [];

    // Restore background grid
    this.addBackgroundGrid();

  }

  /**
   * Get layout container
   */
  public getLayoutContainer(): Container | null {
    return this.layoutContainer;
  }

  /**
   * Get drawing container
   */
  public getDrawingContainer(): Container | null {
    return this.drawingContainer;
  }

  /**
   * Add layout block
   */
  public addLayoutBlock(block: any): void {
    this.layoutBlocks.push(block);
  }

  /**
   * Remove layout block
   */
  public removeLayoutBlock(blockId: string): void {
    this.layoutBlocks = this.layoutBlocks.filter(
      (block) => block.id !== blockId,
    );
  }

  /**
   * Get all layout blocks
   */
  public getLayoutBlocks(): any[] {
    return [...this.layoutBlocks];
  }

  /**
   * Clear layout blocks
   */
  public clearLayoutBlocks(): void {
    this.layoutBlocks = [];
  }

  /**
   * Get layer information
   */
  public getLayerInfo(): any {
    return {
      layoutContainer: {
        exists: !!this.layoutContainer,
        children: this.layoutContainer?.children.length || 0,
        name: this.layoutContainer?.name || "none",
      },
      drawingContainer: {
        exists: !!this.drawingContainer,
        children: this.drawingContainer?.children.length || 0,
        name: this.drawingContainer?.name || "none",
      },
      layoutBlocks: this.layoutBlocks.length,
    };
  }

  /**
   * Destroy all layers
   */
  public destroy(): void {
    // Clean up margin graphics
    if (this.marginGraphics) {
      this.marginGraphics.destroy();
      this.marginGraphics = null;
    }

    if (this.layoutContainer) {
      this.layoutContainer.destroy({ children: true });
      this.layoutContainer = null;
    }
    if (this.drawingContainer) {
      this.drawingContainer.destroy({ children: true });
      this.drawingContainer = null;
    }
    this.layoutBlocks = [];
  }
}
/**
 * Simplified Canvas Manager - Canvas lifecycle and state management only
 */

export class CanvasManager {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private currentTemplate: any = null;
  private isLayoutVisible: boolean = true;

  constructor(canvasId: string = "canvas") {
    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
    if (!this.canvas) {
      throw new Error(`Canvas element with id '${canvasId}' not found`);
    }
    this.ctx = this.canvas.getContext("2d")!;
    this.initializeCanvas();
  }

  private initializeCanvas(): void {
    this.canvas.width = 800;
    this.canvas.height = 600;
    window.addEventListener("resize", () => this.resizeCanvas());
  }

  public resizeCanvas(): void {
    const container = this.canvas.parentElement;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    const aspectRatio = 4 / 3;
    let width = rect.width;
    let height = width / aspectRatio;

    if (height > rect.height) {
      height = rect.height;
      width = height * aspectRatio;
    }

    this.canvas.width = width;
    this.canvas.height = height;
    this.renderCurrentState();
  }

  public async loadTemplate(template: any): Promise<void> {
    this.currentTemplate = template;
    this.renderCurrentState();
  }

  public renderCurrentState(): void {
    if (!this.isLayoutVisible) return;
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = "#f0f0f0";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }

  public toggleLayoutVisibility(): void {
    this.isLayoutVisible = !this.isLayoutVisible;
    if (this.isLayoutVisible) {
      this.renderCurrentState();
    } else {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
  }

  public clearAll(): void {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.currentTemplate = null;
  }

  public getCanvas(): HTMLCanvasElement {
    return this.canvas;
  }

  public getContext(): CanvasRenderingContext2D {
    return this.ctx;
  }

  public getCurrentTemplate(): any {
    return this.currentTemplate;
  }

  public isVisible(): boolean {
    return this.isLayoutVisible;
  }

  public getDimensions(): { width: number; height: number } {
    return { width: this.canvas.width, height: this.canvas.height };
  }

  public exportAsDataURL(type: string = "image/png"): string {
    return this.canvas.toDataURL(type);
  }

  public getCanvasState(): any {
    return {
      dimensions: this.getDimensions(),
      isLayoutVisible: this.isLayoutVisible,
      hasTemplate: !!this.currentTemplate,
    };
  }

  public updateCanvas(content: any): void {
    if (content.template) {
      this.loadTemplate(content.template);
    }
    if (content.visibility !== undefined) {
      this.isLayoutVisible = content.visibility;
    }
    this.renderCurrentState();
  }

  public handleCanvasClick(event: MouseEvent): void {
    const rect = this.canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const canvasClickEvent = new CustomEvent("canvasClick", {
      detail: { x, y },
    });
    this.canvas.dispatchEvent(canvasClickEvent);
  }

  public destroy(): void {
    window.removeEventListener("resize", this.resizeCanvas);
    this.clearAll();
  }
}
/**
 * PIXI Application Manager
 * Handles PIXI Application initialization and basic setup
 * Single Responsibility: PIXI App creation and configuration only
 */

import { Application } from "pixi.js";
import { initDevtools } from "@pixi/devtools";

// Expose PIXI globally for devtools (PIXI v8.2+ requirement)
import * as PIXI from "pixi.js";

// Safely expose PIXI globally for devtools with improved error handling
try {
  // Check if PIXI is already available globally
  if (!(window as any).PIXI) {
    (window as any).PIXI = PIXI;
  } else {
  }
  
  if (!(globalThis as any).PIXI) {
    (globalThis as any).PIXI = PIXI;
  } else {
  }
} catch (error) {
  console.warn("Could not expose PIXI globally:", error);
  // Try alternative approach
  try {
    if (typeof window !== 'undefined') {
      Object.defineProperty(window, 'PIXI', {
        value: PIXI,
        writable: true,
        configurable: true,
        enumerable: false
      });
    }
  } catch (altError) {
    console.warn("Alternative PIXI exposure also failed:", altError);
  }
}

export class PixiApplicationManager {
  private app: Application | null = null;
  private canvasElement: HTMLElement | null = null;
  private static instanceCount = 0;
  private instanceId: number;

  constructor(containerSelector: string) {
    PixiApplicationManager.instanceCount++;
    this.instanceId = PixiApplicationManager.instanceCount;
    
    
    // Handle both ID (#id) and class (.class) selectors
    if (
      containerSelector.startsWith("#") ||
      containerSelector.startsWith(".")
    ) {
      this.canvasElement = document.querySelector(containerSelector);
    } else {
      // Fallback for plain ID strings (legacy compatibility)
      this.canvasElement = document.getElementById(containerSelector);
    }

    if (!this.canvasElement) {
      throw new Error(
        `Canvas container with selector "${containerSelector}" not found`,
      );
    }
  }

  /**
   * Initialize the PixiJS application with A4 dimensions
   */
  public async initializeApplication(): Promise<Application> {
    // Prevent double initialization
    if (this.app) {
      console.warn(`‚ö†Ô∏è PixiJS Application already initialized for instance #${this.instanceId}`);
      return this.app;
    }

    try {
      
      // Create PixiJS application
      this.app = new Application();

      // Use fixed A4 dimensions since container is now properly sized in CSS
      const canvasWidth = 794;
      const canvasHeight = 1123;

      // Initialize the application with A4 dimensions
      await this.app.init({
        width: canvasWidth,
        height: canvasHeight,
        backgroundColor: 0xffffff, // White background
        antialias: true,
        autoDensity: true,
        resolution: window.devicePixelRatio || 1,
      });

      // Clear the canvas container and add PixiJS canvas
      this.canvasElement!.innerHTML = "";
      this.canvasElement!.appendChild(this.app.canvas);

      // Expose app globally for PIXI devtools with multiple approaches
      (window as any).__PIXI_APP__ = this.app;
      (globalThis as any).__PIXI_APP__ = this.app;

      // Safely expose on PIXI object for devtools detection
      let pixiExtensionSuccessful = false;
      
      if ((window as any).PIXI && typeof (window as any).PIXI === "object") {
        const pixiObject = (window as any).PIXI;
        
        // Check if PIXI object is extensible
        if (Object.isExtensible(pixiObject)) {
          try {
            // Handle app property
            const appDescriptor = Object.getOwnPropertyDescriptor(pixiObject, "app");
            
            if (!appDescriptor) {
              // Property doesn't exist, try to create it
              Object.defineProperty(pixiObject, "app", {
                value: this.app,
                writable: true,
                configurable: true,
                enumerable: false
              });
              pixiExtensionSuccessful = true;
            } else {
              // Property exists - check if we can modify it
              if (appDescriptor.writable) {
                pixiObject.app = this.app;
                pixiExtensionSuccessful = true;
              } else if (appDescriptor.configurable) {
                // Reconfigure the property
                Object.defineProperty(pixiObject, "app", {
                  value: this.app,
                  writable: true,
                  configurable: true,
                  enumerable: false
                });
                pixiExtensionSuccessful = true;
              } else {
              }
            }

            // Handle apps array property if app property was successful
            if (pixiExtensionSuccessful) {
              const appsDescriptor = Object.getOwnPropertyDescriptor(pixiObject, "apps");
              
              if (!appsDescriptor) {
                // Property doesn't exist, create it
                Object.defineProperty(pixiObject, "apps", {
                  value: [this.app],
                  writable: true,
                  configurable: true,
                  enumerable: false
                });
              } else if (Array.isArray(pixiObject.apps)) {
                // Property exists and is an array
                if (!pixiObject.apps.includes(this.app)) {
                  try {
                    pixiObject.apps.push(this.app);
                  } catch (pushError) {
                    console.warn("Could not add to PIXI.apps array:", pushError);
                  }
                }
              } else {
              }
            }
          } catch (pixiError) {
            console.warn("Could not modify PIXI object properties:", pixiError);
            pixiExtensionSuccessful = false;
          }
        } else {
          pixiExtensionSuccessful = false;
        }
      } else {
        pixiExtensionSuccessful = false;
      }
      
      // Always create alternative global references (either as primary or fallback)
      try {
        (window as any).PIXI_APP_INSTANCE = this.app;
        const existingApps = (window as any).PIXI_APPS || [];
        (window as any).PIXI_APPS = Array.isArray(existingApps) 
          ? [...existingApps, this.app].filter((app, index, arr) => arr.indexOf(app) === index)
          : [this.app];
        
        if (pixiExtensionSuccessful) {
        } else {
        }
      } catch (fallbackError) {
        console.warn("Could not create alternative global references:", fallbackError);
      }

      // Initialize PIXI devtools - for v8.2+ use no-parameter call
      try {

        // For PIXI v8.2+, try with app parameter first
        initDevtools({ app: this.app });

        // Dispatch custom event for additional devtools support
        window.dispatchEvent(
          new CustomEvent("pixi-app-ready", { detail: this.app }),
        );
      } catch (error) {
        console.error(
          "‚ùå Failed to initialize PIXI devtools with global hooks:",
          error,
        );

        // Fallback to explicit configuration
        try {
          initDevtools({
            app: this.app,
          });
        } catch (fallbackError) {
          try {
            initDevtools({
              renderer: this.app.renderer,
              stage: this.app.stage,
            });
          } catch (finalError) {
            console.error(
              "‚ùå All devtools initialization methods failed:",
              finalError,
            );
          }
        }
      }

      // Style the canvas to be centered in container
      this.styleCanvas();

      // Store the scale factor for layout calculations
      (this.app as any).scaleToA4 = {
        width: 794 / canvasWidth,
        height: 1123 / canvasHeight,
        canvasWidth,
        canvasHeight,
      };

      // Enhanced devtools compatibility
      this.enhanceDevtoolsCompatibility();

      return this.app;
    } catch (error) {
      console.error("‚ùå Failed to initialize PixiJS Application:", error);
      throw error;
    }
  }

  /**
   * Enhanced devtools compatibility measures
   */
  private enhanceDevtoolsCompatibility(): void {
    if (!this.app) return;

    // Register with global hook if available
    if ((window as any).__PIXI_DEVTOOLS_GLOBAL_HOOK__) {
      (window as any).__PIXI_DEVTOOLS_GLOBAL_HOOK__.register(this.app);
    }

    // Make app detectable by various methods
    const globalTargets = [window, globalThis];
    globalTargets.forEach((target) => {
      if (!(target as any).pixiApps) (target as any).pixiApps = [];
      if (!(target as any).pixiApps.includes(this.app)) {
        (target as any).pixiApps.push(this.app);
      }
    });

    // Add event listeners for devtools frame detection
    this.app.renderer.on("resize", () => {
      // Silent hook for devtools detection
    });

  }

  /**
   * Style the canvas element
   */
  private styleCanvas(): void {
    if (!this.app) return;

    this.app.canvas.style.display = "block";
    this.app.canvas.style.margin = "auto";
    this.app.canvas.style.border = "2px solid #6495ed";
    this.app.canvas.style.borderRadius = "8px";
    this.app.canvas.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.1)";
  }

  /**
   * Resize the application
   */
  public resize(width: number, height: number): void {
    if (this.app) {
      this.app.renderer.resize(width, height);
    }
  }

  /**
   * Get the PIXI application instance
   */
  public getApplication(): Application | null {
    return this.app;
  }

  /**
   * Get canvas dimensions
   */
  public getDimensions(): { width: number; height: number } {
    if (!this.app) {
      return { width: 0, height: 0 };
    }

    return {
      width: this.app.screen.width,
      height: this.app.screen.height,
    };
  }

  /**
   * Get detailed canvas information
   */
  public getCanvasInfo(): any {
    if (!this.app) return null;

    return {
      dimensions: this.getDimensions(),
      renderer: {
        type: this.app.renderer.type,
        resolution: this.app.renderer.resolution,
      },
      stage: {
        children: this.app.stage.children.length,
        interactive: this.app.stage.eventMode === "static",
      },
      scaleToA4: (this.app as any).scaleToA4,
    };
  }

  /**
   * Export canvas as image
   */
  public async exportAsImage(): Promise<string> {
    if (!this.app) {
      throw new Error("PixiJS application not initialized");
    }

    try {
      // Extract the canvas as base64
      const base64 = await this.app.renderer.extract.base64(this.app.stage);
      return base64;
    } catch (error) {
      console.error("‚ùå Failed to export canvas as image:", error);
      throw error;
    }
  }

  /**
   * Destroy the application
   */
  public destroy(): void {
    if (this.app) {
      this.app.destroy(true, { children: true, texture: true });
      this.app = null;
      
      // Clean up global references for this specific instance
      try {
        if ((window as any).__PIXI_APP__ === this.app) {
          delete (window as any).__PIXI_APP__;
        }
        if ((globalThis as any).__PIXI_APP__ === this.app) {
          delete (globalThis as any).__PIXI_APP__;
        }
      } catch (error) {
        console.warn("Could not clean up global app references:", error);
      }
      
    }
  }
}
/**
 * Canvas Event Handler
 * Manages PIXI canvas events and interactions
 * Single Responsibility: Event handling only
 */

import { Application, Container, FederatedPointerEvent } from "pixi.js";
import { ToolManager } from "../tools/ToolManager";

export class CanvasEventHandler {
  private app: Application;
  private toolManager: ToolManager;
  private drawingContainer: Container | null = null;

  constructor(app: Application, toolManager: ToolManager) {
    this.app = app;
    this.toolManager = toolManager;
  }

  /**
   * Set drawing container for tool interactions
   */
  public setDrawingContainer(container: Container): void {
    this.drawingContainer = container;
  }

  /**
   * Set up all canvas events
   */
  public setupEvents(): void {
    // Make the stage interactive
    this.app.stage.eventMode = "static";
    this.app.stage.hitArea = this.app.screen;

    // Add pointer events
    this.setupPointerEvents();

  }

  /**
   * Set up pointer events for tool interactions
   */
  private setupPointerEvents(): void {
    // Pointer down event
    this.app.stage.on("pointerdown", (event: FederatedPointerEvent) => {
      this.handlePointerDown(event);
    });

    // Pointer move event
    this.app.stage.on("pointermove", (event: FederatedPointerEvent) => {
      this.handlePointerMove(event);
    });

    // Pointer up event
    this.app.stage.on("pointerup", (event: FederatedPointerEvent) => {
      this.handlePointerUp(event);
    });

  }

  /**
   * Handle pointer down events
   */
  private handlePointerDown(event: FederatedPointerEvent): void {
    const activeTool = this.toolManager.getActiveTool();
    if (activeTool && this.drawingContainer) {
      try {
        activeTool.onPointerDown(event, this.drawingContainer);
      } catch (error) {
        console.error("‚ùå Error in tool pointer down:", error);
      }
    }
  }

  /**
   * Handle pointer move events
   */
  private handlePointerMove(event: FederatedPointerEvent): void {
    const activeTool = this.toolManager.getActiveTool();
    if (activeTool && this.drawingContainer) {
      try {
        activeTool.onPointerMove(event, this.drawingContainer);
      } catch (error) {
        console.error("‚ùå Error in tool pointer move:", error);
      }
    }
  }

  /**
   * Handle pointer up events
   */
  private handlePointerUp(event: FederatedPointerEvent): void {
    const activeTool = this.toolManager.getActiveTool();
    if (activeTool && this.drawingContainer) {
      try {
        activeTool.onPointerUp(event, this.drawingContainer);
      } catch (error) {
        console.error("‚ùå Error in tool pointer up:", error);
      }
    }
  }

  /**
   * Update canvas cursor based on current tool
   */
  public updateCanvasCursor(toolName: string): void {
    const canvas = this.app.canvas;
    if (!canvas) return;

    // Remove all cursor classes
    canvas.classList.remove(
      "cursor-pen",
      "cursor-eraser",
      "cursor-text",
      "cursor-highlighter",
      "cursor-selection",
    );

    // Add cursor class for current tool
    switch (toolName) {
      case "pen":
        canvas.classList.add("cursor-pen");
        break;
      case "eraser":
        canvas.classList.add("cursor-eraser");
        break;
      case "text":
        canvas.classList.add("cursor-text");
        break;
      case "highlighter":
        canvas.classList.add("cursor-highlighter");
        break;
      default:
        canvas.classList.add("cursor-selection");
    }

  }

  /**
   * Enable/disable events
   */
  public setEventsEnabled(enabled: boolean): void {
    this.app.stage.eventMode = enabled ? "static" : "none";
  }

  /**
   * Get event information
   */
  public getEventInfo(): any {
    return {
      stageInteractive: this.app.stage.eventMode === "static",
      hasHitArea: !!this.app.stage.hitArea,
      eventMode: this.app.stage.eventMode,
    };
  }

  /**
   * Destroy event handler
   */
  public destroy(): void {
    // Remove all event listeners
    this.app.stage.off("pointerdown");
    this.app.stage.off("pointermove");
    this.app.stage.off("pointerup");

    // Disable events
    this.app.stage.eventMode = "none";

  }
}
import { Command } from "./Command";

/**
 * Manages the execution, undoing, and redoing of commands.
 */
export class CommandManager {
  private undoStack: Command[] = [];
  private redoStack: Command[] = [];

  /**
   * Executes a command and adds it to the undo stack.
   * @param command The command to execute.
   */
  public executeCommand(command: Command): void {
    command.execute();
    this.undoStack.push(command);
    // When a new command is executed, the redo stack must be cleared.
    this.redoStack = [];
  }

  /**
   * Undoes the most recent command.
   */
  public undo(): void {
    const command = this.undoStack.pop();
    if (command) {
      command.undo();
      this.redoStack.push(command);
        `Command undone, undo stack size: ${this.undoStack.length}, redo stack size: ${this.redoStack.length}`,
      );
    } else {
    }
  }

  /**
   * Redoes the most recently undone command.
   */
  public redo(): void {
    const command = this.redoStack.pop();
    if (command) {
      command.execute();
      this.undoStack.push(command);
        `Command redone, undo stack size: ${this.undoStack.length}, redo stack size: ${this.redoStack.length}`,
      );
    } else {
    }
  }

  /**
   * Checks if there is anything to undo.
   * @returns True if the undo stack is not empty, false otherwise.
   */
  public canUndo(): boolean {
    return this.undoStack.length > 0;
  }

  /**
   * Checks if there is anything to redo.
   * @returns True if the redo stack is not empty, false otherwise.
   */
  public canRedo(): boolean {
    return this.redoStack.length > 0;
  }
}
import { Command } from "./Command";
import { Container, Graphics, Sprite, Text } from "pixi.js";

// Union type for common PIXI display objects
type DisplayObject = Container | Graphics | Sprite | Text;

/**
 * A command to add a DisplayObject to a PIXI.Container.
 */
export class AddObjectCommand implements Command {
  private readonly objectToAdd: DisplayObject;
  private readonly parentContainer: Container;

  /**
   * @param objectToAdd The PIXI.DisplayObject to be added to the canvas.
   * @param parentContainer The PIXI.Container to which the object will be added.
   */
  constructor(objectToAdd: DisplayObject, parentContainer: Container) {
    this.objectToAdd = objectToAdd;
    this.parentContainer = parentContainer;
  }

  /**
   * Executes the command, adding the object to the container.
   */
  public execute(): void {
    this.parentContainer.addChild(this.objectToAdd);
  }

  /**
   * Undoes the command, removing the object from the container.
   */
  public undo(): void {
    this.parentContainer.removeChild(this.objectToAdd);
  }
}
/**
 * Command Interface
 * Defines the structure for all commands in the application, enabling undo/redo functionality.
 */
export interface Command {
  /**
   * Executes the command's action.
   */
  execute(): void;

  /**
   * Reverts the command's action.
   */
  undo(): void;
}
/**
 * Font Manager Core
 * Core font management and family selection
 * Single Responsibility: Font family management and coordination only
 */

import { FontStyleController } from "./FontStyleController.js";
import { FontSizeController } from "./FontSizeController.js";

export class FontManager {
  private currentFont: string = "Arial";
  private availableFonts: Array<{
    name: string;
    family: string;
    loaded: boolean;
  }> = [];
  private fontStyleController: FontStyleController;
  private fontSizeController: FontSizeController;
  private onFontChangeCallback: ((fontFamily: string) => void) | null = null;

  constructor() {
    this.fontStyleController = new FontStyleController();
    this.fontSizeController = new FontSizeController();

    this.initializeDefaultFonts();
    this.bindFontFamilyEvents();
    this.setupControllerCallbacks();
  }

  /**
   * Set callback for font changes
   */
  setOnFontChange(callback: (fontFamily: string) => void): void {
    this.onFontChangeCallback = callback;
  }

  /**
   * Initialize default system fonts
   */
  private initializeDefaultFonts(): void {
    const systemFonts = [
      { name: "Arial", family: "Arial, sans-serif", loaded: true },
      {
        name: "Times New Roman",
        family: "Times New Roman, serif",
        loaded: true,
      },
      { name: "Courier New", family: "Courier New, monospace", loaded: true },
      {
        name: "Helvetica",
        family: "Helvetica, Arial, sans-serif",
        loaded: true,
      },
      { name: "Georgia", family: "Georgia, serif", loaded: true },
      { name: "Verdana", family: "Verdana, sans-serif", loaded: true },
      { name: "Comic Sans MS", family: "Comic Sans MS, cursive", loaded: true },
      { name: "Impact", family: "Impact, sans-serif", loaded: true },
    ];

    this.availableFonts = [...systemFonts];
    this.populateFontSelector();

  }

  /**
   * Bind font family selection events
   */
  private bindFontFamilyEvents(): void {
    const fontSelect = document.getElementById(
      "font-family",
    ) as HTMLSelectElement;
    if (fontSelect) {
      fontSelect.addEventListener("change", this.handleFontChange.bind(this));
    }
  }

  /**
   * Setup controller callbacks
   */
  private setupControllerCallbacks(): void {
    // Font style changes
    this.fontStyleController.setOnStyleChange((styles) => {
    });

    // Font size changes
    this.fontSizeController.setOnSizeChange((size) => {
    });
  }

  /**
   * Handle font family change
   */
  private handleFontChange(event: Event): void {
    const select = event.target as HTMLSelectElement;
    const selectedFont = this.availableFonts.find(
      (font) => font.name === select.value,
    );

    if (selectedFont) {
      this.currentFont = selectedFont.name;

      // Trigger callback
      if (this.onFontChangeCallback) {
        this.onFontChangeCallback(selectedFont.family);
      }
    }
  }

  /**
   * Populate font selector dropdown
   */
  private populateFontSelector(): void {
    const fontSelect = document.getElementById(
      "font-family",
    ) as HTMLSelectElement;
    if (!fontSelect) return;

    fontSelect.innerHTML = this.availableFonts
      .map(
        (font) =>
          `<option value="${font.name}" ${font.name === this.currentFont ? "selected" : ""}>${font.name}</option>`,
      )
      .join("");
  }

  /**
   * Load custom font
   */
  async loadCustomFont(fontName: string, fontUrl: string): Promise<void> {
    try {
      const font = new FontFace(fontName, `url(${fontUrl})`);
      await font.load();
      document.fonts.add(font);

      // Add to available fonts
      const customFont = {
        name: fontName,
        family: `${fontName}, sans-serif`,
        loaded: true,
      };

      this.availableFonts.push(customFont);
      this.populateFontSelector();

    } catch (error) {
      console.error("‚ùå Failed to load custom font:", fontName, error);
    }
  }

  /**
   * Get current font
   */
  getCurrentFont(): string {
    return this.currentFont;
  }

  /**
   * Get current font family
   */
  getCurrentFontFamily(): string {
    const currentFontObj = this.availableFonts.find(
      (font) => font.name === this.currentFont,
    );
    return currentFontObj?.family || "Arial, sans-serif";
  }

  /**
   * Set current font
   */
  setCurrentFont(fontName: string): void {
    const font = this.availableFonts.find((f) => f.name === fontName);
    if (font) {
      this.currentFont = fontName;

      // Update selector
      const fontSelect = document.getElementById(
        "font-family",
      ) as HTMLSelectElement;
      if (fontSelect) {
        fontSelect.value = fontName;
      }


      // Trigger callback
      if (this.onFontChangeCallback) {
        this.onFontChangeCallback(font.family);
      }
    }
  }

  /**
   * Get available fonts
   */
  getAvailableFonts(): Array<{
    name: string;
    family: string;
    loaded: boolean;
  }> {
    return [...this.availableFonts];
  }

  /**
   * Get font style controller
   */
  getStyleController(): FontStyleController {
    return this.fontStyleController;
  }

  /**
   * Get font size controller
   */
  getSizeController(): FontSizeController {
    return this.fontSizeController;
  }

  /**
   * Get complete font configuration
   */
  getCurrentFontConfig(): {
    family: string;
    size: number;
    styles: { bold: boolean; italic: boolean; underline: boolean };
  } {
    return {
      family: this.getCurrentFontFamily(),
      size: this.fontSizeController.getCurrentSize(),
      styles: this.fontStyleController.getCurrentStyles(),
    };
  }

  /**
   * Apply font configuration to element
   */
  applyFontToElement(element: HTMLElement): void {
    const config = this.getCurrentFontConfig();

    element.style.fontFamily = config.family;
    element.style.fontSize = `${config.size}px`;

    this.fontStyleController.applyStylesToElement(element);
  }

  /**
   * Reset all font settings to defaults
   */
  resetToDefaults(): void {
    this.setCurrentFont("Arial");
    this.fontSizeController.reset();
    this.fontStyleController.resetStyles();
  }

  /**
   * Cleanup
   */
  destroy(): void {
    this.fontStyleController.destroy();
    this.fontSizeController.destroy();
    this.onFontChangeCallback = null;
  }
}
/**
 * Font Size Controller - Font size management only
 */

export class FontSizeController {
  private currentSize: number = 16;
  private minSize: number = 8;
  private maxSize: number = 72;
  private sizeOptions: number[] = [
    8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 28, 32, 36, 48, 60, 72,
  ];
  private onSizeChangeCallback: ((size: number) => void) | null = null;

  constructor() {
    this.bindEvents();
    this.updateUI();
  }

  setOnSizeChange(callback: (size: number) => void): void {
    this.onSizeChangeCallback = callback;
  }

  private bindEvents(): void {
    const increaseBtns = document.querySelectorAll(
      '[data-font-action="increase"]',
    );
    const decreaseBtns = document.querySelectorAll(
      '[data-font-action="decrease"]',
    );
    increaseBtns.forEach((btn) =>
      btn.addEventListener("click", () => this.increaseSize()),
    );
    decreaseBtns.forEach((btn) =>
      btn.addEventListener("click", () => this.decreaseSize()),
    );

    const sizeSelects = document.querySelectorAll(
      'select[data-font-property="size"]',
    );
    sizeSelects.forEach((select) => {
      select.addEventListener("change", (e) => this.handleSizeSelect(e));
    });

    const sizeInputs = document.querySelectorAll(
      'input[data-font-property="size"]',
    );
    sizeInputs.forEach((input) => {
      input.addEventListener("input", (e) => this.handleSizeInput(e));
      input.addEventListener("blur", (e) => this.handleSizeBlur(e));
    });

    document.addEventListener("keydown", (e) =>
      this.handleKeyboardShortcuts(e),
    );
  }

  private handleKeyboardShortcuts(event: KeyboardEvent): void {
    if (
      event.target instanceof HTMLInputElement ||
      event.target instanceof HTMLTextAreaElement
    ) {
      return;
    }

    if (event.ctrlKey || event.metaKey) {
      if (event.key === "=") {
        event.preventDefault();
        this.increaseSize();
      } else if (event.key === "-") {
        event.preventDefault();
        this.decreaseSize();
      }
    }
  }

  private handleSizeSelect(event: Event): void {
    const target = event.target as HTMLSelectElement;
    const newSize = parseInt(target.value);
    if (!isNaN(newSize)) {
      this.setSize(newSize);
    }
  }

  private handleSizeInput(event: Event): void {
    const target = event.target as HTMLInputElement;
    const value = target.value.trim();
    if (value === "") return;

    const newSize = parseInt(value);
    if (!isNaN(newSize) && newSize !== this.currentSize) {
      const clampedSize = Math.min(
        Math.max(newSize, this.minSize),
        this.maxSize,
      );
      if (clampedSize !== newSize) {
        target.value = clampedSize.toString();
      }
      this.setSize(clampedSize);
    }
  }

  private handleSizeBlur(event: Event): void {
    const target = event.target as HTMLInputElement;
    if (target.value.trim() === "") {
      target.value = this.currentSize.toString();
    }
  }

  increaseSize(): void {
    const currentIndex = this.sizeOptions.indexOf(this.currentSize);
    if (currentIndex !== -1 && currentIndex < this.sizeOptions.length - 1) {
      this.setSize(this.sizeOptions[currentIndex + 1]);
    } else {
      this.setSize(Math.min(this.currentSize + 2, this.maxSize));
    }
  }

  decreaseSize(): void {
    const currentIndex = this.sizeOptions.indexOf(this.currentSize);
    if (currentIndex > 0) {
      this.setSize(this.sizeOptions[currentIndex - 1]);
    } else {
      this.setSize(Math.max(this.currentSize - 2, this.minSize));
    }
  }

  setSize(size: number): void {
    const clampedSize = Math.min(Math.max(size, this.minSize), this.maxSize);
    if (clampedSize === this.currentSize) return;

    this.currentSize = clampedSize;
    this.updateUI();

    if (this.onSizeChangeCallback) {
      this.onSizeChangeCallback(this.currentSize);
    }
  }

  private updateUI(): void {
    const selects = document.querySelectorAll(
      'select[data-font-property="size"]',
    ) as NodeListOf<HTMLSelectElement>;
    selects.forEach((select) => {
      if (!select.querySelector(`option[value="${this.currentSize}"]`)) {
        const option = document.createElement("option");
        option.value = this.currentSize.toString();
        option.textContent = this.currentSize.toString();
        select.appendChild(option);
      }
      select.value = this.currentSize.toString();
    });

    const inputs = document.querySelectorAll(
      'input[data-font-property="size"]',
    ) as NodeListOf<HTMLInputElement>;
    inputs.forEach((input) => {
      input.value = this.currentSize.toString();
    });

    const displays = document.querySelectorAll("[data-font-size-display]");
    displays.forEach((display) => {
      display.textContent = `${this.currentSize}px`;
    });
  }

  private populateSizeOptions(select: HTMLSelectElement): void {
    select.innerHTML = "";
    this.sizeOptions.forEach((size) => {
      const option = document.createElement("option");
      option.value = size.toString();
      option.textContent = size.toString();
      if (size === this.currentSize) {
        option.selected = true;
      }
      select.appendChild(option);
    });
  }

  getCurrentSize(): number {
    return this.currentSize;
  }

  getSizeOptions(): number[] {
    return [...this.sizeOptions];
  }

  getMinSize(): number {
    return this.minSize;
  }

  getMaxSize(): number {
    return this.maxSize;
  }

  setMinSize(size: number): void {
    this.minSize = Math.max(1, size);
    if (this.currentSize < this.minSize) {
      this.setSize(this.minSize);
    }
  }

  setMaxSize(size: number): void {
    this.maxSize = Math.max(this.minSize, size);
    if (this.currentSize > this.maxSize) {
      this.setSize(this.maxSize);
    }
  }

  setSizeOptions(options: number[]): void {
    this.sizeOptions = options.sort((a, b) => a - b);
    this.updateUI();
  }

  reset(): void {
    this.setSize(16);
  }

  destroy(): void {
    const increaseBtns = document.querySelectorAll(
      '[data-font-action="increase"]',
    );
    const decreaseBtns = document.querySelectorAll(
      '[data-font-action="decrease"]',
    );
    const selects = document.querySelectorAll(
      'select[data-font-property="size"]',
    );
    const inputs = document.querySelectorAll(
      'input[data-font-property="size"]',
    );

    [...increaseBtns, ...decreaseBtns].forEach((btn) => {
      btn.removeEventListener("click", () => this.increaseSize());
    });

    selects.forEach((select) => {
      select.removeEventListener("change", this.handleSizeSelect);
    });

    inputs.forEach((input) => {
      input.removeEventListener("input", this.handleSizeInput);
      input.removeEventListener("blur", this.handleSizeBlur);
    });

    document.removeEventListener("keydown", this.handleKeyboardShortcuts);
    this.onSizeChangeCallback = null;
  }
}
/**
 * Font Style Controller
 * Manages font styling controls (bold, italic, underline) and related UI
 * Single Responsibility: Font style management only
 */

export class FontStyleController {
  private onStyleChangeCallback:
    | ((styles: {
        bold?: boolean;
        italic?: boolean;
        underline?: boolean;
      }) => void)
    | null = null;

  constructor() {
    this.bindStyleEvents();
  }

  /**
   * Set callback for style changes
   */
  setOnStyleChange(
    callback: (styles: {
      bold?: boolean;
      italic?: boolean;
      underline?: boolean;
    }) => void,
  ): void {
    this.onStyleChangeCallback = callback;
  }

  /**
   * Bind font style events
   */
  private bindStyleEvents(): void {
    // Bold button
    const boldBtn = document.getElementById("font-bold");
    if (boldBtn) {
      boldBtn.addEventListener("click", this.toggleBold.bind(this));
    }

    // Italic button
    const italicBtn = document.getElementById("font-italic");
    if (italicBtn) {
      italicBtn.addEventListener("click", this.toggleItalic.bind(this));
    }

    // Underline button
    const underlineBtn = document.getElementById("font-underline");
    if (underlineBtn) {
      underlineBtn.addEventListener("click", this.toggleUnderline.bind(this));
    }
  }

  /**
   * Toggle bold styling
   */
  private toggleBold(): void {
    const boldBtn = document.getElementById("font-bold");
    if (boldBtn) {
      boldBtn.classList.toggle("active");
      const isActive = boldBtn.classList.contains("active");


      // Trigger callback
      if (this.onStyleChangeCallback) {
        this.onStyleChangeCallback({ bold: isActive });
      }

      // Emit custom event
      const boldEvent = new CustomEvent("fontBoldToggle", {
        detail: { active: isActive },
      });
      document.dispatchEvent(boldEvent);
    }
  }

  /**
   * Toggle italic styling
   */
  private toggleItalic(): void {
    const italicBtn = document.getElementById("font-italic");
    if (italicBtn) {
      italicBtn.classList.toggle("active");
      const isActive = italicBtn.classList.contains("active");


      // Trigger callback
      if (this.onStyleChangeCallback) {
        this.onStyleChangeCallback({ italic: isActive });
      }

      // Emit custom event
      const italicEvent = new CustomEvent("fontItalicToggle", {
        detail: { active: isActive },
      });
      document.dispatchEvent(italicEvent);
    }
  }

  /**
   * Toggle underline styling
   */
  private toggleUnderline(): void {
    const underlineBtn = document.getElementById("font-underline");
    if (underlineBtn) {
      underlineBtn.classList.toggle("active");
      const isActive = underlineBtn.classList.contains("active");


      // Trigger callback
      if (this.onStyleChangeCallback) {
        this.onStyleChangeCallback({ underline: isActive });
      }

      // Emit custom event
      const underlineEvent = new CustomEvent("fontUnderlineToggle", {
        detail: { active: isActive },
      });
      document.dispatchEvent(underlineEvent);
    }
  }

  /**
   * Get current font styles
   */
  getCurrentStyles(): { bold: boolean; italic: boolean; underline: boolean } {
    return {
      bold:
        document.getElementById("font-bold")?.classList.contains("active") ||
        false,
      italic:
        document.getElementById("font-italic")?.classList.contains("active") ||
        false,
      underline:
        document
          .getElementById("font-underline")
          ?.classList.contains("active") || false,
    };
  }

  /**
   * Apply font styles
   */
  applyStyles(styles: {
    bold?: boolean;
    italic?: boolean;
    underline?: boolean;
  }): void {
    if (styles.bold !== undefined) {
      const boldBtn = document.getElementById("font-bold");
      if (boldBtn) {
        boldBtn.classList.toggle("active", styles.bold);
      }
    }

    if (styles.italic !== undefined) {
      const italicBtn = document.getElementById("font-italic");
      if (italicBtn) {
        italicBtn.classList.toggle("active", styles.italic);
      }
    }

    if (styles.underline !== undefined) {
      const underlineBtn = document.getElementById("font-underline");
      if (underlineBtn) {
        underlineBtn.classList.toggle("active", styles.underline);
      }
    }

    // Trigger callback for all applied styles
    if (this.onStyleChangeCallback) {
      this.onStyleChangeCallback(styles);
    }
  }

  /**
   * Reset all styles to default (off)
   */
  resetStyles(): void {
    this.applyStyles({ bold: false, italic: false, underline: false });
  }

  /**
   * Check if any styles are active
   */
  hasActiveStyles(): boolean {
    const styles = this.getCurrentStyles();
    return styles.bold || styles.italic || styles.underline;
  }

  /**
   * Get active styles as CSS text properties
   */
  getStylesAsCSS(): {
    fontWeight?: string;
    fontStyle?: string;
    textDecoration?: string;
  } {
    const styles = this.getCurrentStyles();
    const css: {
      fontWeight?: string;
      fontStyle?: string;
      textDecoration?: string;
    } = {};

    if (styles.bold) css.fontWeight = "bold";
    if (styles.italic) css.fontStyle = "italic";
    if (styles.underline) css.textDecoration = "underline";

    return css;
  }

  /**
   * Apply styles to element
   */
  applyStylesToElement(element: HTMLElement): void {
    const cssStyles = this.getStylesAsCSS();

    element.style.fontWeight = cssStyles.fontWeight || "normal";
    element.style.fontStyle = cssStyles.fontStyle || "normal";
    element.style.textDecoration = cssStyles.textDecoration || "none";
  }

  /**
   * Cleanup
   */
  destroy(): void {
    this.onStyleChangeCallback = null;
  }
}
/**
 * Focused Media Manager
 * Coordinates media selection, search, and panel management
 * Single Responsibility: High-level media coordination only
 */

import { MediaSelectionController } from "./MediaSelectionController";
import { MediaSearchController } from "./MediaSearchController";
import { MediaPanelManager } from "./MediaPanelManager";

export class MediaManagerRefactored {
  private selectionController: MediaSelectionController;
  private searchController: MediaSearchController;
  private panelManager: MediaPanelManager;
  private onMediaSelectionCallback: ((mediaType: string) => void) | null = null;

  constructor() {
    this.selectionController = new MediaSelectionController();
    this.searchController = new MediaSearchController();
    this.panelManager = new MediaPanelManager();

    this.setupComponentCallbacks();
  }

  /**
   * Setup callbacks between components
   */
  private setupComponentCallbacks(): void {
    // When media type is selected, update search context and panel
    this.selectionController.setOnMediaSelection((mediaType: string) => {
      this.searchController.setMediaType(mediaType);
      this.panelManager.updateSearchPanel(mediaType);

      // Trigger external callback
      if (this.onMediaSelectionCallback) {
        this.onMediaSelectionCallback(mediaType);
      }
    });

    // When search results are ready, display them
    this.searchController.setOnSearchResults((results: any[]) => {
      this.panelManager.displaySearchResults(results);
    });

    // When media item is selected from panel, add to canvas
    this.panelManager.setOnMediaSelection((mediaUrl: string) => {
      this.addMediaToCanvas(mediaUrl);
    });
  }

  /**
   * Set callback for media selection events
   */
  setOnMediaSelection(callback: (mediaType: string) => void): void {
    this.onMediaSelectionCallback = callback;
  }

  /**
   * Add media to canvas
   */
  private addMediaToCanvas(mediaUrl: string): void {

    // Dispatch event for canvas integration
    const event = new CustomEvent("addMediaToCanvas", {
      detail: {
        url: mediaUrl,
        type: this.selectionController.getSelectedMediaType(),
      },
    });
    document.dispatchEvent(event);
  }

  /**
   * Get current state
   */
  getState(): any {
    return {
      selectedMediaType: this.selectionController.getSelectedMediaType(),
      searchState: this.searchController.getSearchState(),
      panelOpen: this.panelManager.isPanelOpen(),
      availableMediaTypes: this.selectionController.getAvailableMediaTypes(),
    };
  }

  /**
   * Clear all selections and close panel
   */
  clear(): void {
    this.selectionController.clearSelection();
    this.searchController.clearSearch();
    this.panelManager.closePanel();
  }

  /**
   * Destroy all components
   */
  destroy(): void {
    this.selectionController.destroy();
    this.searchController.destroy();
    this.panelManager.destroy();
    this.onMediaSelectionCallback = null;
  }
}
/**
 * Media Panel Manager
 * Manages search panel display and result rendering
 * Single Responsibility: Panel UI management only
 */

export class MediaPanelManager {
  private panelElement: HTMLElement | null = null;
  private resultsContainer: HTMLElement | null = null;
  private onMediaSelectionCallback: ((url: string) => void) | null = null;

  constructor() {
    this.initializePanelElements();
  }

  /**
   * Initialize panel elements
   */
  private initializePanelElements(): void {
    this.panelElement = document.getElementById("media-search-panel");
    this.resultsContainer = document.getElementById("media-search-results");
  }

  /**
   * Set callback for media item selection
   */
  setOnMediaSelection(callback: (url: string) => void): void {
    this.onMediaSelectionCallback = callback;
  }

  /**
   * Update search panel for media type
   */
  updateSearchPanel(mediaType: string): void {
    if (!this.panelElement) return;

    // Update panel title
    const panelTitle = this.panelElement.querySelector(".media-panel-title");
    if (panelTitle) {
      panelTitle.textContent = `Search ${mediaType.charAt(0).toUpperCase() + mediaType.slice(1)}`;
    }

    // Show panel
    this.panelElement.classList.add("media-panel--active");

    // Show placeholder
    this.showSearchPlaceholder();

  }

  /**
   * Display search results
   */
  displaySearchResults(results: any[]): void {
    if (!this.resultsContainer) return;

    // Clear previous results
    this.resultsContainer.innerHTML = "";

    if (results.length === 0) {
      this.showNoResults();
      return;
    }

    // Create result items
    results.forEach((result) => {
      const resultItem = this.createResultItem(result);
      if (this.resultsContainer) {
        this.resultsContainer.appendChild(resultItem);
      }
    });

  }

  /**
   * Create a result item element
   */
  private createResultItem(result: any): HTMLElement {
    const item = document.createElement("div");
    item.className = "media-result-item";
    item.setAttribute("data-media-url", result.url);

    item.innerHTML = `
      <img src="${result.thumbnail}" alt="${result.title}" class="media-result-thumbnail">
      <div class="media-result-info">
        <h4 class="media-result-title">${result.title}</h4>
        <p class="media-result-description">${result.description}</p>
      </div>
    `;

    // Add click handler
    item.addEventListener("click", (event) => {
      this.handleMediaItemSelection(event);
    });

    return item;
  }

  /**
   * Handle media item selection
   */
  private handleMediaItemSelection(event: Event): void {
    const target = event.currentTarget as HTMLElement;
    const mediaUrl = target.getAttribute("data-media-url");

    if (!mediaUrl) return;


    // Trigger callback
    if (this.onMediaSelectionCallback) {
      this.onMediaSelectionCallback(mediaUrl);
    }

    // Close panel
    this.closePanel();
  }

  /**
   * Show search placeholder
   */
  private showSearchPlaceholder(): void {
    if (!this.resultsContainer) return;

    this.resultsContainer.innerHTML = `
      <div class="media-search-placeholder">
        <p>Enter a search term to find media</p>
      </div>
    `;
  }

  /**
   * Show no results message
   */
  private showNoResults(): void {
    if (!this.resultsContainer) return;

    this.resultsContainer.innerHTML = `
      <div class="media-no-results">
        <p>No results found</p>
      </div>
    `;
  }

  /**
   * Close search panel
   */
  closePanel(): void {
    if (!this.panelElement) return;

    this.panelElement.classList.remove("media-panel--active");

    // Clear results
    if (this.resultsContainer) {
      this.resultsContainer.innerHTML = "";
    }

  }

  /**
   * Check if panel is open
   */
  isPanelOpen(): boolean {
    return (
      this.panelElement?.classList.contains("media-panel--active") || false
    );
  }

  /**
   * Destroy panel manager
   */
  destroy(): void {
    // Remove event listeners from result items
    if (this.resultsContainer) {
      const resultItems =
        this.resultsContainer.querySelectorAll(".media-result-item");
      resultItems.forEach((item) => {
        item.removeEventListener("click", this.handleMediaItemSelection);
      });
    }

    this.closePanel();
    this.onMediaSelectionCallback = null;

  }
}
/**
 * Media Selection Controller
 * Handles media type selection and UI interactions
 * Single Responsibility: Media selection UI only
 */

export class MediaSelectionController {
  private onMediaSelectionCallback: ((mediaType: string) => void) | null = null;
  private selectedMediaType: string | null = null;

  constructor() {
    this.bindMediaEvents();
  }

  /**
   * Set callback for media selection
   */
  setOnMediaSelection(callback: (mediaType: string) => void): void {
    this.onMediaSelectionCallback = callback;
  }

  /**
   * Bind media selection events
   */
  private bindMediaEvents(): void {
    // Media type buttons (image, video, audio, etc.)
    const mediaButtons = document.querySelectorAll("[data-media-type]");
    mediaButtons.forEach((button) => {
      button.addEventListener("click", (event) => {
        this.handleMediaSelection(event);
      });
    });
  }

  /**
   * Handle media type selection
   */
  private handleMediaSelection(event: Event): void {
    const target = event.target as HTMLElement;
    const mediaType = target.getAttribute("data-media-type");

    if (!mediaType) return;

    // Update visual selection
    this.updateSelectionUI(mediaType);

    // Store selected media type
    this.selectedMediaType = mediaType;

    // Trigger callback
    if (this.onMediaSelectionCallback) {
      this.onMediaSelectionCallback(mediaType);
    }

  }

  /**
   * Update visual selection in UI
   */
  private updateSelectionUI(selectedType: string): void {
    // Remove active class from all media buttons
    const mediaButtons = document.querySelectorAll("[data-media-type]");
    mediaButtons.forEach((button) => {
      button.classList.remove("media-type--selected");
    });

    // Add active class to selected button
    const selectedButton = document.querySelector(
      `[data-media-type="${selectedType}"]`,
    );
    if (selectedButton) {
      selectedButton.classList.add("media-type--selected");
    }
  }

  /**
   * Get currently selected media type
   */
  getSelectedMediaType(): string | null {
    return this.selectedMediaType;
  }

  /**
   * Clear selection
   */
  clearSelection(): void {
    this.selectedMediaType = null;

    // Remove all active classes
    const mediaButtons = document.querySelectorAll("[data-media-type]");
    mediaButtons.forEach((button) => {
      button.classList.remove("media-type--selected");
    });
  }

  /**
   * Get available media types
   */
  getAvailableMediaTypes(): string[] {
    const buttons = document.querySelectorAll("[data-media-type]");
    return Array.from(buttons)
      .map((button) => button.getAttribute("data-media-type"))
      .filter((type) => type !== null) as string[];
  }

  /**
   * Destroy controller
   */
  destroy(): void {
    // Remove event listeners
    const mediaButtons = document.querySelectorAll("[data-media-type]");
    mediaButtons.forEach((button) => {
      button.removeEventListener("click", this.handleMediaSelection);
    });

    this.onMediaSelectionCallback = null;
    this.selectedMediaType = null;

  }
}
/**
 * Media Search Controller
 * Handles search functionality and result display
 * Single Responsibility: Search operations only
 */

export class MediaSearchController {
  private currentQuery: string = "";
  private currentMediaType: string = "";
  private onSearchCallback: ((results: any[]) => void) | null = null;

  constructor() {
    this.bindSearchEvents();
  }

  /**
   * Set callback for search results
   */
  setOnSearchResults(callback: (results: any[]) => void): void {
    this.onSearchCallback = callback;
  }

  /**
   * Bind search events
   */
  private bindSearchEvents(): void {
    // Search input
    const searchInput = document.getElementById(
      "media-search-input",
    ) as HTMLInputElement;
    if (searchInput) {
      searchInput.addEventListener("input", (event) => {
        this.handleSearchInput(event);
      });

      searchInput.addEventListener("keypress", (event) => {
        this.handleSearchKeypress(event);
      });
    }

    // Search button
    const searchBtn = document.getElementById("media-search-btn");
    if (searchBtn) {
      searchBtn.addEventListener("click", () => {
        this.performSearch();
      });
    }
  }

  /**
   * Handle search input changes
   */
  private handleSearchInput(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentQuery = target.value.trim();
  }

  /**
   * Handle search keypress (Enter to search)
   */
  private handleSearchKeypress(event: KeyboardEvent): void {
    if (event.key === "Enter") {
      event.preventDefault();
      this.performSearch();
    }
  }

  /**
   * Perform media search
   */
  private performSearch(): void {
    if (!this.currentQuery || !this.currentMediaType) {
      console.warn("‚ö†Ô∏è Search query or media type missing");
      return;
    }

      `üîç Searching for ${this.currentMediaType}: "${this.currentQuery}"`,
    );

    // Generate mock results (replace with real API call)
    const results = this.generateMockResults(
      this.currentQuery,
      this.currentMediaType,
    );

    // Trigger callback with results
    if (this.onSearchCallback) {
      this.onSearchCallback(results);
    }
  }

  /**
   * Set media type for search context
   */
  setMediaType(mediaType: string): void {
    this.currentMediaType = mediaType;
  }

  /**
   * Clear search
   */
  clearSearch(): void {
    this.currentQuery = "";
    this.currentMediaType = "";

    const searchInput = document.getElementById(
      "media-search-input",
    ) as HTMLInputElement;
    if (searchInput) {
      searchInput.value = "";
    }
  }

  /**
   * Get current search state
   */
  getSearchState(): { query: string; mediaType: string } {
    return {
      query: this.currentQuery,
      mediaType: this.currentMediaType,
    };
  }

  /**
   * Generate mock search results
   */
  private generateMockResults(
    query: string,
    mediaType: string,
  ): Array<{
    url: string;
    thumbnail: string;
    title: string;
    description: string;
  }> {
    const results = [];
    const baseUrl = "https://picsum.photos";

    for (let i = 1; i <= 8; i++) {
      const imageId = 200 + i;
      results.push({
        url: `${baseUrl}/400/300?random=${imageId}`,
        thumbnail: `${baseUrl}/150/150?random=${imageId}`,
        title: `${mediaType} result ${i} for "${query}"`,
        description: `Sample ${mediaType} found for search term: ${query}`,
      });
    }

    return results;
  }

  /**
   * Destroy controller
   */
  destroy(): void {
    // Remove event listeners
    const searchInput = document.getElementById("media-search-input");
    const searchBtn = document.getElementById("media-search-btn");

    if (searchInput) {
      searchInput.removeEventListener("input", this.handleSearchInput);
      searchInput.removeEventListener("keypress", this.handleSearchKeypress);
    }

    if (searchBtn) {
      searchBtn.removeEventListener("click", this.performSearch);
    }

    this.onSearchCallback = null;
    this.clearSearch();

  }
}
/**
 * Course Builder Navigation
 * Single Responsibility: Handle step-by-step navigation within coursebuilder
 * (Setup ‚Üí Create ‚Üí Preview ‚Üí Launch)
 */

export class CourseBuilderNavigation {
  private sections: string[] = ["setup", "create", "preview", "launch"];
  private currentSectionIndex: number = 0;
  private previousBtn: HTMLButtonElement;
  private nextBtn: HTMLButtonElement;
  private courseBuilder: any; // CourseBuilder instance

  constructor(courseBuilder: any) {
    this.courseBuilder = courseBuilder;

    this.previousBtn = document.getElementById("previous-btn") as HTMLButtonElement;
    this.nextBtn = document.getElementById("next-btn") as HTMLButtonElement;

    this.init();
  }

  private init(): void {
    if (!this.previousBtn || !this.nextBtn) {
      console.error(`CourseBuilderNavigation: Previous or Next button not found`);
      return;
    }

    this.setInitialSection();
    this.bindEvents();
    this.updateUI();
  }

  private setInitialSection(): void {
    const hash = window.location.hash.substring(1);
    const sectionIndex = this.sections.indexOf(hash);

    if (sectionIndex !== -1) {
      this.currentSectionIndex = sectionIndex;
      this.navigateToSection();
    } else {
      this.currentSectionIndex = 0;
      if (hash && hash !== "setup") {
        this.navigateToSection();
      }
    }
  }

  private bindEvents(): void {
    this.previousBtn.addEventListener("click", () => {
      this.goToPrevious();
    });
    
    this.nextBtn.addEventListener("click", () => {
      this.goToNext();
    });

    window.addEventListener("hashchange", () => {
      this.setInitialSection();
    });
  }

  private goToPrevious(): void {
    if (this.currentSectionIndex === 0) {
      window.location.href = "/src/pages/teacher/courses.html";
      return;
    }

    this.currentSectionIndex--;
    this.navigateToSection();
  }

  private goToNext(): void {
    if (this.currentSectionIndex < this.sections.length - 1) {
      this.currentSectionIndex++;
      this.navigateToSection();
    }
  }

  private navigateToSection(): void {
    const currentSection = this.sections[this.currentSectionIndex];
    
    // Remove active classes from all sections
    this.sections.forEach(sectionName => {
      const sectionElement = document.getElementById(sectionName);
      if (sectionElement) {
        sectionElement.style.display = 'none';
        sectionElement.classList.remove('section--active');
        
        const articleElement = sectionElement.querySelector('.article');
        if (articleElement) {
          articleElement.classList.remove('article--active');
        }
      }
    });

    // Show target section
    const targetSectionElement = document.getElementById(currentSection);
    if (targetSectionElement) {
      targetSectionElement.style.display = 'block';
      targetSectionElement.classList.add('section--active');
      
      const articleElement = targetSectionElement.querySelector('.article');
      if (articleElement) {
        articleElement.classList.add('article--active');
      }
      
      // Initialize canvas for create section
      if (currentSection === 'create') {
        this.initializeCanvasForCreateSection();
      }
      
      // Update the URL hash
      window.location.hash = currentSection;
    } else {
      console.error(`CourseBuilderNavigation: Section ${currentSection} not found`);
    }
  }

  private updateUI(): void {
    // Update button states
    // Previous button is never disabled, it either goes to previous section or courses.html
    this.previousBtn.disabled = false;
    this.nextBtn.disabled = this.currentSectionIndex === this.sections.length - 1;

    // Update button text and styling based on current section
    this.updateButtonText();
  }

  private updateButtonText(): void {
    // Update Previous button - always shows "Courses" when in setup section
    if (this.currentSectionIndex === 0) {
      this.previousBtn.textContent = "Courses";
      this.previousBtn.classList.add("button--secondary");
      this.previousBtn.classList.remove("button--disabled");
    } else {
      const previousSection = this.sections[this.currentSectionIndex - 1];
      this.previousBtn.textContent = `‚Üê ${this.capitalizeFirst(previousSection)}`;
      this.previousBtn.classList.remove("button--secondary", "button--disabled");
    }

    // Update Next button
    if (this.currentSectionIndex < this.sections.length - 1) {
      const nextSection = this.sections[this.currentSectionIndex + 1];
      this.nextBtn.textContent = `${this.capitalizeFirst(nextSection)} ‚Üí`;
    } else {
      this.nextBtn.textContent = "Launch Course";
    }
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private initializeCanvasForCreateSection(): void {
    if (this.courseBuilder && this.courseBuilder.initializeCanvasForCreateSection) {
      this.courseBuilder.initializeCanvasForCreateSection();
    } else {
      console.error(`CourseBuilderNavigation: CourseBuilder not available or missing canvas method`);
    }
  }
}
/**
 * Navigation Factory
 * Single Responsibility: Create appropriate navigation instances based on page type
 * This file is no longer the main initialization point - app.ts handles that
 */

import { AsideNavigation } from "./aside/aside";
import { CourseBuilderNavigation } from "./coursebuilder/coursebuilder";

/**
 * Create AsideNavigation instance
 */
export function createAsideNavigation(): AsideNavigation {
  return new AsideNavigation();
}

/**
 * Create CourseBuilderNavigation instance with CourseBuilder dependency
 */
export function createCourseBuilderNavigation(courseBuilder: any): CourseBuilderNavigation {
  return new CourseBuilderNavigation(courseBuilder);
}

/**
 * Check if current page has aside navigation
 */
export function hasAsideNavigation(path: string): boolean {
  return (
    path.includes("/pages/teacher/home.html") ||
    path.includes("/pages/teacher/coursebuilder.html") ||
    path.includes("/pages/student/home.html") ||
    path.includes("/pages/admin/home.html")
  );
}

/**
 * Check if current page is course builder
 */
export function isCourseBuilderPage(path: string): boolean {
  return path.includes("/pages/teacher/coursebuilder.html");
}
// ==========================================================================
// ASIDE NAVIGATION
// ==========================================================================

export class AsideNavigation {
  private asideLinks: NodeListOf<HTMLAnchorElement>;
  private contentSections: NodeListOf<HTMLElement>;
  private readonly STORAGE_KEY = "coursebuilder_active_section";
  private boundHandleLinkClick: (e: Event) => void;

  constructor() {
    this.asideLinks = document.querySelectorAll(".aside__link");
    this.contentSections = document.querySelectorAll(".article");
    this.boundHandleLinkClick = this.handleLinkClick.bind(this);


    this.init();
  }

  private init(): void {
    if (this.asideLinks.length === 0) {
      console.error("No aside links found");
      return;
    }

    if (this.contentSections.length === 0) {
      console.error("No content sections found");
      return;
    }

    // Restore last active section before binding events
    this.restoreActiveSection();

    this.bindEvents();
  }

  /**
   * Restores the last active section from localStorage
   */
  private restoreActiveSection(): void {
    const savedSection = localStorage.getItem(this.STORAGE_KEY);

    if (savedSection) {

      // Find the link and section elements
      const savedLink = document.querySelector(
        `[data-section="${savedSection}"]`,
      ) as HTMLAnchorElement;
      const savedSectionElement = document.getElementById(savedSection);

      if (savedLink && savedSectionElement) {
        // Remove all active states first
        this.removeActiveStates();

        // Set the saved section as active
        this.setActiveStates(savedLink, savedSection);

      } else {
        console.warn("Saved section not found in DOM:", savedSection);
      }
    } else {
    }
  }

  /**
   * Saves the active section to localStorage
   */
  private saveActiveSection(sectionId: string): void {
    localStorage.setItem(this.STORAGE_KEY, sectionId);
  }

  private bindEvents(): void {
    this.asideLinks.forEach((link: HTMLAnchorElement) => {
      link.addEventListener("click", this.boundHandleLinkClick);
    });
  }

  private handleLinkClick(e: Event): void {
    const target = e.target as HTMLAnchorElement;
    const href = target.getAttribute("href");
    const targetSection = target.getAttribute("data-section");

    // Only handle aside navigation if we're currently in the setup section
    const currentHash = window.location.hash.substring(1);
    const setupSection = document.getElementById("setup");
    const isInSetupSection =
      (currentHash === "setup" || !currentHash) &&
      setupSection?.classList.contains("section--active");

    if (!isInSetupSection) {
      return; // Don't handle clicks when not in setup section
    }

    // If the href is a full page URL (not a hash), allow normal navigation
    if (href && href.startsWith("/") && !href.startsWith("#")) {
      return; // Don't prevent default, let the browser navigate
    }

    // For hash navigation (single-page), prevent default and handle manually
    e.preventDefault();

    if (!targetSection) {
      console.error("No data-section attribute found");
      return;
    }

    // Only handle aside navigation if we're in course builder setup section
    if (this.isInCourseBuilderSetup()) {
      this.removeActiveStates();
      this.setActiveStates(target, targetSection);

      // Save the active section to localStorage
      this.saveActiveSection(targetSection);
    } else {
      // For home page or other contexts, handle normally
      this.removeActiveStates();
      this.setActiveStates(target, targetSection);

      // Save the active section to localStorage
      this.saveActiveSection(targetSection);
    }
  }

  private isInCourseBuilderSetup(): boolean {
    const setupSection = document.getElementById("setup");
    return setupSection
      ? setupSection.classList.contains("section--active")
      : false;
  }

  private removeActiveStates(): void {
    this.asideLinks.forEach((link: HTMLAnchorElement) => {
      link.classList.remove("aside__link--active");
    });

    this.contentSections.forEach((section: HTMLElement) => {
      section.classList.remove("article--active");
    });

  }

  private setActiveStates(
    activeLink: HTMLAnchorElement,
    targetSectionId: string,
  ): void {
    activeLink.classList.add("aside__link--active");

    const targetSection = document.getElementById(targetSectionId);
    if (targetSection) {
      targetSection.classList.add("article--active");
    } else {
      console.error("Target section not found:", targetSectionId);
    }
  }

  /**
   * Show the aside navigation
   */
  public show(): void {
    const asideElement = document.querySelector('.aside') as HTMLElement;
    if (asideElement) {
      asideElement.style.display = 'block';
    }
  }

  /**
   * Hide the aside navigation
   */
  public hide(): void {
    const asideElement = document.querySelector('.aside') as HTMLElement;
    if (asideElement) {
      asideElement.style.display = 'none';
    }
  }

  /**
   * Clean up event listeners and references
   */
  public destroy(): void {
    // Remove event listeners
    this.asideLinks.forEach((link: HTMLAnchorElement) => {
      link.removeEventListener("click", this.boundHandleLinkClick);
    });

  }
}
/**
 * Authentication System
 * Handles user sign up, sign in, sign out, and role-based redirects
 */

import { supabase } from "../supabase";

let currentUser: any = null;

// Sign up new user
export async function signUp(
  email: string,
  password: string,
  fullName: string,
  userRole: string,
) {
  try {
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          full_name: fullName,
          user_role: userRole,
        },
      },
    });

    if (error) {
      return { success: false, error: error.message };
    }

    // The database trigger will automatically create the user profile
    // No need to manually insert into users table anymore!

    return { success: true };
  } catch (error) {
    console.error("Unexpected error during sign up:", error);
    return { success: false, error: "An unexpected error occurred" };
  }
}

// Sign in existing user
export async function signIn(email: string, password: string) {
  try {

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });


    if (error) {
      console.error("Sign in error:", error);
      return { success: false, error: error.message };
    }

    if (data.user) {
      currentUser = data.user;

      // Don't redirect immediately - let the auth state listener handle it
      // This prevents the "connection refused" issue
        "‚úÖ Sign in successful - auth state listener will handle redirect",
      );
    }

    return { success: true };
  } catch (error) {
    console.error("Unexpected error during sign in:", error);
    return { success: false, error: "An unexpected error occurred" };
  }
}

// Sign out user
export async function signOut() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) {
      return { success: false, error: error.message };
    }
    currentUser = null;
    return { success: true };
  } catch (error) {
    return { success: false, error: "An unexpected error occurred" };
  }
}

// Get current user
export function getCurrentUser() {
  return currentUser;
}

// Redirect based on user role
export function redirectUser(userRole: string) {
  const origin = window.location.origin;

  switch (userRole) {
    case "administrator":
      const adminUrl = `${origin}/src/pages/admin/home.html`;
      window.location.href = adminUrl;
      break;
    case "teacher":
      const teacherUrl = `${origin}/src/pages/teacher/home.html`;
      window.location.href = teacherUrl;
      break;
    case "student":
      const studentUrl = `${origin}/src/pages/student/home.html`;
      window.location.href = studentUrl;
      break;
    default:
      console.warn("‚ùå Unknown role, defaulting to student:", userRole);
      const defaultUrl = `${origin}/src/pages/student/home.html`;
      window.location.href = defaultUrl;
  }
}

// Helper function to create user profile
async function createUserProfile(user: any) {
  try {

    const userMetadata = user.user_metadata || {};
    const fullName =
      userMetadata.full_name || user.email?.split("@")[0] || "User";
    const userRole = userMetadata.user_role || "student";

    const nameParts = fullName.split(" ");
    const firstName = nameParts[0] || "";
    const lastName = nameParts.slice(1).join(" ") || "";

    const { error: insertError } = await supabase.from("users").insert({
      id: user.id,
      first_name: firstName,
      last_name: lastName,
      email: user.email,
      role: userRole,
    });

    if (!insertError) {
      redirectUser(userRole);
    } else {
      console.error("‚ùå Failed to create profile:", insertError);
      // Still redirect as fallback
      redirectUser("student");
    }
  } catch (error) {
    console.error("‚ùå Unexpected error creating profile:", error);
    redirectUser("student");
  }
}

// Initialize auth state listener
export function initAuth() {
  supabase.auth.onAuthStateChange(async (event, session) => {

    if (event === "SIGNED_IN" && session?.user) {
      currentUser = session.user;

      // Check current page context - ONLY redirect from actual signin/signup pages
      const currentPath = window.location.pathname;

      // ONLY redirect from signin and signup pages - nowhere else!
      const shouldRedirect =
        currentPath.includes("/pages/shared/signin.html") ||
        currentPath.includes("/pages/shared/signup.html");

      if (!shouldRedirect) {
        return;
      }

        "üìç On signin/signup page, proceeding with role-based redirect",
      );

      // Get role from user metadata - this is where the role is actually stored!
      const userMetadata = session.user.user_metadata || {};
      const userRole = userMetadata.user_role || "student";


      // Add a small delay to ensure everything is ready
      setTimeout(() => {
        redirectUser(userRole);
      }, 500);
    } else if (event === "SIGNED_OUT") {
      currentUser = null;

      // Only redirect to signin if we're on a protected page
      const currentPath = window.location.pathname;
      const isProtectedPage =
        currentPath.includes("/pages/student/") ||
        currentPath.includes("/pages/teacher/") ||
        currentPath.includes("/pages/admin/");

      if (isProtectedPage) {
          "üìç On protected page after sign out, redirecting to signin",
        );
        window.location.href = "/src/pages/shared/signin.html";
      } else {
      }
    }
  });

  // Check if user is already signed in
  supabase.auth.getSession().then(({ data: { session } }) => {
    if (session?.user) {
      currentUser = session.user;
    }
  });
}
// ==========================================================================
// COURSE FORM CONFIGURATION - Field definitions and section configs
// ==========================================================================

// ==========================================================================
// TYPES & INTERFACES
// ==========================================================================

export interface FormFieldConfig {
  name: string;
  type:
    | "text"
    | "textarea"
    | "select"
    | "file"
    | "number"
    | "date"
    | "time"
    | "display"
    | "checkbox";
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  accept?: string; // for file inputs
  options?: string[]; // for select dropdowns
  displayFunction?: () => Promise<string>; // for display fields
}

export interface SectionConfig {
  section: string;
  requiredFields: string[];
  jsonbField?: string; // Store in classification_data, schedule_settings, etc.
  fields: FormFieldConfig[];
  submitLabel?: string;
  autoSave?: boolean;
}

export interface ValidationState {
  [fieldName: string]: boolean;
}

// ==========================================================================
// DYNAMIC FIELD FUNCTIONS
// ==========================================================================

import { supabase } from "../supabase";

export const displayFunctions = {
  async getTeacherName(): Promise<string> {
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (user) {
      const { data: profile } = await supabase
        .from("users")
        .select("first_name, last_name")
        .eq("id", user.id)
        .single();
      return profile
        ? `${profile.first_name} ${profile.last_name}`
        : "Unknown Teacher";
    }
    return "Unknown Teacher";
  },

  async getInstitution(): Promise<string> {
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (user) {
      const { data: profile } = await supabase
        .from("users")
        .select("institution")
        .eq("id", user.id)
        .single();
      return profile?.institution || "Independent";
    }
    return "Independent";
  },
};

// ==========================================================================
// SECTION CONFIGURATIONS
// ==========================================================================

export const SECTION_CONFIGS: { [key: string]: SectionConfig } = {
  essentials: {
    section: "essentials",
    requiredFields: [
      "course_name",
      "course_description",
      "teacher_id",
      "institution",
      "course_language",
      "course_image",
    ],
    fields: [
      { name: "course_name", type: "text", required: true, minLength: 3 },
      {
        name: "course_description",
        type: "textarea",
        required: true,
        minLength: 10,
      },
      {
        name: "teacher_id",
        type: "display",
        required: true,
        displayFunction: displayFunctions.getTeacherName,
      },
      {
        name: "institution",
        type: "display",
        required: true,
        displayFunction: displayFunctions.getInstitution,
      },
      {
        name: "course_language",
        type: "select",
        required: true,
        options: [
          "English",
          "Spanish",
          "French",
          "German",
          "Italian",
          "Portuguese",
          "Dutch",
          "Chinese",
          "Japanese",
          "Korean",
          "Arabic",
          "Other",
        ],
      },
      { name: "course_image", type: "file", required: true, accept: "image/*" },
    ],
    submitLabel: "Create Course",
    autoSave: false,
  },

  classification: {
    section: "classification",
    requiredFields: ["class_year", "domain", "subject"],
    jsonbField: "classification_data",
    fields: [
      {
        name: "class_year",
        type: "select",
        required: true,
        options: [
          "Year 1",
          "Year 2",
          "Year 3",
          "Year 4",
          "Year 5",
          "Year 6",
          "Year 7",
          "Year 8",
          "Year 9",
          "Year 10",
          "Year 11",
          "Year 12",
          "Undergraduate",
          "Graduate",
          "Postgraduate",
        ],
      },
      {
        name: "curricular_framework",
        type: "select",
        required: false,
        options: [
          "National Curriculum",
          "International Baccalaureate",
          "Cambridge International",
          "Advanced Placement",
          "Custom Framework",
          "Other",
        ],
      },
      { name: "domain", type: "text", required: true },
      { name: "subject", type: "text", required: true },
      { name: "topic", type: "text", required: false },
      { name: "subtopic", type: "text", required: false },
      { name: "previous_course", type: "text", required: false },
      { name: "current_course", type: "text", required: false },
      { name: "next_course", type: "text", required: false },
    ],
    autoSave: true,
  },

  templates: {
    section: "templates",
    requiredFields: ["template_type"],
    jsonbField: "template_settings",
    fields: [
      {
        name: "template_type",
        type: "select",
        required: true,
        options: [
          "programming",
          "mathematics",
          "science",
          "language",
          "custom",
        ],
      },
      {
        name: "template_style",
        type: "select",
        required: false,
        options: ["modern", "classic", "minimal", "colorful"],
      },
    ],
    autoSave: true,
  },

  schedule: {
    section: "schedule",
    requiredFields: ["start_date", "schedule_type"],
    jsonbField: "schedule_settings",
    fields: [
      { name: "start_date", type: "date", required: true },
      { name: "end_date", type: "date", required: false },
      {
        name: "schedule_type",
        type: "select",
        required: true,
        options: ["weekly", "bi-weekly", "daily", "custom"],
      },
      { name: "class_time", type: "time", required: false },
      { name: "class_duration", type: "number", required: false },
    ],
    autoSave: true,
  },

  curriculum: {
    section: "curriculum",
    requiredFields: ["curriculum_approach"],
    jsonbField: "curriculum_data",
    fields: [
      {
        name: "curriculum_approach",
        type: "select",
        required: true,
        options: ["modular", "linear", "spiral", "project-based"],
      },
      { name: "learning_objectives", type: "textarea", required: false },
      { name: "assessment_methods", type: "textarea", required: false },
      { name: "required_materials", type: "textarea", required: false },
    ],
    autoSave: true,
  },

  settings: {
    section: "settings",
    requiredFields: [],
    jsonbField: "course_settings",
    fields: [
      { name: "course_visible", type: "checkbox", required: false },
      { name: "allow_enrollment", type: "checkbox", required: false },
      { name: "require_approval", type: "checkbox", required: false },
    ],
    autoSave: true,
  },
};

// ==========================================================================
// HELPER FUNCTIONS
// ==========================================================================

export function getSectionConfig(sectionName: string): SectionConfig | null {
  return SECTION_CONFIGS[sectionName] || null;
}

export function getFieldConfig(
  sectionName: string,
  fieldName: string,
): FormFieldConfig | null {
  const sectionConfig = getSectionConfig(sectionName);
  if (!sectionConfig) return null;

  return sectionConfig.fields.find((field) => field.name === fieldName) || null;
}

export function getRequiredFields(sectionName: string): string[] {
  const sectionConfig = getSectionConfig(sectionName);
  return sectionConfig?.requiredFields || [];
}

export function isAutoSaveSection(sectionName: string): boolean {
  const sectionConfig = getSectionConfig(sectionName);
  return sectionConfig?.autoSave || false;
}
// ==========================================================================
// COURSE CLASSIFICATION & CRUD OPERATIONS
// ==========================================================================

import { supabase } from "../supabase";

// Course classification interface
export interface CourseClassificationData {
  class_year: string;
  curricular_framework: string;
  domain: string;
  subject: string;
  topic: string;
  subtopic?: string;
  previous_course?: string;
  current_course?: string;
  next_course?: string;
  // course_id will be provided when updating existing course
}

// Classification validation rules
export interface ClassificationValidation {
  class_year: boolean;
  curricular_framework: boolean;
  domain: boolean;
  subject: boolean;
  topic: boolean;
  subtopic: boolean;
  previous_course: boolean;
  current_course: boolean;
  next_course: boolean;
}

// ==========================================================================
// CLASSIFICATION DATA LOADERS
// ==========================================================================

let classYearData: any = null;
let curricularFrameworkData: any = null;
let iscedData: any = null;

export async function loadClassYearData() {
  if (!classYearData) {
    try {
      const response = await fetch(
        "/src/scripts/json/classification/classYear.json",
      );
      classYearData = await response.json();
    } catch (error) {
      console.error("Error loading class year data:", error);
      classYearData = { classYears: [] };
    }
  }
  return classYearData;
}

export async function loadCurricularFrameworkData() {
  if (!curricularFrameworkData) {
    try {
      const response = await fetch(
        "/src/scripts/json/classification/curricularFramework.json",
      );
      curricularFrameworkData = await response.json();
    } catch (error) {
      console.error("Error loading curricular framework data:", error);
      curricularFrameworkData = { curricularFrameworks: [] };
    }
  }
  return curricularFrameworkData;
}

export async function loadIscedData() {
  if (!iscedData) {
    try {
      const response = await fetch(
        "/src/scripts/json/classification/isced2011.json",
      );
      iscedData = await response.json();
    } catch (error) {
      console.error("Error loading ISCED data:", error);
      iscedData = { domains: [] };
    }
  }
  return iscedData;
}

// ==========================================================================
// CLASSIFICATION HELPERS
// ==========================================================================

export function getSubjectsByDomain(domainValue: string): any[] {
  if (!iscedData) return [];
  const domain = iscedData.domains.find((d: any) => d.value === domainValue);
  return domain ? domain.subjects : [];
}

export function getTopicsBySubject(
  domainValue: string,
  subjectValue: string,
): any[] {
  if (!iscedData) return [];
  const domain = iscedData.domains.find((d: any) => d.value === domainValue);
  if (!domain) return [];
  const subject = domain.subjects.find((s: any) => s.value === subjectValue);
  return subject ? subject.topics : [];
}

export function getSubtopicsByTopic(
  domainValue: string,
  subjectValue: string,
  topicValue: string,
): any[] {
  if (!iscedData) return [];
  const domain = iscedData.domains.find((d: any) => d.value === domainValue);
  if (!domain) return [];
  const subject = domain.subjects.find((s: any) => s.value === subjectValue);
  if (!subject) return [];
  const topic = subject.topics.find((t: any) => t.value === topicValue);
  return topic ? topic.subtopics || [] : [];
}

// ==========================================================================
// VALIDATION
// ==========================================================================

export function validateClassificationData(
  data: Partial<CourseClassificationData>,
): ClassificationValidation {
  return {
    class_year: Boolean(data.class_year && data.class_year.trim()),
    curricular_framework: Boolean(
      data.curricular_framework && data.curricular_framework.trim(),
    ),
    domain: Boolean(data.domain && data.domain.trim()),
    subject: Boolean(data.subject && data.subject.trim()),
    topic: Boolean(data.topic && data.topic.trim()),
    subtopic: true, // Optional field
    previous_course: true, // Optional field
    current_course: true, // Optional field
    next_course: true, // Optional field
  };
}

export function isValidClassification(
  validation: ClassificationValidation,
): boolean {
  // Only require the mandatory fields
  const requiredFields = [
    "class_year",
    "curricular_framework",
    "domain",
    "subject",
    "topic",
  ];

  return requiredFields.every(
    (field) => validation[field as keyof ClassificationValidation],
  );
}

// ==========================================================================
// COURSE CLASSIFICATION CRUD OPERATIONS
// ==========================================================================

export async function savePartialCourseClassification(
  courseId: string,
  data: Partial<CourseClassificationData>,
): Promise<{ success: boolean; error?: string }> {
  try {
    // Enhanced authentication check with session validation
    const {
      data: { session },
      error: sessionError,
    } = await supabase.auth.getSession();
    if (sessionError) {
      console.error("Session error:", sessionError);
      return { success: false, error: "Authentication session error" };
    }

    if (!session?.user) {
      console.error("No valid session or user found");
      return {
        success: false,
        error: "User not authenticated - please sign in again",
      };
    }

    const user = session.user;
      "Saving partial course classification for user:",
      user.id,
      "course:",
      courseId,
    );

    // Verify course ownership
    const { data: courseData, error: courseError } = await supabase
      .from("courses")
      .select("teacher_id")
      .eq("id", courseId)
      .single();

    if (courseError) {
      console.error("Error fetching course:", courseError);
      return { success: false, error: "Course not found" };
    }

    if (courseData.teacher_id !== user.id) {
      return {
        success: false,
        error: "Unauthorized - you can only modify your own courses",
      };
    }

    // Prepare classification data for JSONB column (allow partial data)
    const classificationData: any = {
      updated_at: new Date().toISOString(),
    };

    // Only include fields that have values
    if (data.class_year?.trim())
      classificationData.class_year = data.class_year.trim();
    if (data.curricular_framework?.trim())
      classificationData.curricular_framework =
        data.curricular_framework.trim();
    if (data.domain?.trim()) classificationData.domain = data.domain.trim();
    if (data.subject?.trim()) classificationData.subject = data.subject.trim();
    if (data.topic?.trim()) classificationData.topic = data.topic.trim();
    if (data.subtopic?.trim())
      classificationData.subtopic = data.subtopic.trim();
    if (data.previous_course?.trim())
      classificationData.previous_course = data.previous_course.trim();
    if (data.current_course?.trim())
      classificationData.current_course = data.current_course.trim();
    if (data.next_course?.trim())
      classificationData.next_course = data.next_course.trim();

      "Saving partial course classification data:",
      classificationData,
    );

    // Update course with classification data in the JSONB column
    const { error: updateError } = await supabase
      .from("courses")
      .update({
        classification_data: classificationData,
        updated_at: new Date().toISOString(),
      })
      .eq("id", courseId);

    if (updateError) {
      console.error("Error updating course classification:", updateError);
      return {
        success: false,
        error: `Failed to update classification: ${updateError.message}`,
      };
    }

    return { success: true };
  } catch (error) {
    console.error("Error in savePartialCourseClassification:", error);
    return { success: false, error: "Unexpected error occurred" };
  }
}

export async function updateCourseClassification(
  courseId: string,
  data: CourseClassificationData,
): Promise<{ success: boolean; error?: string }> {
  try {
    // Enhanced authentication check with session validation
    const {
      data: { session },
      error: sessionError,
    } = await supabase.auth.getSession();
    if (sessionError) {
      console.error("Session error:", sessionError);
      return { success: false, error: "Authentication session error" };
    }

    if (!session?.user) {
      console.error("No valid session or user found");
      return {
        success: false,
        error: "User not authenticated - please sign in again",
      };
    }

    const user = session.user;
      "Updating course classification for user:",
      user.id,
      "course:",
      courseId,
    );

    // Validate data
    const validation = validateClassificationData(data);
    if (!isValidClassification(validation)) {
      return {
        success: false,
        error: "Invalid classification data - required fields missing",
      };
    }

    // Verify course ownership
    const { data: courseData, error: courseError } = await supabase
      .from("courses")
      .select("teacher_id")
      .eq("id", courseId)
      .single();

    if (courseError) {
      console.error("Error fetching course:", courseError);
      return { success: false, error: "Course not found" };
    }

    if (courseData.teacher_id !== user.id) {
      return {
        success: false,
        error: "Unauthorized - you can only modify your own courses",
      };
    }

    // Prepare classification data for JSONB column
    const classificationData = {
      class_year: data.class_year.trim(),
      curricular_framework: data.curricular_framework.trim(),
      domain: data.domain.trim(),
      subject: data.subject.trim(),
      topic: data.topic.trim(),
      subtopic: data.subtopic?.trim() || null,
      previous_course: data.previous_course?.trim() || null,
      current_course: data.current_course?.trim() || null,
      next_course: data.next_course?.trim() || null,
      updated_at: new Date().toISOString(),
    };


    // Update course with classification data in the JSONB column
    const { error: updateError } = await supabase
      .from("courses")
      .update({
        classification_data: classificationData,
        updated_at: new Date().toISOString(),
      })
      .eq("id", courseId);

    if (updateError) {
      console.error("Error updating course classification:", updateError);
      return {
        success: false,
        error: `Failed to update classification: ${updateError.message}`,
      };
    }

    return { success: true };
  } catch (error) {
    console.error("Error in updateCourseClassification:", error);
    return { success: false, error: "Unexpected error occurred" };
  }
}

export async function getCourseClassification(
  courseId: string,
): Promise<CourseClassificationData | null> {
  try {
    const { data, error } = await supabase
      .from("courses")
      .select("classification_data")
      .eq("id", courseId)
      .single();

    if (error) {
      console.error("Error fetching course classification:", error);
      return null;
    }

    // Extract classification data from JSONB column
    const classificationData = data?.classification_data || {};

    // Return the classification data with proper structure
    return {
      class_year: classificationData.class_year || "",
      curricular_framework: classificationData.curricular_framework || "",
      domain: classificationData.domain || "",
      subject: classificationData.subject || "",
      topic: classificationData.topic || "",
      subtopic: classificationData.subtopic || undefined,
      previous_course: classificationData.previous_course || undefined,
      current_course: classificationData.current_course || undefined,
      next_course: classificationData.next_course || undefined,
    };
  } catch (error) {
    console.error("Error in getCourseClassification:", error);
    return null;
  }
}

export async function getAvailableCourses(
  userId?: string,
): Promise<Array<{ id: string; course_name: string }>> {
  try {
    let query = supabase
      .from("courses")
      .select("id, course_name")
      .order("course_name");

    if (userId) {
      query = query.eq("teacher_id", userId);
    } else {
      // Get current user's courses
      const {
        data: { user },
        error: authError,
      } = await supabase.auth.getUser();
      if (authError || !user) return [];
      query = query.eq("teacher_id", user.id);
    }

    const { data, error } = await query;

    if (error) {
      console.error("Error fetching available courses:", error);
      return [];
    }

    return data || [];
  } catch (error) {
    console.error("Error in getAvailableCourses:", error);
    return [];
  }
}

// ==========================================================================
// CLASSIFICATION FORM HELPERS
// ==========================================================================

export interface ClassificationFormState {
  selectedDomain: string;
  selectedSubject: string;
  selectedTopic: string;
  selectedSubtopic: string;
  availableSubjects: any[];
  availableTopics: any[];
  availableSubtopics: any[];
}

export function initializeClassificationFormState(): ClassificationFormState {
  return {
    selectedDomain: "",
    selectedSubject: "",
    selectedTopic: "",
    selectedSubtopic: "",
    availableSubjects: [],
    availableTopics: [],
    availableSubtopics: [],
  };
}

export function updateClassificationFormState(
  state: ClassificationFormState,
  field: keyof ClassificationFormState,
  value: string,
): ClassificationFormState {
  const newState = { ...state };

  switch (field) {
    case "selectedDomain":
      newState.selectedDomain = value;
      newState.selectedSubject = "";
      newState.selectedTopic = "";
      newState.selectedSubtopic = "";
      newState.availableSubjects = getSubjectsByDomain(value);
      newState.availableTopics = [];
      newState.availableSubtopics = [];
      break;

    case "selectedSubject":
      newState.selectedSubject = value;
      newState.selectedTopic = "";
      newState.selectedSubtopic = "";
      newState.availableTopics = getTopicsBySubject(
        state.selectedDomain,
        value,
      );
      newState.availableSubtopics = [];
      break;

    case "selectedTopic":
      newState.selectedTopic = value;
      newState.selectedSubtopic = "";
      newState.availableSubtopics = getSubtopicsByTopic(
        state.selectedDomain,
        state.selectedSubject,
        value,
      );
      break;

    case "selectedSubtopic":
      newState.selectedSubtopic = value;
      break;
  }

  return newState;
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

export async function initializeClassificationData(): Promise<void> {
  try {
    // Load all classification data in parallel
    await Promise.all([
      loadClassYearData(),
      loadCurricularFrameworkData(),
      loadIscedData(),
    ]);

  } catch (error) {
    console.error("Error initializing classification data:", error);
  }
}
// ==========================================================================
// CLASSIFICATION FORM HANDLER
// ==========================================================================

import {
  initializeClassificationData,
  loadClassYearData,
  loadCurricularFrameworkData,
  loadIscedData,
  getSubjectsByDomain,
  getSubtopicsByTopic,
  getAvailableCourses,
  savePartialCourseClassification,
  getCourseClassification,
  ClassificationFormState,
  initializeClassificationFormState,
  updateClassificationFormState,
  CourseClassificationData,
} from "./classifyCourse";

export class ClassificationFormHandler {
  private formState: ClassificationFormState;
  private currentCourseId: string | null = null;
  private autoSaveTimeout: NodeJS.Timeout | null = null;
  private lastSavedData: string = "";

  constructor() {
    this.formState = initializeClassificationFormState();
    this.initialize();
  }

  // ==========================================================================
  // INITIALIZATION
  // ==========================================================================

  private async initialize(): Promise<void> {

    try {
      // Get course ID from sessionStorage (set when course is created)
      this.currentCourseId = sessionStorage.getItem("currentCourseId");

      // Initialize classification data
      await initializeClassificationData();

      // Setup form event listeners
      this.setupFormHandlers();

      // Setup dropdown functionality
      this.setupDropdowns();

      // Populate static dropdowns
      await this.populateStaticDropdowns();

      // Load available courses for sequence dropdowns
      await this.populateAvailableCourses();

      // Load existing classification if course exists
      if (this.currentCourseId) {
        await this.loadExistingClassification(this.currentCourseId);
        this.updateSaveStatus("Loaded existing data");
      } else {
        this.updateSaveStatus("Waiting for course creation...");
      }

    } catch (error) {
      console.error("Error initializing Classification Form Handler:", error);
      this.updateSaveStatus("Error loading data", true);
    }
  }

  // ==========================================================================
  // DROPDOWN SETUP
  // ==========================================================================

  private setupDropdowns(): void {
    const dropdowns = [
      "class-year",
      "curricular-framework",
      "domain",
      "subject",
      "topic",
      "subtopic",
      "previous-course",
      "current-course",
      "next-course",
    ];

    dropdowns.forEach((dropdownId) => {
      this.setupSingleDropdown(dropdownId);
    });
  }

  private setupSingleDropdown(dropdownId: string): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    const menu = document.getElementById(`${dropdownId}-menu`);
    const hiddenInput = document.getElementById(
      `${dropdownId}-value`,
    ) as HTMLInputElement;

    if (!trigger || !menu || !hiddenInput) {
      console.warn(`Dropdown elements not found for: ${dropdownId}`);
      return;
    }

    // Toggle dropdown
    trigger.addEventListener("click", (e) => {
      e.preventDefault();
      this.toggleDropdown(dropdownId);
    });

    // Handle option selection
    menu.addEventListener("click", (e) => {
      const option = (e.target as HTMLElement).closest(
        ".dropdown__option",
      ) as HTMLElement;
      if (
        option &&
        !option.classList.contains("dropdown__option--disabled") &&
        !option.classList.contains("dropdown__option--header")
      ) {
        this.selectOption(dropdownId, option);
      }
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
      if (
        !trigger.contains(e.target as Node) &&
        !menu.contains(e.target as Node)
      ) {
        this.closeDropdown(dropdownId);
      }
    });
  }

  private toggleDropdown(dropdownId: string): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    const menu = document.getElementById(`${dropdownId}-menu`);

    if (!trigger || !menu) return;

    const isOpen = trigger.getAttribute("aria-expanded") === "true";

    // Close all other dropdowns first
    this.closeAllDropdowns();

    if (!isOpen) {
      trigger.setAttribute("aria-expanded", "true");
      trigger.classList.add("dropdown__trigger--open");
      menu.classList.add("dropdown__menu--open");

      const icon = trigger.querySelector(".dropdown__icon");
      if (icon) icon.classList.add("dropdown__icon--open");
    }
  }

  private closeDropdown(dropdownId: string): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    const menu = document.getElementById(`${dropdownId}-menu`);

    if (!trigger || !menu) return;

    trigger.setAttribute("aria-expanded", "false");
    trigger.classList.remove("dropdown__trigger--open");
    menu.classList.remove("dropdown__menu--open");

    const icon = trigger.querySelector(".dropdown__icon");
    if (icon) icon.classList.remove("dropdown__icon--open");
  }

  private closeAllDropdowns(): void {
    const triggers = document.querySelectorAll(".dropdown__trigger");
    triggers.forEach((trigger) => {
      const dropdownId = trigger.id.replace("-dropdown", "");
      this.closeDropdown(dropdownId);
    });
  }

  private selectOption(dropdownId: string, option: HTMLElement): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    const hiddenInput = document.getElementById(
      `${dropdownId}-value`,
    ) as HTMLInputElement;
    const label = trigger?.querySelector(".dropdown__label");

    if (!trigger || !hiddenInput || !label) return;

    const value = option.dataset.value || "";
    const text = option.textContent?.trim() || "";

    // Update UI
    hiddenInput.value = value;
    label.textContent = text;
    label.classList.remove("dropdown__label--placeholder");

    // Handle cascading updates for ISCED hierarchy
    this.handleCascadingUpdates(dropdownId, value);

    // Close dropdown
    this.closeDropdown(dropdownId);

    // Mark as success
    trigger.classList.add("dropdown__trigger--success");

    // Trigger auto-save
    this.triggerAutoSave();

  }

  // ==========================================================================
  // CASCADING UPDATES
  // ==========================================================================

  private handleCascadingUpdates(dropdownId: string, value: string): void {
    switch (dropdownId) {
      case "domain":
        this.formState = updateClassificationFormState(
          this.formState,
          "selectedDomain",
          value,
        );
        // Reset dependent dropdowns first
        this.resetDropdown("topic");
        this.resetDropdown("subtopic");
        // Then populate the immediate next dropdown
        this.populateSubjectDropdown();
        break;

      case "subject":
        this.formState = updateClassificationFormState(
          this.formState,
          "selectedSubject",
          value,
        );
        // Reset dependent dropdowns first
        this.resetDropdown("subtopic");
        // Then populate the immediate next dropdown
        this.populateTopicDropdown();
        break;

      case "topic":
        this.formState = updateClassificationFormState(
          this.formState,
          "selectedTopic",
          value,
        );
        // Then populate the immediate next dropdown
        this.populateSubtopicDropdown();
        break;
    }
  }

  private resetDropdown(dropdownId: string): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    const menu = document.getElementById(`${dropdownId}-menu`);
    const hiddenInput = document.getElementById(
      `${dropdownId}-value`,
    ) as HTMLInputElement;
    const label = trigger?.querySelector(".dropdown__label");

    if (!trigger || !menu || !hiddenInput || !label) return;

    // Reset values
    hiddenInput.value = "";
    label.classList.add("dropdown__label--placeholder");

    // Clear menu
    menu.innerHTML = "";

    // Disable trigger
    trigger.classList.add("dropdown__trigger--disabled");
    trigger.setAttribute("disabled", "true");

    // Update placeholder text
    switch (dropdownId) {
      case "subject":
        label.textContent = "Select domain first...";
        break;
      case "topic":
        label.textContent = "Select subject first...";
        break;
      case "subtopic":
        label.textContent = "Select topic first...";
        break;
      default:
        label.textContent = `Select ${dropdownId.replace("-", " ")}...`;
    }

    // Remove success styling
    trigger.classList.remove("dropdown__trigger--success");
  }

  // ==========================================================================
  // DROPDOWN POPULATION
  // ==========================================================================

  private async populateStaticDropdowns(): Promise<void> {
    await Promise.all([
      this.populateClassYearDropdown(),
      this.populateCurricularFrameworkDropdown(),
      this.populateDomainDropdown(),
    ]);
  }

  private async populateClassYearDropdown(): Promise<void> {
    try {
      const data = await loadClassYearData();
      const menu = document.getElementById("class-year-menu");

      if (!menu || !data.classYears) return;

      menu.innerHTML = data.classYears
        .map(
          (year: any) => `
        <div class="dropdown__option" data-value="${year.value}" role="option">
          <div class="dropdown__option-text">
            ${year.label}
            ${year.description ? `<div class="dropdown__option-description">${year.description}</div>` : ""}
          </div>
        </div>
      `,
        )
        .join("");

      // Enable dropdown
      this.enableDropdown("class-year");
    } catch (error) {
      console.error("Error populating class year dropdown:", error);
    }
  }

  private async populateCurricularFrameworkDropdown(): Promise<void> {
    try {
      const data = await loadCurricularFrameworkData();
      const menu = document.getElementById("curricular-framework-menu");

      if (!menu || !data.curricularFrameworks) return;

      menu.innerHTML = data.curricularFrameworks
        .map(
          (framework: any) => `
        <div class="dropdown__option" data-value="${framework.value}" role="option">
          <div class="dropdown__option-text">
            ${framework.label}
            ${framework.description ? `<div class="dropdown__option-description">${framework.description}</div>` : ""}
          </div>
        </div>
      `,
        )
        .join("");

      // Enable dropdown
      this.enableDropdown("curricular-framework");
    } catch (error) {
      console.error("Error populating curricular framework dropdown:", error);
    }
  }

  private async populateDomainDropdown(): Promise<void> {
    try {
      const data = await loadIscedData();
      const menu = document.getElementById("domain-menu");

      if (!menu || !data.domains) return;

      menu.innerHTML = data.domains
        .map(
          (domain: any) => `
        <div class="dropdown__option" data-value="${domain.value}" role="option">
          <div class="dropdown__option-text">
            ${domain.label}
            <div class="dropdown__option-code">${domain.code}</div>
          </div>
        </div>
      `,
        )
        .join("");

      // Enable dropdown
      this.enableDropdown("domain");
    } catch (error) {
      console.error("Error populating domain dropdown:", error);
    }
  }

  private populateSubjectDropdown(): void {
    const subjects = this.formState.availableSubjects;
    const menu = document.getElementById("subject-menu");

    if (!menu) return;

    if (subjects.length === 0) {
      menu.innerHTML =
        '<div class="dropdown__option dropdown__option--disabled">No subjects available</div>';
      return;
    }

    menu.innerHTML = subjects
      .map(
        (subject: any) => `
      <div class="dropdown__option" data-value="${subject.value}" role="option">
        <div class="dropdown__option-text">
          ${subject.label}
          <div class="dropdown__option-code">${subject.code}</div>
        </div>
      </div>
    `,
      )
      .join("");

    // Enable dropdown
    this.enableDropdown("subject");
  }

  private populateTopicDropdown(): void {
    const topics = this.formState.availableTopics;
    const menu = document.getElementById("topic-menu");

    if (!menu) return;

    if (topics.length === 0) {
      menu.innerHTML =
        '<div class="dropdown__option dropdown__option--disabled">No topics available</div>';
      return;
    }

    menu.innerHTML = topics
      .map(
        (topic: any) => `
      <div class="dropdown__option" data-value="${topic.value}" role="option">
        <div class="dropdown__option-text">
          ${topic.label}
          <div class="dropdown__option-code">${topic.code}</div>
        </div>
      </div>
    `,
      )
      .join("");

    // Enable dropdown
    this.enableDropdown("topic");
  }

  private populateSubtopicDropdown(): void {
    const subtopics = this.formState.availableSubtopics;
    const menu = document.getElementById("subtopic-menu");

    if (!menu) return;

    if (subtopics.length === 0) {
      menu.innerHTML =
        '<div class="dropdown__option dropdown__option--disabled">No subtopics available</div>';
      return;
    }

    menu.innerHTML = subtopics
      .map(
        (subtopic: any) => `
      <div class="dropdown__option" data-value="${subtopic.value}" role="option">
        <div class="dropdown__option-text">
          ${subtopic.label}
          <div class="dropdown__option-code">${subtopic.code}</div>
        </div>
      </div>
    `,
      )
      .join("");

    // Enable dropdown
    this.enableDropdown("subtopic");
  }

  private async populateAvailableCourses(): Promise<void> {
    try {
      const courses = await getAvailableCourses();
      const courseDropdowns = [
        "previous-course",
        "current-course",
        "next-course",
      ];

      courseDropdowns.forEach((dropdownId) => {
        const menu = document.getElementById(`${dropdownId}-menu`);
        if (!menu) return;

        const coursesHtml = courses
          .map(
            (course) => `
          <div class="dropdown__option" data-value="${course.id}" role="option">
            <div class="dropdown__option-text">${course.course_name}</div>
          </div>
        `,
          )
          .join("");

        // Keep the header and add courses
        const existingHeader = menu.querySelector(".dropdown__option--header");
        if (existingHeader) {
          menu.innerHTML = existingHeader.outerHTML + coursesHtml;
        } else {
          menu.innerHTML = coursesHtml;
        }

        // Enable dropdown
        this.enableDropdown(dropdownId);
      });
    } catch (error) {
      console.error("Error populating available courses:", error);
    }
  }

  private enableDropdown(dropdownId: string): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    if (!trigger) return;

    trigger.classList.remove("dropdown__trigger--disabled");
    trigger.removeAttribute("disabled");

    // Update placeholder if needed
    const label = trigger.querySelector(".dropdown__label");
    if (label && label.classList.contains("dropdown__label--placeholder")) {
      switch (dropdownId) {
        case "subject":
          label.textContent = "Select subject...";
          break;
        case "topic":
          label.textContent = "Select topic...";
          break;
        case "subtopic":
          label.textContent = "Select subtopic...";
          break;
      }
    }
  }

  // ==========================================================================
  // FORM HANDLING & AUTO-SAVE
  // ==========================================================================

  private setupFormHandlers(): void {
    // No more manual form submission - everything is auto-saved
    // Just listen for course ID updates from sessionStorage
    this.watchForCourseId();
  }

  private watchForCourseId(): void {
    // Check for course ID periodically in case it's set after initialization
    const checkInterval = setInterval(() => {
      const courseId = sessionStorage.getItem("currentCourseId");
      if (courseId && courseId !== this.currentCourseId) {
        this.currentCourseId = courseId;
        this.updateSaveStatus("Course connected - auto-save enabled");
        clearInterval(checkInterval);
      }
    }, 500);

    // Stop checking after 30 seconds to prevent infinite checking
    setTimeout(() => clearInterval(checkInterval), 30000);
  }

  private triggerAutoSave(): void {
    // Clear existing timeout
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout);
    }

    // Set new timeout for auto-save (debounced)
    this.autoSaveTimeout = setTimeout(() => {
      this.performAutoSave();
    }, 1000); // Save 1 second after last change

    this.updateSaveStatus("Saving...");
  }

  private async performAutoSave(): Promise<void> {
    if (!this.currentCourseId) {
      this.updateSaveStatus("Waiting for course creation...", true);
      return;
    }

    try {
      const classificationData = this.getCurrentFormData();

      // Check if data has actually changed
      const currentDataString = JSON.stringify(classificationData);
      if (currentDataString === this.lastSavedData) {
        return; // No changes to save
      }

      // Use partial save for auto-save (doesn't require all fields to be filled)
      const result = await savePartialCourseClassification(
        this.currentCourseId,
        classificationData,
      );

      if (result.success) {
        this.lastSavedData = currentDataString;
        const now = new Date();
        const timeString = now.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });
        this.updateSaveStatus(`Last saved at ${timeString}`);
      } else {
        throw new Error(result.error || "Failed to save classification");
      }
    } catch (error) {
      console.error("Error in auto-save:", error);
      this.updateSaveStatus("Save failed - will retry", true);

      // Retry after 3 seconds
      setTimeout(() => {
        this.triggerAutoSave();
      }, 3000);
    }
  }

  private getCurrentFormData(): CourseClassificationData {
    const form = document.getElementById(
      "course-classification-form",
    ) as HTMLFormElement;
    if (!form) throw new Error("Classification form not found");

    const formData = new FormData(form);
    return {
      class_year: (formData.get("class_year") as string) || "",
      curricular_framework:
        (formData.get("curricular_framework") as string) || "",
      domain: (formData.get("domain") as string) || "",
      subject: (formData.get("subject") as string) || "",
      topic: (formData.get("topic") as string) || "",
      subtopic: (formData.get("subtopic") as string) || undefined,
      previous_course: (formData.get("previous_course") as string) || undefined,
      current_course: (formData.get("current_course") as string) || undefined,
      next_course: (formData.get("next_course") as string) || undefined,
    };
  }

  private updateSaveStatus(message: string, isError: boolean = false): void {
    const statusElement = document.getElementById("classification-save-status");
    if (!statusElement) return;

    statusElement.textContent = message;

    // Update styling based on status
    const indicator = document.getElementById("classification-last-saved");
    if (indicator) {
      indicator.className = `save-indicator ${isError ? "save-indicator--error" : "save-indicator--success"}`;
    }
  }

  // ==========================================================================
  // UTILITY METHODS
  // ==========================================================================

  public setCourseId(courseId: string): void {
    this.currentCourseId = courseId;
    sessionStorage.setItem("currentCourseId", courseId);
    this.updateSaveStatus("Course connected - auto-save enabled");
  }

  public async loadExistingClassification(courseId: string): Promise<void> {
    try {
      const classification = await getCourseClassification(courseId);
      if (classification) {
        this.populateFormWithData(classification);
        this.lastSavedData = JSON.stringify(classification);
        this.updateSaveStatus("Loaded existing data");
      }
    } catch (error) {
      console.error("Error loading existing classification:", error);
      this.updateSaveStatus("Error loading existing data", true);
    }
  }

  private populateFormWithData(data: CourseClassificationData): void {
    // Update form state
    this.formState.selectedDomain = data.domain || "";
    this.formState.selectedSubject = data.subject || "";
    this.formState.selectedTopic = data.topic || "";
    this.formState.selectedSubtopic = data.subtopic || "";

    // Populate dropdowns with cascade
    if (data.domain) {
      this.setDropdownValue("domain", data.domain);
      this.formState = updateClassificationFormState(
        this.formState,
        "selectedDomain",
        data.domain,
      );
      this.populateSubjectDropdown();

      if (data.subject) {
        this.setDropdownValue("subject", data.subject);
        this.formState = updateClassificationFormState(
          this.formState,
          "selectedSubject",
          data.subject,
        );
        this.populateTopicDropdown();

        if (data.topic) {
          this.setDropdownValue("topic", data.topic);
          this.formState = updateClassificationFormState(
            this.formState,
            "selectedTopic",
            data.topic,
          );
          this.populateSubtopicDropdown();

          if (data.subtopic) {
            this.setDropdownValue("subtopic", data.subtopic);
          }
        }
      }
    }

    // Set other dropdowns
    if (data.class_year) this.setDropdownValue("class-year", data.class_year);
    if (data.curricular_framework)
      this.setDropdownValue("curricular-framework", data.curricular_framework);
    if (data.previous_course)
      this.setDropdownValue("previous-course", data.previous_course);
    if (data.current_course)
      this.setDropdownValue("current-course", data.current_course);
    if (data.next_course)
      this.setDropdownValue("next-course", data.next_course);
  }

  private setDropdownValue(dropdownId: string, value: string): void {
    const trigger = document.getElementById(`${dropdownId}-dropdown`);
    const hiddenInput = document.getElementById(
      `${dropdownId}-value`,
    ) as HTMLInputElement;
    const label = trigger?.querySelector(".dropdown__label");

    if (!trigger || !hiddenInput || !label) return;

    hiddenInput.value = value;

    // Find the option with this value to get the display text
    const menu = document.getElementById(`${dropdownId}-menu`);
    const option = menu?.querySelector(`[data-value="${value}"]`);
    if (option) {
      label.textContent = option.textContent?.trim() || value;
      label.classList.remove("dropdown__label--placeholder");
      trigger.classList.add("dropdown__trigger--success");
      this.enableDropdown(dropdownId);
    }
  }
}

// ==========================================================================
// AUTO-INITIALIZATION
// ==========================================================================

// Initialize when DOM is ready - but only on the classification section
document.addEventListener("DOMContentLoaded", () => {
  if (document.getElementById("course-classification-form")) {
    new ClassificationFormHandler();
  }
});
import { supabase } from "../../backend/supabase.js";

interface ScheduleSession {
  lessonNumber: number;
  day: string;
  date: string;
  startTime: string;
  endTime: string;
}

interface ScheduleConfig {
  startDate: string;
  endDate: string;
  selectedDays: string[];
  startTime: string;
  endTime: string;
}

export class ScheduleCourseManager {
  private courseId: string;
  private scheduleConfigSection!: HTMLElement;
  private schedulePreviewSection!: HTMLElement;
  private scheduleButton!: HTMLButtonElement;
  private deleteScheduleButton!: HTMLButtonElement;
  private currentSchedule: ScheduleSession[] = [];

  constructor(courseId?: string) {
    // Get course ID from parameter or session storage
    this.courseId = courseId || sessionStorage.getItem("currentCourseId") || "";

    if (!this.courseId) {
      console.error("No course ID available for schedule management");
      return;
    }

    this.initializeElements();
    this.bindEvents();
    this.loadExistingSchedule();

    // Run initial validation to set proper button state
    this.validateScheduleForm();
  }

  private initializeElements(): void {
    this.scheduleConfigSection = document.getElementById(
      "schedule-config",
    ) as HTMLElement;
    this.schedulePreviewSection = document.getElementById(
      "schedule-preview",
    ) as HTMLElement;
    this.scheduleButton = document.getElementById(
      "schedule-course-btn",
    ) as HTMLButtonElement;
    this.deleteScheduleButton = document.getElementById(
      "delete-schedule-btn",
    ) as HTMLButtonElement;

    // Check if all elements were found
    if (!this.scheduleConfigSection) {
      console.error("schedule-config element not found");
      return;
    }
    if (!this.schedulePreviewSection) {
      console.error("schedule-preview element not found");
      return;
    }
    if (!this.scheduleButton) {
      console.error("schedule-course-btn element not found");
      return;
    }
    if (!this.deleteScheduleButton) {
      console.error("delete-schedule-btn element not found");
      return;
    }

  }

  private bindEvents(): void {
    if (
      !this.scheduleConfigSection ||
      !this.scheduleButton ||
      !this.deleteScheduleButton
    ) {
      console.error("Cannot bind events: required elements not found");
      return;
    }

    // Form input validation
    this.scheduleConfigSection.addEventListener("input", () =>
      this.validateScheduleForm(),
    );
    this.scheduleConfigSection.addEventListener("change", () =>
      this.validateScheduleForm(),
    );

    // Day selection buttons
    const dayButtons =
      this.scheduleConfigSection.querySelectorAll(".day-button");
    dayButtons.forEach((button) => {
      button.addEventListener("click", (e) =>
        this.toggleDaySelection(e.target as HTMLButtonElement),
      );
    });

    // Schedule generation
    this.scheduleButton.addEventListener("click", (e) => {
      this.generateSchedule();
    });

    // Delete schedule
    this.deleteScheduleButton.addEventListener("click", (e) => {
      this.deleteSchedule();
    });

  }

  private validateScheduleForm(): void {
    const startDate = (
      document.getElementById("start-date") as HTMLInputElement
    )?.value;
    const endDate = (document.getElementById("end-date") as HTMLInputElement)
      ?.value;
    const startTime = (
      document.getElementById("start-time") as HTMLInputElement
    )?.value;
    const endTime = (document.getElementById("end-time") as HTMLInputElement)
      ?.value;
    const selectedDays = this.getSelectedDays();

    const isValid =
      startDate && endDate && startTime && endTime && selectedDays.length > 0;

    if (isValid) {
      this.scheduleButton.classList.add("active");
      this.scheduleButton.classList.remove("button--disabled");
      this.scheduleButton.disabled = false;
    } else {
      this.scheduleButton.classList.remove("active");
      this.scheduleButton.classList.add("button--disabled");
      this.scheduleButton.disabled = true;
    }
  }

  private toggleDaySelection(button: HTMLButtonElement): void {
    button.classList.toggle("selected");
    this.validateScheduleForm();
  }

  private getSelectedDays(): string[] {
    const selectedButtons = this.scheduleConfigSection.querySelectorAll(
      ".day-button.selected",
    );
    return Array.from(selectedButtons).map(
      (btn) => (btn as HTMLElement).dataset.day || "",
    );
  }

  private getScheduleConfig(): ScheduleConfig {
    return {
      startDate: (document.getElementById("start-date") as HTMLInputElement)
        .value,
      endDate: (document.getElementById("end-date") as HTMLInputElement).value,
      selectedDays: this.getSelectedDays(),
      startTime: (document.getElementById("start-time") as HTMLInputElement)
        .value,
      endTime: (document.getElementById("end-time") as HTMLInputElement).value,
    };
  }

  private async generateSchedule(): Promise<void> {

    const config = this.getScheduleConfig();

    const sessions = this.calculateScheduleSessions(config);

    try {
      await this.saveScheduleToDatabase(sessions);
      this.currentSchedule = sessions;
      this.renderSchedulePreview();
      this.lockScheduleConfig();
      this.showDeleteScheduleButton();
    } catch (error) {
      console.error("Error generating schedule:", error);
      alert("Failed to generate schedule. Please try again.");
    }
  }

  private calculateScheduleSessions(config: ScheduleConfig): ScheduleSession[] {
    const sessions: ScheduleSession[] = [];
    const startDate = new Date(config.startDate);
    const endDate = new Date(config.endDate);

    let lessonNumber = 1;
    const currentDate = new Date(startDate);

    while (currentDate <= endDate) {
      const dayName = currentDate
        .toLocaleDateString("en-US", { weekday: "long" })
        .toLowerCase();

      if (config.selectedDays.includes(dayName)) {
        sessions.push({
          lessonNumber: lessonNumber++,
          day: dayName,
          date: currentDate.toISOString().split("T")[0],
          startTime: config.startTime,
          endTime: config.endTime,
        });
      }

      currentDate.setDate(currentDate.getDate() + 1);
    }

    return sessions;
  }

  private async saveScheduleToDatabase(
    sessions: ScheduleSession[],
  ): Promise<void> {
    const { error } = await supabase
      .from("courses")
      .update({
        schedule_settings: sessions,
        course_days: sessions.length,
      })
      .eq("id", this.courseId);

    if (error) {
      throw error;
    }
  }

  private renderSchedulePreview(): void {
    const previewContainer =
      this.schedulePreviewSection.querySelector(".schedule-list");
    if (!previewContainer) return;

    previewContainer.innerHTML = "";

    // Safety check: ensure currentSchedule is an array
    if (!Array.isArray(this.currentSchedule)) {
      console.warn("currentSchedule is not an array:", this.currentSchedule);
      this.currentSchedule = [];
      return;
    }

    this.currentSchedule.forEach((session, index) => {
      const row = this.createScheduleRow(session, index);
      previewContainer.appendChild(row);
    });

    this.updateTotalLessonsDisplay();
    this.schedulePreviewSection.classList.remove("hidden");
  }

  private createScheduleRow(
    session: ScheduleSession,
    index: number,
  ): HTMLElement {
    const row = document.createElement("div");
    row.className = "schedule-row";
    row.innerHTML = `
            <span class="lesson-number">${session.lessonNumber}</span>
            <span class="lesson-day">${this.formatDay(session.day)}</span>
            <input type="time" class="lesson-start-time" value="${session.startTime}" data-index="${index}">
            <input type="time" class="lesson-end-time" value="${session.endTime}" data-index="${index}">
            <button class="delete-lesson-btn" data-index="${index}">√ó</button>
        `;

    // Bind events for time editing
    const startTimeInput = row.querySelector(
      ".lesson-start-time",
    ) as HTMLInputElement;
    const endTimeInput = row.querySelector(
      ".lesson-end-time",
    ) as HTMLInputElement;
    const deleteButton = row.querySelector(
      ".delete-lesson-btn",
    ) as HTMLButtonElement;

    startTimeInput.addEventListener("change", (e) =>
      this.updateLessonTime(
        index,
        "startTime",
        (e.target as HTMLInputElement).value,
      ),
    );
    endTimeInput.addEventListener("change", (e) =>
      this.updateLessonTime(
        index,
        "endTime",
        (e.target as HTMLInputElement).value,
      ),
    );
    deleteButton.addEventListener("click", () => this.deleteLessonRow(index));

    return row;
  }

  private async updateLessonTime(
    index: number,
    timeType: "startTime" | "endTime",
    newTime: string,
  ): Promise<void> {
    this.currentSchedule[index][timeType] = newTime;

    try {
      await this.saveScheduleToDatabase(this.currentSchedule);
    } catch (error) {
      console.error("Error updating lesson time:", error);
    }
  }

  private async deleteLessonRow(index: number): Promise<void> {
    if (!confirm("Are you sure you want to delete this lesson?")) {
      return;
    }

    this.currentSchedule.splice(index, 1);

    // Renumber lessons
    this.currentSchedule.forEach((session, i) => {
      session.lessonNumber = i + 1;
    });

    try {
      await this.saveScheduleToDatabase(this.currentSchedule);
      this.renderSchedulePreview();
    } catch (error) {
      console.error("Error deleting lesson:", error);
    }
  }

  private async deleteSchedule(): Promise<void> {
    if (!confirm("Are you sure you want to delete the entire schedule?")) {
      return;
    }

    try {
      await supabase
        .from("courses")
        .update({
          schedule_settings: null,
          course_days: null,
        })
        .eq("id", this.courseId);

      this.currentSchedule = [];
      this.unlockScheduleConfig();
      this.hideSchedulePreview();
      this.hideDeleteScheduleButton();
    } catch (error) {
      console.error("Error deleting schedule:", error);
    }
  }

  private async loadExistingSchedule(): Promise<void> {
    try {
      const { data, error } = await supabase
        .from("courses")
        .select("schedule_settings, course_days")
        .eq("id", this.courseId)
        .single();

      if (error) throw error;

      if (data?.schedule_settings && Array.isArray(data.schedule_settings)) {
        this.currentSchedule = data.schedule_settings;
        this.renderSchedulePreview();
        this.lockScheduleConfig();
        this.showDeleteScheduleButton();
      } else {
        // No existing schedule or invalid data - ensure currentSchedule is empty array
        this.currentSchedule = [];
        this.hideSchedulePreview();
        this.unlockScheduleConfig();
        this.hideDeleteScheduleButton();
      }
    } catch (error) {
      console.error("Error loading existing schedule:", error);
      // Ensure currentSchedule is always an array even on error
      this.currentSchedule = [];
      this.hideSchedulePreview();
      this.unlockScheduleConfig();
      this.hideDeleteScheduleButton();
    }
  }

  private lockScheduleConfig(): void {
    const inputs = this.scheduleConfigSection.querySelectorAll(
      "input, button:not(#delete-schedule-btn)",
    );
    inputs.forEach((input) => {
      (input as HTMLInputElement | HTMLButtonElement).disabled = true;
    });
    this.scheduleConfigSection.classList.add("locked");
  }

  private unlockScheduleConfig(): void {
    const inputs = this.scheduleConfigSection.querySelectorAll("input, button");
    inputs.forEach((input) => {
      (input as HTMLInputElement | HTMLButtonElement).disabled = false;
    });
    this.scheduleConfigSection.classList.remove("locked");
    this.validateScheduleForm();
  }

  private showDeleteScheduleButton(): void {
    this.deleteScheduleButton.classList.remove("hidden");
    this.deleteScheduleButton.disabled = false;
    this.deleteScheduleButton.style.pointerEvents = "auto";
  }

  private hideDeleteScheduleButton(): void {
    this.deleteScheduleButton.classList.add("hidden");
  }

  private hideSchedulePreview(): void {
    this.schedulePreviewSection.classList.add("hidden");
  }

  private updateTotalLessonsDisplay(): void {
    const totalDisplay =
      this.schedulePreviewSection.querySelector(".total-lessons");
    if (totalDisplay) {
      totalDisplay.textContent = `Total lessons: ${this.currentSchedule.length}`;
    }
  }

  private formatDay(day: string): string {
    return day.charAt(0).toUpperCase() + day.slice(1);
  }
}

// Make ScheduleCourseManager available globally for testing/debugging
declare global {
  interface Window {
    ScheduleCourseManager: typeof ScheduleCourseManager;
  }
}

if (typeof window !== "undefined") {
  window.ScheduleCourseManager = ScheduleCourseManager;
}
/**
 * Margin Settings Handler
 * Handles margin settings UI and database persistence for course canvas
 */

import { supabase } from "../../backend/supabase";

export interface MarginSettings {
  top: number;
  bottom: number;
  left: number;
  right: number;
  unit: "inches" | "centimeters";
}

export class MarginSettingsHandler {
  private courseId: string | null = null;
  private currentSettings: MarginSettings;
  private saveTimeout: NodeJS.Timeout | null = null;
  private courseBuilder: any = null; // Will be set when course builder is available

  constructor() {
    // Default values in centimeters
    this.currentSettings = {
      top: 2.54,
      bottom: 2.54,
      left: 2.54,
      right: 2.54,
      unit: "centimeters",
    };

    // Load from local storage if available
    this.init();
  }

  private init(): void {
    this.bindEvents();
    this.updateUnitDisplays();
    this.updateInputValues(); // Ensure UI shows default values
      "üìè Margin Settings Handler initialized with defaults:",
      this.currentSettings,
    );
  }

  private bindEvents(): void {
    // Unit toggle events
    const unitInputs = document.querySelectorAll('input[name="margin-unit"]');
    unitInputs.forEach((input) => {
      input.addEventListener("change", (e) => this.handleUnitChange(e));
    });

    // Margin input events
    const marginInputs = document.querySelectorAll(".margin-input");
    marginInputs.forEach((input) => {
      input.addEventListener("input", (e) => this.handleMarginChange(e));
      input.addEventListener("change", (e) => this.handleMarginChange(e)); // For when user leaves field
    });
  }

  private handleUnitChange(event: Event): void {
    const input = event.target as HTMLInputElement;
    const newUnit = input.value as "inches" | "centimeters";


    // Convert current values to new unit
    if (newUnit !== this.currentSettings.unit) {
      this.convertMarginUnits(this.currentSettings.unit, newUnit);
      this.currentSettings.unit = newUnit;
      this.updateInputValues();
      this.updateUnitDisplays();
      this.saveSettingsToDatabase();
      this.updateCanvasMargins();
    }
  }

  private handleMarginChange(event: Event): void {
    const input = event.target as HTMLInputElement;
    const marginType = input.name.replace("margin_", "") as keyof Omit<
      MarginSettings,
      "unit"
    >;
    const value = parseFloat(input.value) || 0;

      `üìè Margin ${marginType} changed to: ${value} ${this.currentSettings.unit}`,
    );

    // Update current settings
    this.currentSettings[marginType] = value;

    // Show saving status
    this.showSaveStatus("saving");

    // Debounce saving to database
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }

    this.saveTimeout = setTimeout(() => {
      this.saveSettingsToDatabase();
      this.updateCanvasMargins();
    }, 500); // Save after 500ms of no changes
  }

  private convertMarginUnits(
    fromUnit: "inches" | "centimeters",
    toUnit: "inches" | "centimeters",
  ): void {
    if (fromUnit === toUnit) return;

    const conversionFactor = fromUnit === "inches" ? 2.54 : 1 / 2.54; // inches to cm or cm to inches

    this.currentSettings.top = parseFloat(
      (this.currentSettings.top * conversionFactor).toFixed(2),
    );
    this.currentSettings.bottom = parseFloat(
      (this.currentSettings.bottom * conversionFactor).toFixed(2),
    );
    this.currentSettings.left = parseFloat(
      (this.currentSettings.left * conversionFactor).toFixed(2),
    );
    this.currentSettings.right = parseFloat(
      (this.currentSettings.right * conversionFactor).toFixed(2),
    );

      `üìè Converted margins from ${fromUnit} to ${toUnit}:`,
      this.currentSettings,
    );
  }

  private updateInputValues(): void {
    const topInput = document.getElementById("margin-top") as HTMLInputElement;
    const bottomInput = document.getElementById(
      "margin-bottom",
    ) as HTMLInputElement;
    const leftInput = document.getElementById(
      "margin-left",
    ) as HTMLInputElement;
    const rightInput = document.getElementById(
      "margin-right",
    ) as HTMLInputElement;

    if (topInput) topInput.value = this.currentSettings.top.toString();
    if (bottomInput) bottomInput.value = this.currentSettings.bottom.toString();
    if (leftInput) leftInput.value = this.currentSettings.left.toString();
    if (rightInput) rightInput.value = this.currentSettings.right.toString();
  }

  private updateUnitDisplays(): void {
    const unitDisplays = document.querySelectorAll(".margin-unit-display");
    const displayUnit = this.currentSettings.unit === "inches" ? "in" : "cm";

    unitDisplays.forEach((display) => {
      display.textContent = displayUnit;
    });
  }

  private async saveSettingsToDatabase(): Promise<void> {
    if (!this.courseId) {
      console.error(
        "üìè ERROR: No course ID available, cannot save margin settings",
      );
      return;
    }

    try {
        "üìè Saving margin settings to database...",
        this.currentSettings,
      );

      // Get current course settings
      const { data: course, error: fetchError } = await supabase
        .from("courses")
        .select("course_settings")
        .eq("id", this.courseId)
        .single();

      if (fetchError) {
        throw fetchError;
      }

      // Merge with existing settings
      const existingSettings = course?.course_settings || {};
      const updatedSettings = {
        ...existingSettings,
        margins: this.currentSettings,
      };

      // Save to database
      const { error } = await supabase
        .from("courses")
        .update({ course_settings: updatedSettings })
        .eq("id", this.courseId);

      if (error) {
        throw error;
      }

      this.showSaveStatus("saved");
    } catch (error) {
      console.error("üìè Failed to save margin settings:", error);
      this.showSaveStatus("error");
    }
  }

  private showSaveStatus(status: "saving" | "saved" | "error"): void {
    const statusElement = document.querySelector(
      "#margins-save-status .save-indicator__text",
    ) as HTMLElement;
    if (!statusElement) return;

    // Remove existing status classes
    statusElement.classList.remove("saved", "saving", "error");

    switch (status) {
      case "saving":
        statusElement.textContent = "Saving margins...";
        statusElement.classList.add("saving");
        break;
      case "saved":
        statusElement.textContent = "Margins saved successfully";
        statusElement.classList.add("saved");
        // Reset to default message after 3 seconds
        setTimeout(() => {
          statusElement.textContent = "Margins will be saved automatically";
          statusElement.classList.remove("saved");
        }, 3000);
        break;
      case "error":
        statusElement.textContent = "Failed to save margins";
        statusElement.classList.add("error");
        // Reset to default message after 5 seconds
        setTimeout(() => {
          statusElement.textContent = "Margins will be saved automatically";
          statusElement.classList.remove("error");
        }, 5000);
        break;
    }
  }

  public async loadSettingsFromDatabase(courseId: string): Promise<void> {
    this.courseId = courseId;

    try {

      const { data: course, error } = await supabase
        .from("courses")
        .select("course_settings")
        .eq("id", courseId)
        .single();

      if (error) {
        console.error("üìè Error loading course settings:", error);
        // Use defaults if loading fails
        this.updateInputValues();
        this.updateUnitDisplays();
        this.updateCanvasMargins();
        return;
      }

      if (course?.course_settings?.margins) {
        const margins = course.course_settings.margins;
        this.currentSettings = { ...this.currentSettings, ...margins };
          "üìè Loaded margin settings from database:",
          this.currentSettings,
        );
      } else {
      }

      // Update UI and canvas
      this.updateInputValues();
      this.updateUnitDisplays();
      this.updateCanvasMargins();
    } catch (error) {
      console.error("üìè Error loading margin settings:", error);
      // Use defaults if loading fails
      this.updateInputValues();
      this.updateUnitDisplays();
      this.updateCanvasMargins();
    }
  }

  private updateCanvasMargins(): void {
    // This will communicate with the course builder to update canvas margins
    if (
      this.courseBuilder &&
      typeof this.courseBuilder.updateCanvasMargins === "function"
    ) {
      // Convert to pixels (assuming 96 DPI)
      const dpi = 96;
      const marginsInPixels = {
        top:
          this.currentSettings.unit === "inches"
            ? this.currentSettings.top * dpi
            : (this.currentSettings.top / 2.54) * dpi,
        bottom:
          this.currentSettings.unit === "inches"
            ? this.currentSettings.bottom * dpi
            : (this.currentSettings.bottom / 2.54) * dpi,
        left:
          this.currentSettings.unit === "inches"
            ? this.currentSettings.left * dpi
            : (this.currentSettings.left / 2.54) * dpi,
        right:
          this.currentSettings.unit === "inches"
            ? this.currentSettings.right * dpi
            : (this.currentSettings.right / 2.54) * dpi,
      };

      this.courseBuilder.updateCanvasMargins(marginsInPixels);
    } else {
        "üìè Course builder not available yet, margins will be applied when canvas is ready",
      );
    }
  }

  public setCourseBuilder(courseBuilder: any): void {
    this.courseBuilder = courseBuilder;
    // Apply current margins immediately
    this.updateCanvasMargins();
  }

  public setCourseId(courseId: string): void {
    this.loadSettingsFromDatabase(courseId);
  }

  public getCurrentSettings(): MarginSettings {
    return { ...this.currentSettings };
  }

  /**
   * Force save current settings to database (used for manual save operations)
   */
  public async forceSaveToDatabase(): Promise<void> {
    if (this.courseId) {
      await this.saveSettingsToDatabase();
    }
  }

  public getMarginPixels(): {
    top: number;
    bottom: number;
    left: number;
    right: number;
  } {
    const dpi = 96;
    return {
      top:
        this.currentSettings.unit === "inches"
          ? this.currentSettings.top * dpi
          : (this.currentSettings.top / 2.54) * dpi,
      bottom:
        this.currentSettings.unit === "inches"
          ? this.currentSettings.bottom * dpi
          : (this.currentSettings.bottom / 2.54) * dpi,
      left:
        this.currentSettings.unit === "inches"
          ? this.currentSettings.left * dpi
          : (this.currentSettings.left / 2.54) * dpi,
      right:
        this.currentSettings.unit === "inches"
          ? this.currentSettings.right * dpi
          : (this.currentSettings.right / 2.54) * dpi,
    };
  }

  public destroy(): void {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
  }
}

// Export singleton instance
export const marginSettingsHandler = new MarginSettingsHandler();
import { supabase } from "../supabase.js";

export interface TemplateData {
  template_id: string;
  course_id?: string;
  template_description?: string;
  template_type: "lesson";
  template_data: {
    name: string;
    blocks: TemplateBlock[];
    settings: Record<string, any>;
  };
}

export interface TemplateBlock {
  id: string;
  type:
    | "header"
    | "program"
    | "resources"
    | "content"
    | "assignment"
    | "footer";
  order: number;
  config: Record<string, any>;
  content: string;
}

export class TemplateManager {
  private static selectedTemplateId: string | null = null;
  private static currentlyLoadedTemplateId: string | null = null;
  private static currentlyLoadedTemplateData: any = null;

  /**
   * Shows the create template modal
   */
  static showCreateTemplateModal(): void {
    const modal = document.getElementById(
      "create-template-modal",
    ) as HTMLElement;
    if (!modal) {
      console.error("Create template modal not found");
      return;
    }

    // Clear the form for new template creation
    const form = modal.querySelector(
      "#create-template-form",
    ) as HTMLFormElement;
    if (form) {
      form.reset();
    }

    modal.style.display = "flex";
    modal.classList.add("modal--active");
  }

  /**
   * Hides the create template modal
   */
  static hideCreateTemplateModal(): void {
    const modal = document.getElementById("create-template-modal");
    if (modal) {
      modal.classList.remove("modal--active");

      setTimeout(() => {
        modal.style.display = "none";
      }, 300);
    }
  }

  /**
   * Shows the load template modal
   */
  static async showLoadTemplateModal(): Promise<void> {
    const modal = document.getElementById("load-template-modal");
    if (modal) {
      modal.style.display = "flex";
      modal.classList.add("modal--active");

      // Load templates when modal is shown
      await this.loadTemplatesForModal();

      // Add a small delay to trigger the animation
      setTimeout(() => {
        const content = modal.querySelector(".modal__content") as HTMLElement;
        if (content) {
          content.style.transform = "scale(1)";
          content.style.opacity = "1";
        }
      }, 10);
    }
  }

  /**
   * Hides the load template modal
   */
  static hideLoadTemplateModal(): void {
    const modal = document.getElementById("load-template-modal");
    if (modal) {
      const content = modal.querySelector(".modal__content") as HTMLElement;
      if (content) {
        content.style.transform = "scale(0.9)";
        content.style.opacity = "0";
      }

      setTimeout(() => {
        modal.style.display = "none";
        modal.classList.remove("modal--active");
      }, 300);

      // Clear selection
      this.selectedTemplateId = null;
      this.updateLoadButtonState();
    }
  }

  /**
   * Loads templates for the modal display
   */
  static async loadTemplatesForModal(): Promise<void> {
    const loadingEl = document.getElementById("template-loading");
    const contentEl = document.getElementById("template-list-content");
    const noTemplatesEl = document.getElementById("no-templates-message");

    if (loadingEl) loadingEl.style.display = "flex";
    if (contentEl) contentEl.style.display = "none";
    if (noTemplatesEl) noTemplatesEl.style.display = "none";

    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) {
        throw new Error("User not authenticated");
      }

      const { data, error } = await supabase
        .from("templates")
        .select(
          "id, template_id, template_type, template_description, created_at, template_data",
        )
        .eq("created_by", user.id)
        .order("created_at", { ascending: false });

      if (error) {
        throw error;
      }

      if (loadingEl) loadingEl.style.display = "none";

      if (!data || data.length === 0) {
        if (noTemplatesEl) noTemplatesEl.style.display = "flex";
      } else {
        this.displayTemplatesInModal(data);
        if (contentEl) contentEl.style.display = "grid";
      }
    } catch (error) {
      console.error("Failed to load templates:", error);
      if (loadingEl) loadingEl.style.display = "none";
      if (noTemplatesEl) {
        noTemplatesEl.innerHTML = `
          <div class="no-templates__icon">‚ö†</div>
          <h3>Error Loading Templates</h3>
          <p>There was an error loading your templates. Please try again.</p>
          <button class="button button--secondary" onclick="TemplateManager.loadTemplatesForModal()">
            Retry
          </button>
        `;
        noTemplatesEl.style.display = "flex";
      }
    }
  }

  /**
   * Displays templates in the modal
   */
  static displayTemplatesInModal(templates: any[]): void {
    const contentEl = document.getElementById("template-list-content");
    if (!contentEl) return;

    const templatesHtml = templates
      .map((template) => {
        const createdDate = new Date(template.created_at).toLocaleDateString();
        const templateName =
          template.template_data?.name || "Untitled Template";
        const description =
          template.template_description || "No description provided";

        return `
        <div class="template-card" data-template-id="${template.id}" onclick="TemplateManager.selectTemplate('${template.id}')">
          <div class="template-card__header">
            <h4 class="template-card__title">${templateName}</h4>
            <span class="template-card__type">${template.template_type}</span>
          </div>
          <div class="template-card__description">
            ${description}
          </div>
          <div class="template-card__meta">
            <span class="template-card__date">Created: ${createdDate}</span>
          </div>
          <div class="template-card__actions">
            <button class="button button--outline button--small" onclick="event.stopPropagation(); TemplateManager.previewTemplateInModal('${template.id}')">
              Preview
            </button>
            <button class="button button--outline button--small button--danger" onclick="event.stopPropagation(); TemplateManager.deleteTemplate('${template.id}')">
              Delete
            </button>
          </div>
        </div>
      `;
      })
      .join("");

    contentEl.innerHTML = templatesHtml;
  }

  /**
   * Selects a template in the modal
   */
  static selectTemplate(templateId: string): void {
    // Remove previous selection
    document.querySelectorAll(".template-card").forEach((card) => {
      card.classList.remove("template-card--selected");
    });

    // Add selection to current template
    const selectedCard = document.querySelector(
      `[data-template-id="${templateId}"]`,
    );
    if (selectedCard) {
      selectedCard.classList.add("template-card--selected");
    }

    this.selectedTemplateId = templateId;
    this.updateLoadButtonState();
  }

  /**
   * Updates the load button state
   */
  static updateLoadButtonState(): void {
    const loadButton = document.getElementById(
      "load-selected-template",
    ) as HTMLButtonElement;
    if (loadButton) {
      loadButton.disabled = !this.selectedTemplateId;
    }
  }

  /**
   * Loads the selected template
   */
  static async loadSelectedTemplate(): Promise<void> {
    if (!this.selectedTemplateId) return;

    try {
      await this.loadTemplate(this.selectedTemplateId);
      this.hideLoadTemplateModal();
      // The template is now loaded in the config and preview areas
    } catch (error) {
      console.error("Failed to load selected template:", error);
      alert("Failed to load template. Please try again.");
    }
  }

  /**
   * Updates a template field and auto-saves to database
   */
  static async updateTemplateField(
    templateId: string,
    blockType: string,
    fieldName: string,
    isChecked: boolean,
  ): Promise<void> {
    try {
      // Update the currently loaded template data
      if (
        this.currentlyLoadedTemplateData &&
        this.currentlyLoadedTemplateData.id === templateId
      ) {
        const block =
          this.currentlyLoadedTemplateData.template_data.blocks.find(
            (b: any) => b.type === blockType,
          );
        if (block) {
          if (isChecked) {
            block.config[fieldName] = true;
          } else {
            delete block.config[fieldName];
          }
        }

        // Data is automatically persisted to database via auto-save
      }

      // Show saving status
      const statusEl = document.getElementById("template-save-status");
      if (statusEl) {
        statusEl.innerHTML =
          '<span class="save-indicator__text save-indicator__text--saving">Saving...</span>';
      }

      // Get current template data from database
      const { data: currentTemplate, error: fetchError } = await supabase
        .from("templates")
        .select("template_data")
        .eq("id", templateId)
        .single();

      if (fetchError) throw fetchError;

      // Update the specific block's config
      const updatedTemplateData = { ...currentTemplate.template_data };
      const blockToUpdate = updatedTemplateData.blocks.find(
        (block: any) => block.type === blockType,
      );

      if (blockToUpdate) {
        if (isChecked) {
          blockToUpdate.config[fieldName] = true;
        } else {
          delete blockToUpdate.config[fieldName];
        }
      }

      // Save to database
      const { error: updateError } = await supabase
        .from("templates")
        .update({
          template_data: updatedTemplateData,
          updated_at: new Date().toISOString(),
        })
        .eq("id", templateId);

      if (updateError) throw updateError;

      // Show success status
      if (statusEl) {
        statusEl.innerHTML =
          '<span class="save-indicator__text save-indicator__text--saved">Saved</span>';
        setTimeout(() => {
          statusEl.innerHTML =
            '<span class="save-indicator__text">Changes saved automatically</span>';
        }, 2000);
      }

      // Update the preview
      this.updateTemplatePreview();
    } catch (error) {
      console.error("Failed to update template field:", error);

      // Show error status
      const statusEl = document.getElementById("template-save-status");
      if (statusEl) {
        statusEl.innerHTML =
          '<span class="save-indicator__text save-indicator__text--error">Error saving</span>';
        setTimeout(() => {
          statusEl.innerHTML =
            '<span class="save-indicator__text">Changes saved automatically</span>';
        }, 3000);
      }
    }
  }

  /**
   * Saves changes to a template
   */
  static async saveTemplateChanges(templateId: string): Promise<void> {
    try {
      // This would typically gather data from the configuration forms
      // For now, just show a success message
      alert("Template changes saved successfully!");
    } catch (error) {
      console.error("Failed to save template changes:", error);
      alert("Failed to save template changes. Please try again.");
    }
  }

  /**
   * Previews a template in a mini modal
   */
  static async previewTemplateInModal(templateId: string): Promise<void> {
    try {
      const { data, error } = await supabase
        .from("templates")
        .select("*")
        .eq("id", templateId)
        .single();

      if (error) throw error;

      // Create a simple preview modal
      const previewHtml = `
        <div class="template-preview-modal" onclick="this.remove()">
          <div class="template-preview-modal__content" onclick="event.stopPropagation()">
            <div class="template-preview-modal__header">
              <h3>${data.template_data?.name || "Template Preview"}</h3>
              <button onclick="this.closest('.template-preview-modal').remove()">&times;</button>
            </div>
            <div class="template-preview-modal__body">
              <div class="template-blocks-preview">
                ${
                  data.template_data?.blocks
                    ?.map(
                      (block: any) => `
                  <div class="preview-block preview-block--${block.type}">
                    <div class="preview-block__label">${block.type.charAt(0).toUpperCase() + block.type.slice(1)}</div>
                    <div class="preview-block__content">${block.content || "No content"}</div>
                  </div>
                `,
                    )
                    .join("") || "<p>No blocks configured</p>"
                }
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML("beforeend", previewHtml);
    } catch (error) {
      console.error("Failed to preview template:", error);
      alert("Failed to load template preview.");
    }
  }

  /**
   * Deletes a template
   */
  static async deleteTemplate(templateId: string): Promise<void> {
    const confirmation = confirm(
      "Are you sure you want to delete this template? This action cannot be undone.",
    );
    if (!confirmation) return;

    try {
      const { error } = await supabase
        .from("templates")
        .delete()
        .eq("id", templateId);

      if (error) throw error;

      // Reload templates in modal
      await this.loadTemplatesForModal();

    } catch (error) {
      console.error("Failed to delete template:", error);
      alert("Failed to delete template. Please try again.");
    }
  }

  /**
   * Filters templates based on search term
   */
  static filterTemplates(searchTerm: string): void {
    const templateCards = document.querySelectorAll(".template-card");

    templateCards.forEach((card) => {
      const title =
        card
          .querySelector(".template-card__title")
          ?.textContent?.toLowerCase() || "";
      const description =
        card
          .querySelector(".template-card__description")
          ?.textContent?.toLowerCase() || "";
      const type =
        card
          .querySelector(".template-card__type")
          ?.textContent?.toLowerCase() || "";

      const matchesSearch =
        title.includes(searchTerm) ||
        description.includes(searchTerm) ||
        type.includes(searchTerm);

      (card as HTMLElement).style.display = matchesSearch ? "block" : "none";
    });
  }

  /**
   * Applies filters and sorting to templates
   */
  static applyFiltersAndSort(): void {
    const typeFilter = document.getElementById(
      "template-type-filter",
    ) as HTMLSelectElement;
    const sortFilter = document.getElementById(
      "template-sort",
    ) as HTMLSelectElement;
    const searchInput = document.getElementById(
      "template-search",
    ) as HTMLInputElement;

    if (!typeFilter || !sortFilter) return;

    const selectedType = typeFilter.value;
    const sortBy = sortFilter.value;
    const searchTerm = searchInput?.value?.toLowerCase() || "";

    const container = document.getElementById("template-list-content");
    if (!container) return;

    const templateCards = Array.from(
      container.querySelectorAll(".template-card"),
    ) as HTMLElement[];

    // Filter by type and search
    templateCards.forEach((card) => {
      const cardType =
        card
          .querySelector(".template-card__type")
          ?.textContent?.toLowerCase() || "";
      const title =
        card
          .querySelector(".template-card__title")
          ?.textContent?.toLowerCase() || "";
      const description =
        card
          .querySelector(".template-card__description")
          ?.textContent?.toLowerCase() || "";

      const matchesType = !selectedType || cardType === selectedType;
      const matchesSearch =
        !searchTerm ||
        title.includes(searchTerm) ||
        description.includes(searchTerm) ||
        cardType.includes(searchTerm);

      card.style.display = matchesType && matchesSearch ? "block" : "none";
    });

    // Sort visible cards
    const visibleCards = templateCards.filter(
      (card) => card.style.display !== "none",
    );

    visibleCards.sort((a, b) => {
      switch (sortBy) {
        case "name":
          const nameA =
            a.querySelector(".template-card__title")?.textContent || "";
          const nameB =
            b.querySelector(".template-card__title")?.textContent || "";
          return nameA.localeCompare(nameB);
        case "created_at":
          // For created_at, we assume newer templates are shown first by default
          // This would require storing the actual date in a data attribute for proper sorting
          return 0; // Keep original order for now
        case "modified_at":
          // Similar to created_at - would need modification date stored
          return 0; // Keep original order for now
        default:
          return 0;
      }
    });

    // Re-append sorted cards
    visibleCards.forEach((card) => {
      container.appendChild(card);
    });
  }

  /**
   * Creates a new template with default blocks
   */
  static async createTemplate(formData: {
    name: string;
    type: "lesson";
    description?: string;
  }): Promise<string | null> {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) {
        throw new Error("User not authenticated");
      }

      // Generate a unique template ID
      const templateId = `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      // Create default blocks for the template
      const defaultBlocks: TemplateBlock[] = [
        {
          id: "header-1",
          type: "header",
          order: 1,
          config: {
            lesson_number: true,
            lesson_title: true,
            module_title: true,
            course_title: true,
            institution_name: true,
          },
          content: '<div class="header-section">{{header}}</div>',
        },
        {
          id: "program-1",
          type: "program",
          order: 2,
          config: {
            competence: true,
            topic: true,
            objective: true,
            task: true,
          },
          content: '<div class="program-section">{{program}}</div>',
        },
        {
          id: "resources-1",
          type: "resources",
          order: 3,
          config: {
            task: true,
            type: true,
            origin: true,
          },
          content: '<div class="resources-section">{{resources}}</div>',
        },
        {
          id: "content-1",
          type: "content",
          order: 4,
          config: {
            instruction_title: true,
            instruction_area: true,
            student_title: true,
            student_area: true,
            teacher_title: true,
            teacher_area: true,
          },
          content: '<div class="content-section">{{content}}</div>',
        },
        {
          id: "assignment-1",
          type: "assignment",
          order: 5,
          config: {
            instruction_title: true,
            instruction_area: true,
            student_title: true,
            student_area: true,
            teacher_title: true,
            teacher_area: true,
          },
          content: '<div class="assignment-section">{{assignment}}</div>',
        },
        {
          id: "footer-1",
          type: "footer",
          order: 6,
          config: {
            copyright: true,
            page_number: true,
          },
          content: '<footer class="template-footer">{{footer}}</footer>',
        },
      ];

      const templateData: TemplateData = {
        template_id: templateId,
        template_type: formData.type,
        template_description: formData.description,
        template_data: {
          name: formData.name,
          blocks: defaultBlocks,
          settings: {
            version: "1.0",
            created_at: new Date().toISOString(),
          },
        },
      };

      const { data, error } = await supabase
        .from("templates")
        .insert([
          {
            template_id: templateData.template_id,
            template_type: templateData.template_type,
            template_description: templateData.template_description,
            template_data: templateData.template_data,
            created_by: user.id,
            created_at: new Date().toISOString(),
          },
        ])
        .select("id")
        .single();

      if (error) {
        console.error("Error creating template:", error);
        throw error;
      }

      return data.id;
    } catch (error) {
      console.error("Failed to create template:", error);
      return null;
    }
  }

  /**
   * Shows the template configuration and preview areas
   */
  static showTemplateBuilder(templateId?: string): void {
    const templateLayout = document.querySelector(
      ".template-layout",
    ) as HTMLElement;

    if (templateLayout) {
      // Template layout is now always visible, no need to change display

      // Wait a bit for the layout to be visible, then initialize
      setTimeout(() => {
        // Initialize the configuration handler if available
        if (window.templateConfigHandler) {
          window.templateConfigHandler.init();
        } else {
          console.warn(
            "Template config handler not available, showing basic interface",
          );
          this.initializeBasicInterface();
        }

        // If templateId is provided, load the template
        if (templateId) {
          this.loadTemplate(templateId);
        } else {
          this.initializeEmptyTemplate();
        }
      }, 100);
    } else {
      console.error("Template layout not found");
    }
  }

  /**
   * Loads existing templates from the database
   */
  static async loadExistingTemplates(): Promise<void> {
    try {
      // If we have a currently loaded template, display it instead of the placeholder
      if (this.currentlyLoadedTemplateData) {
          "Displaying currently loaded template:",
          this.currentlyLoadedTemplateData,
        );
        this.displayTemplateBlocks(this.currentlyLoadedTemplateData);
        this.updateTemplatePreview(this.currentlyLoadedTemplateData);
        return;
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) {
        throw new Error("User not authenticated");
      }

      const { data, error } = await supabase
        .from("templates")
        .select(
          "id, template_id, template_type, template_description, created_at, template_data",
        )
        .eq("created_by", user.id)
        .order("created_at", { ascending: false });

      if (error) {
        throw error;
      }

      this.displayTemplateList(data || []);
    } catch (error) {
      console.error("Failed to load templates:", error);
    }
  }

  /**
   * Displays the list of available templates
   */
  static displayTemplateList(templates: any[]): void {
    const configArea = document.querySelector(".template-config");
    if (!configArea) return;

    if (templates.length === 0) {
      configArea.innerHTML = `
        <div class="template-config-placeholder">
          <h3 class="heading heading--tertiary">Template Configuration</h3>
          <p class="text">You haven't created any templates yet. Create your first template to get started!</p>
          <div class="template-actions">
            <button class="button button--primary" onclick="TemplateManager.showCreateTemplateModal()">
              Create First Template
            </button>
          </div>
        </div>
      `;
      return;
    }

    // If templates exist, show the configuration interface instead of a list
    // The Load Template button in the header will handle template selection
    configArea.innerHTML = `
      <div class="template-config-placeholder">
        <h3 class="heading heading--tertiary">Template Configuration</h3>
        <p class="text">Use the "Load Template" button above to select and edit an existing template, or create a new one.</p>
      </div>
    `;
  }

  /**
   * Previews a template without editing
   */
  static async previewTemplate(templateId: string): Promise<void> {
    try {
      const { data, error } = await supabase
        .from("templates")
        .select("*")
        .eq("id", templateId)
        .single();

      if (error) {
        throw error;
      }

      this.updateTemplatePreview(data);
    } catch (error) {
      console.error("Failed to preview template:", error);
    }
  }

  /**
   * Initializes a basic interface when the config handler is not available
   */
  static initializeBasicInterface(): void {
    const configArea = document.querySelector(".template-config");
    const previewArea = document.querySelector(".template-preview");

    if (configArea) {
      // Use the existing placeholder structure from HTML instead of generating new HTML
      const placeholder = configArea.querySelector(
        ".template-config-placeholder",
      );
      if (placeholder) {
        placeholder.innerHTML = `
          <h3 class="heading heading--tertiary">Template Configuration</h3>
          <p class="text">Template configuration interface is ready. Use the buttons above to create or load templates.</p>
        `;
      }
    }

    if (previewArea) {
      const previewContainer = previewArea.querySelector(".preview-container");
      if (previewContainer) {
        previewContainer.innerHTML = `
          <div class="preview-placeholder">
            <h4 class="preview-placeholder__title">Template Preview</h4>
            <p class="preview-placeholder__text">Create a new template or load an existing one to see the preview here.</p>
            <div class="template-blocks-default">
              <div class="template-block template-block--header">Header Block</div>
              <div class="template-block template-block--program">Program Block</div>
              <div class="template-block template-block--resources">Resources Block</div>
              <div class="template-block template-block--content">Content Block</div>
              <div class="template-block template-block--assignment">Assignment Block</div>
              <div class="template-block template-block--footer">Footer Block</div>
            </div>
          </div>
        `;
      }
    }
  }

  /**
   * Loads an existing template for editing
   */
  /**
   * Clears the current template state
   */
  static clearTemplateState(): void {
    this.currentlyLoadedTemplateId = null;
    this.currentlyLoadedTemplateData = null;

    // Template state is now managed via database

    // Reset the template areas to placeholder state
    const templateConfig = document.querySelector(".template-config");
    if (templateConfig) {
      const placeholder = templateConfig.querySelector(
        ".template-config-placeholder",
      );
      if (placeholder) {
        placeholder.innerHTML = `
          <h3 class="heading heading--tertiary">Template Configuration</h3>
          <p class="text">Select a template to configure or create a new one...</p>
        `;
      }
    }

    const previewContainer = document.querySelector(".preview-container");
    if (previewContainer) {
      previewContainer.innerHTML = `
        <div class="template-preview-placeholder">
          <h4>Template Preview</h4>
          <p>Template preview will appear here when you load a template...</p>
        </div>
      `;
    }
  }

  static async loadTemplate(templateId: string): Promise<void> {
    try {
      const { data, error } = await supabase
        .from("templates")
        .select("*")
        .eq("id", templateId)
        .single();

      if (error) {
        throw error;
      }


      // Get current course ID and associate template with it
      const courseId = sessionStorage.getItem("currentCourseId");
      if (courseId && data.course_id !== courseId) {

        // Update the template to be associated with current course
        const { error: updateError } = await supabase
          .from("templates")
          .update({ course_id: courseId })
          .eq("id", templateId);

        if (updateError) {
          console.error(
            "Failed to associate template with course:",
            updateError,
          );
        } else {
        }
      }

      // Store the loaded template data
      this.currentlyLoadedTemplateId = data.id; // Store UUID for database operations
      this.currentlyLoadedTemplateData = data;

      // Populate the template configuration area with blocks
      this.displayTemplateBlocks(data);

      // Update the preview area with template content
      this.updateTemplatePreview(data.template_data);
    } catch (error) {
      console.error("Failed to load template:", error);
    }
  }

  /**
   * Loads template associated with current course from database
   */
  static async loadCourseTemplate(): Promise<void> {
    try {
      const courseId = sessionStorage.getItem("currentCourseId");

      if (!courseId) {
        // Try to get the most recent course if no courseId is set
        const { data: recentCourse, error: courseError } = await supabase
          .from("courses")
          .select("id")
          .order("created_at", { ascending: false })
          .limit(1)
          .single();

        if (!courseError && recentCourse) {
          sessionStorage.setItem("currentCourseId", recentCourse.id);
          return this.loadCourseTemplate(); // Recursive call with course ID now set
        } else {
          this.loadExistingTemplates();
          return;
        }
      }


      // Query database for template associated with this course
      const { data: template, error } = await supabase
        .from("templates")
        .select("*")
        .eq("course_id", courseId)
        .single();

      if (error && error.code !== "PGRST116") {
        // PGRST116 = no rows found
        console.error("Error loading course template:", error);
        this.loadExistingTemplates();
        return;
      }

      if (template) {
          "Found existing template for course:",
          template.template_id,
        );

        // Load the template
        this.currentlyLoadedTemplateId = template.id; // Store UUID for database operations
        this.currentlyLoadedTemplateData = template;

        // Populate the template configuration area with blocks
        this.displayTemplateBlocks(template);

        // Update the preview area with template content
        this.updateTemplatePreview(template.template_data);
      } else {
        this.loadExistingTemplates();
      }
    } catch (error) {
      console.error("Failed to load course template:", error);
      // Fallback to showing template list
      this.loadExistingTemplates();
    }
  }

  /**
   * Gets the field configuration for each block type
   */
  static getBlockFieldConfiguration(): Record<
    string,
    Array<{
      name: string;
      label: string;
      mandatory: boolean;
      separator?: boolean;
    }>
  > {
    return {
      header: [
        { name: "lesson_number", label: "Lesson number (#)", mandatory: true },
        { name: "lesson_title", label: "Lesson title", mandatory: true },
        { name: "module_title", label: "Module title", mandatory: true },
        { name: "course_title", label: "Course title", mandatory: true },
        {
          name: "institution_name",
          label: "Institution name",
          mandatory: true,
        },
        { name: "teacher_name", label: "Teacher name", mandatory: false },
      ],
      program: [
        { name: "competence", label: "Competence", mandatory: true },
        { name: "topic", label: "Topic", mandatory: true },
        { name: "objective", label: "Objective", mandatory: true },
        { name: "task", label: "Task", mandatory: true },
      ],
      resources: [
        { name: "task", label: "Task", mandatory: true },
        { name: "type", label: "Type", mandatory: true },
        { name: "origin", label: "Origin", mandatory: true },
        { name: "state", label: "State", mandatory: false },
        { name: "quality", label: "Quality", mandatory: false },
        {
          name: "include_glossary",
          label: "Include Glossary",
          mandatory: false,
          separator: true,
        },
        {
          name: "historical_figures",
          label: "Historical figures",
          mandatory: false,
        },
        { name: "terminology", label: "Terminology", mandatory: false },
        { name: "concepts", label: "Concepts", mandatory: false },
      ],
      content: [
        {
          name: "instruction_title",
          label: "Instruction title",
          mandatory: true,
        },
        {
          name: "instruction_area",
          label: "Instruction area",
          mandatory: true,
        },
        { name: "student_title", label: "Student Title", mandatory: true },
        { name: "student_area", label: "Student Area", mandatory: true },
        { name: "teacher_title", label: "Teacher title", mandatory: true },
        { name: "teacher_area", label: "Teacher area", mandatory: true },
      ],
      assignment: [
        {
          name: "instruction_title",
          label: "Instruction title",
          mandatory: true,
        },
        {
          name: "instruction_area",
          label: "Instruction area",
          mandatory: true,
        },
        { name: "student_title", label: "Student Title", mandatory: true },
        { name: "student_area", label: "Student Area", mandatory: true },
        { name: "teacher_title", label: "Teacher title", mandatory: true },
        { name: "teacher_area", label: "Teacher area", mandatory: true },
      ],
      footer: [
        { name: "copyright", label: "Copyright", mandatory: true },
        { name: "teacher_name", label: "Teacher name", mandatory: false },
        {
          name: "institution_name",
          label: "Institution name",
          mandatory: false,
        },
        { name: "page_number", label: "Page number (#)", mandatory: true },
      ],
    };
  }

  /**
   * Displays the template blocks in the configuration area
   */
  static displayTemplateBlocks(templateData: any): void {
    const configArea = document.querySelector(".template-config");
    if (!configArea) return;

    // Handle both full template object and just template_data
    const actualData = templateData.template_data || templateData;
    const blocks = actualData.blocks || [];
    const templateId = templateData.id || this.currentlyLoadedTemplateId;
    const fieldConfig = this.getBlockFieldConfiguration();

    const blocksHtml = `
      <div class="template-blocks">
        ${blocks
          .map((block: TemplateBlock) => {
            const fields = fieldConfig[block.type] || [];

            return `
            <div class="template-block-config" data-block="${block.type}" data-template-id="${templateId}">
              <div class="template-block-config__header">
                <div class="template-block-item__icon template-block-item__icon--${block.type}"></div>
                <h4 class="template-block-config__title">${block.type.charAt(0).toUpperCase() + block.type.slice(1)}</h4>
              </div>
              <div class="template-block-config__fields" data-block="${block.type}">
                ${fields
                  .map((field) => {
                    // Check if field is enabled in template data
                    const isChecked =
                      field.mandatory ||
                      (block.config && block.config[field.name] === true);

                    return `
                  ${field.separator ? '<div class="template-field-separator"></div>' : ""}
                  <div class="template-field ${field.separator ? "template-field--separator" : ""}">
                    <label class="template-field__label">
                      <input 
                        type="checkbox" 
                        name="${field.name}" 
                        data-block="${block.type}"
                        data-template-id="${templateData.id}"
                        ${field.mandatory ? "checked disabled" : isChecked ? "checked" : ""}
                        onchange="TemplateManager.updateTemplateField('${templateId}', '${block.type}', '${field.name}', this.checked)"
                        class="template-field__checkbox"
                      >
                      <span class="template-field__text">
                        ${field.label}
                      </span>
                    </label>
                  </div>
                `;
                  })
                  .join("")}
              </div>
            </div>
          `;
          })
          .join("")}
      </div>
    `;

    configArea.innerHTML = blocksHtml;

    // Update template preview after displaying blocks
    this.updateTemplatePreview(templateData);
  }

  /**
   * Gets description for a block type
   */
  static getBlockDescription(blockType: string): string {
    const descriptions: Record<string, string> = {
      header: "Title and introduction section",
      program: "Learning objectives and outcomes",
      resources: "Files, links, and materials",
      content: "Main lesson content and materials",
      assignment: "Tasks and submissions",
      footer: "Credits and additional information",
    };
    return descriptions[blockType] || "Block configuration";
  }

  /**
   * Initializes an empty template configuration
   */
  static initializeEmptyTemplate(): void {

    // Clear any existing configuration forms
    const forms = document.querySelectorAll(".template-config form");
    forms.forEach((form) => {
      (form as HTMLFormElement).reset();
    });

    // Create a basic template structure to display
    const basicTemplate = {
      template_data: {
        name: "New Template",
        blocks: [
          {
            id: "header-1",
            type: "header",
            order: 1,
            config: {},
            content: "Header content will appear here",
          },
          {
            id: "program-1",
            type: "program",
            order: 2,
            config: {},
            content: "Learning objectives will appear here",
          },
          {
            id: "resources-1",
            type: "resources",
            order: 3,
            config: {},
            content: "Resources will appear here",
          },
          {
            id: "content-1",
            type: "content",
            order: 4,
            config: {},
            content: "Main content will appear here",
          },
          {
            id: "assignment-1",
            type: "assignment",
            order: 5,
            config: {},
            content: "Assignment details will appear here",
          },
          {
            id: "footer-1",
            type: "footer",
            order: 6,
            config: {},
            content: "Footer content will appear here",
          },
        ],
      },
    };

    // Display the template blocks and preview
    this.displayTemplateBlocks(basicTemplate);
    this.updateTemplatePreview(basicTemplate);
  }

  /**
   * Populates the template configuration form
   */
  static populateTemplateConfig(templateData: any): void {
    // Implementation will be added in template configuration handler
  }

  /**
   * Updates the template preview
   */
  static updateTemplatePreview(templateData?: any): void {
    const previewContainer = document.querySelector(".preview-container");
    if (!previewContainer) return;

    // Use current template data if none provided
    const data = templateData || this.currentlyLoadedTemplateData;

    // Handle both full template object and just template_data
    const actualData = data?.template_data || data;

    if (!actualData || !actualData.blocks) {
      previewContainer.innerHTML = `
        <div class="preview-placeholder">
          <h4 class="preview-placeholder__title">No Template Selected</h4>
          <p class="preview-placeholder__text">Create a new template or select an existing one to see the preview here.</p>
        </div>
      `;
      return;
    }

    const blocks = actualData.blocks || [];
    const templateName = actualData.name || "Untitled Template";

    // Sort blocks by order and render them
    const sortedBlocks = blocks.sort(
      (a: TemplateBlock, b: TemplateBlock) => a.order - b.order,
    );

    const blocksHtml = sortedBlocks
      .map((block: TemplateBlock) => {
        const checkedFields = this.getCheckedFields(block.type);

        return `
        <div class="template-preview-block template-preview-block--${block.type}">
          <div class="template-preview-block__header">
            <h4 class="template-preview-block__title">${block.type.charAt(0).toUpperCase() + block.type.slice(1)}</h4>
          </div>
          <div class="template-preview-block__content">
            ${this.renderBlockContent(block.type, checkedFields)}
          </div>
        </div>
      `;
      })
      .join("");

    previewContainer.innerHTML = `


        ${blocksHtml}
    
    `;
  }

  /**
   * Gets the currently checked fields for a block type from template data
   */
  static getCheckedFields(
    blockType: string,
  ): Array<{ name: string; label: string }> {
    const fieldConfig = this.getBlockFieldConfiguration();
    const blockFields = fieldConfig[blockType] || [];
    const checkedFields: Array<{ name: string; label: string }> = [];

    blockFields.forEach((field) => {
      // Include mandatory fields (always checked)
      if (field.mandatory) {
        checkedFields.push({ name: field.name, label: field.label });
      } else {
        // Include optional fields that are checked in template data
        if (this.currentlyLoadedTemplateData) {
          const block =
            this.currentlyLoadedTemplateData.template_data.blocks.find(
              (b: any) => b.type === blockType,
            );
          if (block && block.config && block.config[field.name] === true) {
            checkedFields.push({ name: field.name, label: field.label });
          }
        }
      }
    });

    return checkedFields;
  }

  /**
   * Renders the content for a specific block type
   */
  static renderBlockContent(
    blockType: string,
    checkedFields: Array<{ name: string; label: string }>,
  ): string {
    if (blockType === "resources") {
      return this.renderResourcesBlockContent(checkedFields);
    }

    if (blockType === "content" || blockType === "assignment") {
      return this.renderNestedBlockContent(blockType, checkedFields);
    }

    // Default table rendering for other blocks
    return `
      <div class="template-preview-table">
        <div class="template-preview-table__header">
          ${checkedFields
            .map(
              (field) => `
            <div class="template-preview-table__column-header">${field.label}</div>
          `,
            )
            .join("")}
        </div>
        <div class="template-preview-table__row">
          ${checkedFields
            .map(
              (field) => `
            <div class="template-preview-table__cell">[${field.label}]</div>
          `,
            )
            .join("")}
        </div>
      </div>
    `;
  }

  /**
   * Renders the nested hierarchical content for Content and Assignment blocks
   */
  static renderNestedBlockContent(
    _blockType: string,
    checkedFields: Array<{ name: string; label: string }>,
  ): string {
    let html = `<div class="template-nested-structure">`;

    // Add the fixed hierarchy with proper nesting indentation
    html += `
      <div class="template-hierarchy">
        <div class="template-hierarchy-level template-hierarchy-level-1">Topic</div>
        <div class="template-hierarchy-level template-hierarchy-level-2">Objective</div>
        <div class="template-hierarchy-level template-hierarchy-level-3">Task</div>
        
        <div class="template-content-fields">
          ${checkedFields
            .map(
              (field) => `
            <div class="template-content-field template-hierarchy-level-4">
              ${field.label}
            </div>
          `,
            )
            .join("")}
        </div>
      </div>
    `;

    html += `</div>`;

    return html;
  }

  /**
   * Renders the special Resources block content with optional glossary table
   */
  static renderResourcesBlockContent(
    checkedFields: Array<{ name: string; label: string }>,
  ): string {
    // Get main resource fields (excluding glossary items)
    const mainFields = checkedFields.filter(
      (field) =>
        ![
          "include_glossary",
          "historical_figures",
          "terminology",
          "concepts",
        ].includes(field.name),
    );

    // Check if glossary is included
    const includeGlossary = checkedFields.some(
      (field) => field.name === "include_glossary",
    );

    // Get glossary items that are selected
    const glossaryItems = checkedFields.filter((field) =>
      ["historical_figures", "terminology", "concepts"].includes(field.name),
    );

    let html = "";

    // Main resources table
    if (mainFields.length > 0) {
      html += `
        <div class="template-preview-table">
          <div class="template-preview-table__header">
            ${mainFields
              .map(
                (field) => `
              <div class="template-preview-table__column-header">${field.label}</div>
            `,
              )
              .join("")}
          </div>
          <div class="template-preview-table__row">
            ${mainFields
              .map(
                (field) => `
              <div class="template-preview-table__cell">[${field.label}]</div>
            `,
              )
              .join("")}
          </div>
        </div>
      `;
    }

    // Glossary table (only if glossary is included and items are selected)
    if (includeGlossary && glossaryItems.length > 0) {
      html += `
        <div class="template-preview-glossary">
          <h5 class="template-preview-glossary__title">Glossary</h5>
          <div class="template-preview-table">
            <div class="template-preview-table__header">
              <div class="template-preview-table__column-header">Type</div>
              <div class="template-preview-table__column-header">URL</div>
            </div>
            ${glossaryItems
              .map(
                (item) => `
              <div class="template-preview-table__row">
                <div class="template-preview-table__cell">${item.label}</div>
                <div class="template-preview-table__cell">[URL]</div>
              </div>
            `,
              )
              .join("")}
          </div>
        </div>
      `;
    }

    return html;
  }

  /**
   * Gets preview content for a block
   */
  static getBlockPreviewContent(block: TemplateBlock): string {
    // If block has custom content, show it (removing HTML tags for preview)
    if (block.content && block.content.trim() !== "") {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = block.content;
      const textContent = tempDiv.textContent || tempDiv.innerText || "";
      return (
        textContent.replace(/\{\{.*?\}\}/g, "[Dynamic Content]") ||
        this.getDefaultBlockContent(block.type)
      );
    }

    return this.getDefaultBlockContent(block.type);
  }

  /**
   * Gets default content for block preview
   */
  static getDefaultBlockContent(blockType: string): string {
    const defaultContent: Record<string, string> = {
      header: "Course title and introduction will appear here",
      program: "Learning objectives and outcomes will be displayed here",
      resources: "Files, links, and materials will be listed here",
      content: "Main lesson content and materials will appear here",
      assignment: "Tasks and submission instructions will be shown here",
      footer: "Credits and additional information will appear here",
    };
    return defaultContent[blockType] || "Block content will appear here";
  } /**
   * Show block configuration modal/interface
   */
  static showBlockConfiguration(blockType: string, templateId?: string): void {
      `Showing configuration for ${blockType} block${templateId ? ` of template ${templateId}` : ""}`,
    );

    // Create an elegant modal for block configuration
    const modalHtml = `
      <div class="modal modal--active" id="block-config-modal">
        <div class="modal__backdrop" onclick="TemplateManager.hideBlockConfiguration()"></div>
        <div class="modal__content">
          <div class="modal__header">
            <h3 class="heading heading--tertiary">Configure ${blockType.charAt(0).toUpperCase() + blockType.slice(1)} Block</h3>
            <button type="button" class="modal__close" onclick="TemplateManager.hideBlockConfiguration()">
              <span class="sr-only">Close</span>
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
          <div class="modal__body">
            <form id="block-config-form" class="form">
              <div class="form__group">
                <label for="block-title" class="form__label">Block Title</label>
                <input type="text" id="block-title" name="block-title" class="form__input" 
                       placeholder="Enter block title" value="${blockType.charAt(0).toUpperCase() + blockType.slice(1)}">
              </div>
              <div class="form__group">
                <label for="block-content" class="form__label">Block Content</label>
                <textarea id="block-content" name="block-content" class="form__textarea" 
                          placeholder="Enter block content" rows="6">Configure ${blockType} block settings and content...</textarea>
              </div>
              <div class="form__group">
                <label class="form__label">Block Options</label>
                <div class="form__checkbox-group">
                  <label class="form__checkbox">
                    <input type="checkbox" name="block-visible" checked>
                    <span class="form__checkbox-label">Visible in template</span>
                  </label>
                  <label class="form__checkbox">
                    <input type="checkbox" name="block-required">
                    <span class="form__checkbox-label">Required field</span>
                  </label>
                </div>
              </div>
            </form>
          </div>
          <div class="modal__footer">
            <button type="button" class="button button--secondary" onclick="TemplateManager.hideBlockConfiguration()">
              Cancel
            </button>
            <button type="button" class="button button--primary" onclick="TemplateManager.saveBlockConfiguration('${blockType}')">
              Save Block
            </button>
          </div>
        </div>
      </div>
    `;

    // Add modal to page
    document.body.insertAdjacentHTML("beforeend", modalHtml);
  }

  /**
   * Hide block configuration modal
   */
  static hideBlockConfiguration(): void {
    const modal = document.getElementById("block-config-modal");
    if (modal) {
      modal.remove();
    }
  }

  /**
   * Save block configuration
   */
  static saveBlockConfiguration(blockType: string): void {
    const form = document.getElementById(
      "block-config-form",
    ) as HTMLFormElement;
    if (form) {
      const formData = new FormData(form);
      const config = {
        title: formData.get("block-title"),
        content: formData.get("block-content"),
        visible: formData.get("block-visible") === "on",
        required: formData.get("block-required") === "on",
      };


      // Here you would save the configuration to the template
      // For now, just show success and close modal
      alert(
        `${blockType.charAt(0).toUpperCase() + blockType.slice(1)} block saved successfully!`,
      );
      this.hideBlockConfiguration();

      // Update the preview
      this.updateBlockPreview(blockType, config);
    }
  }

  /**
   * Update block preview
   */
  static updateBlockPreview(blockType: string, config: any): void {
    const previewBlock = document.querySelector(`.preview-${blockType}`);
    if (previewBlock && config.title) {
      previewBlock.textContent = config.title;
    }
  }
}

// Make TemplateManager available globally for onclick handlers
declare global {
  interface Window {
    TemplateManager: typeof TemplateManager;
  }
}

window.TemplateManager = TemplateManager;

// Initialize template modal handlers when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  // Create template button handler
  const createTemplateBtn = document.getElementById("create-template-btn");
  if (createTemplateBtn) {
    createTemplateBtn.addEventListener("click", () => {
      TemplateManager.showCreateTemplateModal();
    });
  }

  // Load template button handler
  const loadTemplateBtn = document.getElementById("load-template-btn");
  if (loadTemplateBtn) {
    loadTemplateBtn.addEventListener("click", () => {
      TemplateManager.showLoadTemplateModal();
    });
  }

  // Load existing templates when the templates section is accessed
  const templatesSection = document.getElementById("templates");
  if (templatesSection) {
    // Create a MutationObserver to watch for when the templates section becomes active
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (
          mutation.type === "attributes" &&
          mutation.attributeName === "class"
        ) {
          const target = mutation.target as HTMLElement;
          if (
            target.classList.contains("article--active") &&
            target.id === "templates"
          ) {
            // Templates section is now active, load existing templates
              "Templates section activated, loading existing templates",
            );

            // Check if there's a template for the current course
            TemplateManager.loadCourseTemplate();
          }
        }
      });
    });

    observer.observe(templatesSection, { attributes: true });

    // Also check if templates section is already active on page load
    if (templatesSection.classList.contains("article--active")) {

      // Check if there's a template for the current course
      TemplateManager.loadCourseTemplate();
    }
  }

  // Search functionality for load template modal
  const templateSearch = document.getElementById("template-search");
  if (templateSearch) {
    templateSearch.addEventListener("input", (e) => {
      const searchTerm = (e.target as HTMLInputElement).value.toLowerCase();
      TemplateManager.filterTemplates(searchTerm);
    });
  }

  // Filter functionality
  const typeFilter = document.getElementById("template-type-filter");
  const sortFilter = document.getElementById("template-sort");

  if (typeFilter) {
    typeFilter.addEventListener("change", () => {
      TemplateManager.applyFiltersAndSort();
    });
  }

  if (sortFilter) {
    sortFilter.addEventListener("change", () => {
      TemplateManager.applyFiltersAndSort();
    });
  }

  // Modal form submission handler
  const createTemplateForm = document.getElementById("create-template-form");
  if (createTemplateForm) {
    createTemplateForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const formData = new FormData(e.target as HTMLFormElement);
      const templateFormData = {
        name: formData.get("template-name") as string,
        type: formData.get("template-type") as "lesson",
        description:
          (formData.get("template-description") as string) || undefined,
      };


      const templateId = await TemplateManager.createTemplate(templateFormData);
      if (templateId) {
        TemplateManager.hideCreateTemplateModal();
        TemplateManager.showTemplateBuilder(templateId);
        // Reload the template list to show the new template
        setTimeout(() => {
          TemplateManager.loadExistingTemplates();
        }, 500);
      } else {
        console.error("Failed to create template");
        // You could show an error message to the user here
      }
    });
  }

  // Modal close handlers
  const modalCloseBtn = document.querySelector(".modal__close");
  const modal = document.getElementById("create-template-modal");

  if (modalCloseBtn) {
    modalCloseBtn.addEventListener("click", () => {
      TemplateManager.hideCreateTemplateModal();
    });
  }

  if (modal) {
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        TemplateManager.hideCreateTemplateModal();
      }
    });
  }
});
// ==========================================================================
// COURSE FORM HANDLER - Generic form UI controller for all course sections
// ==========================================================================

import {
  SectionConfig,
  ValidationState,
  getSectionConfig,
} from "./courseFormConfig";
import { validateFormSection, isFormSectionValid } from "./courseFormValidator";
import { createCourse, updateCourse, getCourse } from "./createCourse";

// ==========================================================================
// COURSE FORM HANDLER CLASS
// ==========================================================================

export class CourseFormHandler {
  private sectionConfig: SectionConfig;
  private form: HTMLFormElement | null = null;
  private currentCourseId: string | null = null;
  private validationState: ValidationState = {};
  private debounceTimer: NodeJS.Timeout | null = null;

  constructor(sectionName: string) {
    const config = getSectionConfig(sectionName);
    if (!config) {
      throw new Error(`No configuration found for section: ${sectionName}`);
    }

    this.sectionConfig = config;
    this.currentCourseId = sessionStorage.getItem("currentCourseId");
    this.initialize();
  }

  // ==========================================================================
  // INITIALIZATION
  // ==========================================================================

  private async initialize(): Promise<void> {
    this.findForm();
    if (this.form) {
      await this.initializeFields();
      await this.loadExistingData();
      this.setupEventListeners();
      this.validateForm();
    }
  }

  private findForm(): void {
    const activeArticle = document.querySelector(".article--active");
    if (activeArticle) {
      this.form = activeArticle.querySelector("form");
    }
  }

  private async initializeFields(): Promise<void> {
    if (!this.form) return;

    for (const fieldConfig of this.sectionConfig.fields) {
      const field = this.form.querySelector(
        `[name="${fieldConfig.name}"]`,
      ) as HTMLElement;

      if (!field) continue;

      // Handle display fields
      if (fieldConfig.type === "display" && fieldConfig.displayFunction) {
        try {
          const displayValue = await fieldConfig.displayFunction();
          this.setDisplayField(field, displayValue);
        } catch (error) {
          console.error(
            `Error setting display field ${fieldConfig.name}:`,
            error,
          );
        }
      }

      // Handle select fields with options
      if (
        fieldConfig.type === "select" &&
        fieldConfig.options &&
        field.tagName === "SELECT"
      ) {
        this.populateSelectField(field as HTMLSelectElement, fieldConfig);
      }
    }
  }

  private setDisplayField(field: HTMLElement, value: string): void {
    if (field.tagName === "INPUT") {
      (field as HTMLInputElement).value = value;
      (field as HTMLInputElement).readOnly = true;
    } else {
      field.textContent = value;
    }
  }

  private populateSelectField(
    select: HTMLSelectElement,
    fieldConfig: any,
  ): void {
    select.innerHTML = "";

    // Add default option
    const defaultOption = document.createElement("option");
    defaultOption.value = "";
    defaultOption.textContent = `Select ${fieldConfig.name.replace("_", " ")}...`;
    select.appendChild(defaultOption);

    // Add options
    fieldConfig.options.forEach((option: string) => {
      const optionElement = document.createElement("option");
      optionElement.value = option;
      optionElement.textContent = option;
      select.appendChild(optionElement);
    });
  }

  // ==========================================================================
  // DATA LOADING
  // ==========================================================================

  private async loadExistingData(): Promise<void> {
    if (!this.form || !this.currentCourseId) return;

    try {
      const courseData = await getCourse(this.currentCourseId);
      if (!courseData) return;

      this.populateFormFields(courseData);

      // Show course code if we're in essentials section and have a course ID
      if (this.sectionConfig.section === "essentials") {
        this.showCourseCode(this.currentCourseId);
      }

      setTimeout(() => this.validateForm(), 100);
    } catch (error) {
      console.error("Error loading existing course data:", error);
    }
  }

  private populateFormFields(courseData: any): void {
    if (this.sectionConfig.section === "essentials") {
      this.setFieldValue("course_name", courseData.course_name);
      this.setFieldValue("course_description", courseData.course_description);
      this.setFieldValue("course_language", courseData.course_language);

      if (courseData.course_image) {
        this.displayExistingImage(courseData.course_image);
      }
    } else if (this.sectionConfig.section === "classification") {
      // Handle classification data from classification_data JSONB field
      if (courseData.classification_data) {
        const classificationData = courseData.classification_data;
        this.setFieldValue("class_year", classificationData.class_year);
        this.setFieldValue(
          "curricular_framework",
          classificationData.curricular_framework,
        );
        this.setFieldValue("domain", classificationData.domain);
        this.setFieldValue("subject", classificationData.subject);
        this.setFieldValue("topic", classificationData.topic);
        this.setFieldValue("subtopic", classificationData.subtopic);
        this.setFieldValue(
          "previous_course",
          classificationData.previous_course,
        );
        this.setFieldValue("current_course", classificationData.current_course);
        this.setFieldValue("next_course", classificationData.next_course);
      }
    } else if (
      this.sectionConfig.jsonbField &&
      courseData[this.sectionConfig.jsonbField]
    ) {
      const sectionData = courseData[this.sectionConfig.jsonbField];

      this.sectionConfig.fields.forEach((fieldConfig) => {
        if (sectionData[fieldConfig.name]) {
          this.setFieldValue(fieldConfig.name, sectionData[fieldConfig.name]);
        }
      });
    }
  }

  private setFieldValue(fieldName: string, value: any): void {
    if (!this.form || value === null || value === undefined) return;

    // Handle classification dropdown fields
    if (this.sectionConfig.section === "classification") {
      const hiddenInput = this.form.querySelector(
        `#${fieldName}-value`,
      ) as HTMLInputElement;
      const dropdownTrigger = this.form.querySelector(`#${fieldName}-dropdown`);
      const dropdownLabel = dropdownTrigger?.querySelector(".dropdown__label");

      if (hiddenInput && dropdownTrigger && dropdownLabel) {
        hiddenInput.value = value;
        dropdownLabel.textContent = this.getDisplayTextForValue(
          fieldName,
          value,
        );
        dropdownLabel.classList.remove("dropdown__label--placeholder");
        dropdownTrigger.classList.add("dropdown__trigger--success");
        return;
      }
    }

    // Handle regular form fields
    const field = this.form.querySelector(`[name="${fieldName}"]`) as
      | HTMLInputElement
      | HTMLSelectElement
      | HTMLTextAreaElement;
    if (!field) return;

    try {
      if (field.tagName === "SELECT") {
        (field as HTMLSelectElement).value = value;
      } else if (field.type !== "file") {
        field.value = value;
      }

      field.dispatchEvent(new Event("input", { bubbles: true }));
      field.dispatchEvent(new Event("change", { bubbles: true }));
    } catch (error) {
      console.warn(`Failed to set field ${fieldName}:`, error);
    }
  }

  private getDisplayTextForValue(fieldName: string, value: string): string {
    // For class year, return the value as is since it's user-friendly
    if (fieldName === "class_year") {
      return value;
    }

    // For curricular framework, return the value as is
    if (fieldName === "curricular_framework") {
      return value;
    }

    // For other fields, return the value (can be enhanced with lookup tables later)
    return value || "";
  }

  // ==========================================================================
  // EVENT HANDLING
  // ==========================================================================

  private setupEventListeners(): void {
    if (!this.form || this.form.dataset.listenersAttached === "true") return;

    const inputs = this.form.querySelectorAll("input, textarea, select");

    inputs.forEach((input) => {
      const inputElement = input as HTMLInputElement;
      if (inputElement.type === "file") {
        input.addEventListener("change", () =>
          this.handleFileChange(inputElement),
        );
      } else {
        input.addEventListener("input", () => this.handleInputChange());
        input.addEventListener("change", () => this.handleInputChange());
      }
    });

    this.form.addEventListener("submit", (e) => this.handleSubmit(e));

    // Handle remove image button
    const removeImageBtn = this.form.querySelector("#remove-image");
    if (removeImageBtn) {
      removeImageBtn.addEventListener("click", () => this.handleRemoveImage());
    }

    this.form.dataset.listenersAttached = "true";
  }

  private handleInputChange(): void {
    this.validateForm();

    if (this.sectionConfig.autoSave && this.currentCourseId) {
      this.debouncedSave();
    }
  }

  private handleFileChange(input: HTMLInputElement): void {
    const file = input.files?.[0];
    if (file) {
      this.showFilePreview(file);
    }
    this.validateForm();
  }

  private handleRemoveImage(): void {
    const imagePreview = document.getElementById("image-preview");
    const previewImg = document.getElementById(
      "preview-img",
    ) as HTMLImageElement;
    const fileInput = document.getElementById(
      "course-image",
    ) as HTMLInputElement;

    if (imagePreview && previewImg && fileInput) {
      imagePreview.style.display = "none";
      fileInput.value = "";
      previewImg.src = "";
      this.validateForm();
    }
  }

  private async handleSubmit(event: Event): Promise<void> {
    event.preventDefault();

    if (this.form?.dataset.submitting === "true") return;

    if (!this.isFormValid()) {
      this.showStatus("Please fill in all required fields", "error");
      return;
    }

    if (this.form) this.form.dataset.submitting = "true";

    try {
      if (this.sectionConfig.section === "essentials") {
        await this.createNewCourse();
      } else {
        await this.updateExistingCourse();
      }
    } finally {
      if (this.form) this.form.dataset.submitting = "false";
    }
  }

  // ==========================================================================
  // VALIDATION
  // ==========================================================================

  private validateForm(): void {
    if (!this.form) return;

    const formData = this.getFormData();
    this.validationState = validateFormSection(
      this.sectionConfig.fields,
      formData,
    );
    this.updateUI();
  }

  private isFormValid(): boolean {
    return isFormSectionValid(
      this.sectionConfig.requiredFields,
      this.validationState,
    );
  }

  private getFormData(): { [key: string]: any } {
    if (!this.form) return {};

    const formData = new FormData(this.form);
    const data: { [key: string]: any } = {};

    for (const [key, value] of formData.entries()) {
      data[key] = value instanceof File ? value : String(value).trim();
    }

    return data;
  }

  // ==========================================================================
  // COURSE OPERATIONS
  // ==========================================================================

  private async createNewCourse(): Promise<void> {
    try {
      this.showStatus("Creating course...", "loading");

      const formData = this.getFormData();
      const courseData = {
        course_name: formData.course_name,
        course_description: formData.course_description,
        course_language: formData.course_language,
        course_image: formData.course_image,
      };

      const result = await createCourse(courseData);

      if (result.success && result.courseId) {
        this.currentCourseId = result.courseId;
        sessionStorage.setItem("currentCourseId", result.courseId);

        this.showStatus("Course created successfully! üéâ", "success");
        this.showCourseCode(result.courseId);
        this.navigateToNextSection();
      } else {
        throw new Error(result.error || "Failed to create course");
      }
    } catch (error) {
      console.error("Error creating course:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error occurred";
      this.showStatus(`Failed to create course: ${errorMessage}`, "error");
    }
  }

  private async updateExistingCourse(): Promise<void> {
    if (!this.currentCourseId) return;

    try {
      const formData = this.getFormData();
      const updateData: any = {};

      if (this.sectionConfig.jsonbField) {
        updateData[this.sectionConfig.jsonbField] = formData;
      } else {
        Object.assign(updateData, formData);
      }

      const result = await updateCourse(this.currentCourseId, updateData);

      if (result.success) {
        this.showStatus("Saved ‚úì", "success");
      } else {
        throw new Error(result.error || "Failed to save");
      }
    } catch (error) {
      console.error("Error updating course:", error);
      this.showStatus("Failed to save", "error");
    }
  }

  // ==========================================================================
  // UI HELPERS
  // ==========================================================================

  private displayExistingImage(imageUrl: string): void {
    const imagePreview = document.getElementById("image-preview");
    const previewImg = document.getElementById(
      "preview-img",
    ) as HTMLImageElement;
    const fileUploadLabel = this.form?.querySelector(
      ".file-upload__compact-label",
    );

    if (imagePreview && previewImg) {
      previewImg.src = imageUrl;
      imagePreview.style.display = "block";

      if (fileUploadLabel) {
        const textElement = fileUploadLabel.querySelector(".file-upload__text");
        if (textElement) {
          textElement.textContent = "Change course image";
        }
      }
    }
  }

  private showFilePreview(file: File): void {
    const preview = document.getElementById("image-preview");
    const img = document.getElementById("preview-img") as HTMLImageElement;

    if (preview && img) {
      const reader = new FileReader();
      reader.onload = (e) => {
        img.src = e.target?.result as string;
        preview.style.display = "block";
      };
      reader.readAsDataURL(file);
    }
  }

  private updateUI(): void {
    const submitBtn = this.form?.querySelector(
      'button[type="submit"]',
    ) as HTMLButtonElement;

    if (submitBtn) {
      const isValid = this.isFormValid();
      submitBtn.disabled = !isValid;
      submitBtn.classList.toggle("button--disabled", !isValid);
      submitBtn.classList.toggle("button--primary", isValid);
    }
  }

  private showStatus(
    message: string,
    type: "success" | "error" | "loading",
  ): void {
    const statusDiv = this.form?.querySelector(".form__status") as HTMLElement;
    if (statusDiv) {
      statusDiv.textContent = message;
      statusDiv.className = `form__status form__status--${type}`;
    }
  }

  private showCourseCode(courseId: string): void {
    const courseCodeDisplay = this.form?.querySelector(
      "#course-code-display",
    ) as HTMLElement;
    const courseCodeValue = this.form?.querySelector(
      "#course-code-value",
    ) as HTMLElement;
    const courseCodeCopyBtn = this.form?.querySelector(
      "#course-code-copy-btn",
    ) as HTMLElement;

    if (courseCodeDisplay && courseCodeValue && courseCodeCopyBtn) {
      courseCodeValue.textContent = courseId;
      courseCodeDisplay.style.display = "block";

      // Only add copy functionality if not already added
      if (!courseCodeCopyBtn.hasAttribute("data-copy-listener")) {
        courseCodeCopyBtn.setAttribute("data-copy-listener", "true");

        courseCodeCopyBtn.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(courseId);
            this.showCopyFeedback(courseCodeCopyBtn);
          } catch (err) {
            console.error("Failed to copy course code:", err);
            // Fallback for older browsers
            this.fallbackCopy(courseId);
            this.showCopyFeedback(courseCodeCopyBtn);
          }
        });
      }
    }
  }

  private showCopyFeedback(button: HTMLElement): void {
    const originalContent = button.innerHTML;
    button.innerHTML = "<span>‚úì</span>";
    button.style.color = "#10b981"; // green

    setTimeout(() => {
      button.innerHTML = originalContent;
      button.style.color = "";
    }, 1500);
  }

  private fallbackCopy(text: string): void {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand("copy");
    document.body.removeChild(textArea);
  }

  private navigateToNextSection(): void {
    setTimeout(() => {
      const nextLink = document.querySelector(
        '[data-section="classification"]',
      ) as HTMLElement;
      nextLink?.click();
    }, 1500);
  }

  private debouncedSave(): void {
    if (this.debounceTimer) clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => this.updateExistingCourse(), 500);
  }
}

// ==========================================================================
// EXPORT
// ==========================================================================

export function initializeCourseForm(sectionName: string): CourseFormHandler {
  return new CourseFormHandler(sectionName);
}
// ==========================================================================
// COURSES PAGE - Load and display user courses with navigation
// ==========================================================================

import { getUserCourses } from "./createCourse";

interface Course {
  id: string;
  course_name: string;
  course_description: string;
  course_image?: string;
  course_language: string;
  created_at: string;
  updated_at: string;
  // Add other course properties as needed
}

export class CoursesManager {
  private coursesContainer: HTMLElement;
  private noCoursesMessage: HTMLElement;

  constructor() {
    this.coursesContainer = document.getElementById(
      "courses-container",
    ) as HTMLElement;
    this.noCoursesMessage = document.getElementById(
      "no-courses-message",
    ) as HTMLElement;

    this.initialize();
  }

  private async initialize(): Promise<void> {
    await this.loadCourses();
  }

  private async loadCourses(): Promise<void> {
    try {
      const courses = await getUserCourses();

      if (courses && courses.length > 0) {
        this.displayCourses(courses);
        this.hideNoCoursesMessage();
      } else {
        this.showNoCoursesMessage();
      }
    } catch (error) {
      console.error("Error loading courses:", error);
      this.showNoCoursesMessage();
    }
  }

  private displayCourses(courses: Course[]): void {
    // Clear existing courses (except no-courses message)
    const existingCards =
      this.coursesContainer.querySelectorAll(".course-card");
    existingCards.forEach((card) => card.remove());

    courses.forEach((course) => {
      const courseCard = this.createCourseCard(course);
      this.coursesContainer.appendChild(courseCard);
    });
  }

  private createCourseCard(course: Course): HTMLElement {
    const cardElement = document.createElement("div");
    cardElement.className = "course-card";
    cardElement.dataset.courseId = course.id;

    cardElement.innerHTML = `
      <div class="course-card__image-container">
        ${
          course.course_image
            ? `<img src="${course.course_image}" alt="${course.course_name}" class="course-card__image">`
            : `<div class="course-card__image-placeholder">${this.getInitials(course.course_name)}</div>`
        }
      </div>
      
      <div class="course-card__content">
        <h3 class="course-card__title">${course.course_name}</h3>
      </div>
      
      <div class="course-card__navigation">
        <div class="course-card__nav-item" 
             data-section="setup" data-course-id="${course.id}">
          Setup
        </div>
        <div class="course-card__nav-item" 
             data-section="create" data-course-id="${course.id}">
          Create
        </div>
        <div class="course-card__nav-item" 
             data-section="preview" data-course-id="${course.id}">
          Preview
        </div>
        <div class="course-card__nav-item" 
             data-section="launch" data-course-id="${course.id}">
          Launch
        </div>
      </div>
    `;

    // Add click event listeners to navigation items
    this.addNavigationEventListeners(cardElement);

    return cardElement;
  }

  private addNavigationEventListeners(cardElement: HTMLElement): void {
    const navItems = cardElement.querySelectorAll(".course-card__nav-item");

    navItems.forEach((item) => {
      item.addEventListener("click", (e) => {
        e.stopPropagation();

        const section = (item as HTMLElement).dataset.section;
        const courseId = (item as HTMLElement).dataset.courseId;

        if (section && courseId) {
          this.navigateToCourseSection(courseId, section);
        }
      });
    });
  }

  private navigateToCourseSection(courseId: string, section: string): void {

    // Store the course ID in session storage for the course builder
    sessionStorage.setItem("currentCourseId", courseId);

    // Navigate to the course builder with the specific section
    const url = `/src/pages/teacher/coursebuilder.html#${section}`;
    window.location.href = url;
  }

  private getInitials(courseName: string): string {
    return courseName
      .split(" ")
      .map((word) => word.charAt(0).toUpperCase())
      .slice(0, 2)
      .join("");
  }

  private showNoCoursesMessage(): void {
    if (this.noCoursesMessage) {
      this.noCoursesMessage.style.display = "block";
    }
  }

  private hideNoCoursesMessage(): void {
    if (this.noCoursesMessage) {
      this.noCoursesMessage.style.display = "none";
    }
  }

  // Public method to refresh courses (called after creating a new course)
  public async refreshCourses(): Promise<void> {
    await this.loadCourses();
  }
}

// ==========================================================================
// INITIALIZE COURSES MANAGER
// ==========================================================================

// Auto-initialize when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  new CoursesManager();
});

// Export for use in other modules
export function initializeCoursesManager(): CoursesManager {
  return new CoursesManager();
}
// ==========================================================================
// COURSE FORM VALIDATION - Validation logic and rules
// ==========================================================================

import { FormFieldConfig, ValidationState } from "./courseFormConfig";

// ==========================================================================
// VALIDATION FUNCTIONS
// ==========================================================================

export function validateField(config: FormFieldConfig, value: any): boolean {
  // If field is not required and has no value, it's valid
  if (!value && !config.required) return true;

  // If field is required and has no value, it's invalid
  if (!value && config.required) return false;

  // Validate based on field type
  switch (config.type) {
    case "text":
    case "textarea":
      return validateTextField(config, value);

    case "file":
      return validateFileField(config, value);

    case "select":
      return validateSelectField(config, value);

    case "number":
      return validateNumberField(config, value);

    case "date":
    case "time":
      return validateDateTimeField(config, value);

    case "checkbox":
      return true; // Checkboxes are always valid

    case "display":
      return true; // Display fields are always valid

    default:
      return Boolean(value);
  }
}

function validateTextField(config: FormFieldConfig, value: string): boolean {
  const strValue = String(value).trim();

  // Check minimum length
  if (config.minLength && strValue.length < config.minLength) {
    return false;
  }

  // Check maximum length
  if (config.maxLength && strValue.length > config.maxLength) {
    return false;
  }

  // Check pattern
  if (config.pattern && !config.pattern.test(strValue)) {
    return false;
  }

  return true;
}

function validateFileField(config: FormFieldConfig, value: File): boolean {
  if (!value) return !config.required;

  // Check file type if accept is specified
  if (config.accept && !isFileTypeAccepted(value, config.accept)) {
    return false;
  }

  return true;
}

function validateSelectField(config: FormFieldConfig, value: string): boolean {
  if (!value) return !config.required;

  // If options are specified, check if value is in the list
  if (config.options && !config.options.includes(value)) {
    return false;
  }

  return true;
}

function validateNumberField(
  config: FormFieldConfig,
  value: number | string,
): boolean {
  if (!value && value !== 0) return !config.required;

  const numValue = Number(value);
  return !isNaN(numValue);
}

function validateDateTimeField(
  config: FormFieldConfig,
  value: string,
): boolean {
  if (!value) return !config.required;

  // Basic date/time validation
  if (config.type === "date") {
    const date = new Date(value);
    return !isNaN(date.getTime());
  }

  if (config.type === "time") {
    // Basic time format validation (HH:MM)
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    return timeRegex.test(value);
  }

  return true;
}

function isFileTypeAccepted(file: File, accept: string): boolean {
  const acceptedTypes = accept.split(",").map((type) => type.trim());

  for (const acceptedType of acceptedTypes) {
    if (acceptedType.startsWith(".")) {
      // File extension check
      if (file.name.toLowerCase().endsWith(acceptedType.toLowerCase())) {
        return true;
      }
    } else if (acceptedType.includes("/*")) {
      // MIME type wildcard check (e.g., image/*)
      const baseType = acceptedType.split("/")[0];
      if (file.type.startsWith(baseType + "/")) {
        return true;
      }
    } else {
      // Exact MIME type check
      if (file.type === acceptedType) {
        return true;
      }
    }
  }

  return false;
}

// ==========================================================================
// FORM VALIDATION
// ==========================================================================

export function validateFormSection(
  fields: FormFieldConfig[],
  formData: { [key: string]: any },
): ValidationState {
  const validationState: ValidationState = {};

  fields.forEach((fieldConfig) => {
    const value = formData[fieldConfig.name];
    validationState[fieldConfig.name] = validateField(fieldConfig, value);
  });

  return validationState;
}

export function isFormSectionValid(
  requiredFields: string[],
  validationState: ValidationState,
): boolean {
  return requiredFields.every(
    (fieldName) => validationState[fieldName] === true,
  );
}

// ==========================================================================
// VALIDATION ERROR MESSAGES
// ==========================================================================

export function getValidationMessage(
  config: FormFieldConfig,
  value: any,
): string {
  if (!value && config.required) {
    return `${config.name.replace("_", " ")} is required`;
  }

  if (config.type === "text" || config.type === "textarea") {
    const strValue = String(value || "").trim();

    if (config.minLength && strValue.length < config.minLength) {
      return `${config.name.replace("_", " ")} must be at least ${config.minLength} characters`;
    }

    if (config.maxLength && strValue.length > config.maxLength) {
      return `${config.name.replace("_", " ")} must be no more than ${config.maxLength} characters`;
    }
  }

  if (config.type === "file" && value instanceof File) {
    if (config.accept && !isFileTypeAccepted(value, config.accept)) {
      return `Please select a valid file type (${config.accept})`;
    }
  }

  return ""; // No validation error
}

// ==========================================================================
// VALIDATION STATE HELPERS
// ==========================================================================

export function hasValidationErrors(validationState: ValidationState): boolean {
  return Object.values(validationState).some((isValid) => !isValid);
}

export function getInvalidFields(validationState: ValidationState): string[] {
  return Object.keys(validationState).filter(
    (fieldName) => !validationState[fieldName],
  );
}

export function getValidFields(validationState: ValidationState): string[] {
  return Object.keys(validationState).filter(
    (fieldName) => validationState[fieldName],
  );
}
export interface TemplateBlockConfig {
  id: string;
  type:
    | "header"
    | "program"
    | "resources"
    | "content"
    | "assignment"
    | "footer";
  label: string;
  icon: string;
  defaultConfig: Record<string, any>;
  configFields: TemplateConfigField[];
}

export interface TemplateConfigField {
  name: string;
  label: string;
  type: "text" | "textarea" | "select" | "checkbox" | "color" | "number";
  options?: { value: string; label: string }[];
  defaultValue?: any;
  required?: boolean;
}

export const TEMPLATE_BLOCKS: TemplateBlockConfig[] = [
  {
    id: "header",
    type: "header",
    label: "Header",
    icon: "header",
    defaultConfig: {
      showTitle: true,
      showSubtitle: true,
      backgroundColor: "#ffffff",
      textColor: "#333333",
    },
    configFields: [
      {
        name: "showTitle",
        label: "Show Title",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "showSubtitle",
        label: "Show Subtitle",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "backgroundColor",
        label: "Background Color",
        type: "color",
        defaultValue: "#ffffff",
      },
      {
        name: "textColor",
        label: "Text Color",
        type: "color",
        defaultValue: "#333333",
      },
    ],
  },
  {
    id: "program",
    type: "program",
    label: "Program",
    icon: "program",
    defaultConfig: {
      showObjectives: true,
      showOutcomes: true,
      showPrerequisites: false,
    },
    configFields: [
      {
        name: "showObjectives",
        label: "Show Learning Objectives",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "showOutcomes",
        label: "Show Learning Outcomes",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "showPrerequisites",
        label: "Show Prerequisites",
        type: "checkbox",
        defaultValue: false,
      },
    ],
  },
  {
    id: "resources",
    type: "resources",
    label: "Resources",
    icon: "resources",
    defaultConfig: {
      allowFiles: true,
      allowLinks: true,
      allowVideos: true,
      maxFiles: 10,
    },
    configFields: [
      {
        name: "allowFiles",
        label: "Allow File Uploads",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "allowLinks",
        label: "Allow External Links",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "allowVideos",
        label: "Allow Video Embeds",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "maxFiles",
        label: "Maximum Files",
        type: "number",
        defaultValue: 10,
      },
    ],
  },
  {
    id: "content",
    type: "content",
    label: "Content",
    icon: "content",
    defaultConfig: {
      editor: "rich-text",
      allowMedia: true,
      allowTables: true,
    },
    configFields: [
      {
        name: "editor",
        label: "Editor Type",
        type: "select",
        options: [
          { value: "rich-text", label: "Rich Text Editor" },
          { value: "markdown", label: "Markdown Editor" },
          { value: "plain-text", label: "Plain Text" },
        ],
        defaultValue: "rich-text",
      },
      {
        name: "allowMedia",
        label: "Allow Media Uploads",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "allowTables",
        label: "Allow Tables",
        type: "checkbox",
        defaultValue: true,
      },
    ],
  },
  {
    id: "assignment",
    type: "assignment",
    label: "Assignment",
    icon: "assignment",
    defaultConfig: {
      allowSubmissions: true,
      requireDueDate: true,
      enableGrading: true,
      maxSubmissions: 1,
    },
    configFields: [
      {
        name: "allowSubmissions",
        label: "Allow Student Submissions",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "requireDueDate",
        label: "Require Due Date",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "enableGrading",
        label: "Enable Grading",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "maxSubmissions",
        label: "Maximum Submissions",
        type: "number",
        defaultValue: 1,
      },
    ],
  },
  {
    id: "footer",
    type: "footer",
    label: "Footer",
    icon: "footer",
    defaultConfig: {
      showCredits: true,
      showDate: true,
      showContact: false,
    },
    configFields: [
      {
        name: "showCredits",
        label: "Show Credits",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "showDate",
        label: "Show Creation Date",
        type: "checkbox",
        defaultValue: true,
      },
      {
        name: "showContact",
        label: "Show Contact Information",
        type: "checkbox",
        defaultValue: false,
      },
    ],
  },
];
export class TemplatePreviewHandler {
  private previewContainer: HTMLElement | null = null;

  constructor() {
    this.previewContainer = document.querySelector(".preview-container");
    this.setupEventListeners();
  }

  /**
   * Sets up event listeners for template preview updates
   */
  private setupEventListeners(): void {
    document.addEventListener("templateConfigChanged", (e: any) => {
      this.updatePreview(e.detail.template, e.detail.activeBlocks);
    });
  }

  /**
   * Updates the template preview based on configuration
   */
  updatePreview(template: any, activeBlocks: string[]): void {
    if (!this.previewContainer) return;

    if (!template || !activeBlocks.length) {
      this.renderEmptyPreview();
      return;
    }

    const previewHtml = this.generatePreviewHtml(template, activeBlocks);
    this.previewContainer.innerHTML = previewHtml;
  }

  /**
   * Renders an empty preview state
   */
  private renderEmptyPreview(): void {
    if (!this.previewContainer) return;

    this.previewContainer.innerHTML = `
      <div class="preview-empty">
        <div class="preview-empty__icon">üìã</div>
        <h4 class="preview-empty__title">Template Preview</h4>
        <p class="preview-empty__text">Configure your template blocks to see a preview here.</p>
      </div>
    `;
  }

  /**
   * Generates HTML for the template preview
   */
  private generatePreviewHtml(template: any, activeBlocks: string[]): string {
    const blocks = template.blocks || [];
    const sortedBlocks = blocks
      .filter((block: any) => activeBlocks.includes(block.type))
      .sort((a: any, b: any) => {
        const aIndex = activeBlocks.indexOf(a.type);
        const bIndex = activeBlocks.indexOf(b.type);
        return aIndex - bIndex;
      });

    const blocksHtml = sortedBlocks
      .map((block: any) => this.renderBlock(block))
      .join("");

    return `
      <div class="template-preview-content">
        <div class="preview-header">
          <h4 class="preview-title">Template Preview</h4>
          <div class="preview-actions">
            <button type="button" class="btn btn--small btn--secondary" onclick="templatePreviewHandler.exportTemplate()">
              Export
            </button>
          </div>
        </div>
        <div class="preview-body">
          ${blocksHtml}
        </div>
      </div>
    `;
  }

  /**
   * Renders a single block in the preview
   */
  private renderBlock(block: any): string {
    const config = block.config || {};

    switch (block.type) {
      case "header":
        return this.renderHeaderBlock(config);
      case "program":
        return this.renderProgramBlock(config);
      case "resources":
        return this.renderResourcesBlock(config);
      case "content":
        return this.renderContentBlock(config);
      case "assignment":
        return this.renderAssignmentBlock(config);
      case "footer":
        return this.renderFooterBlock(config);
      default:
        return `<div class="preview-block preview-block--unknown">Unknown block type: ${block.type}</div>`;
    }
  }

  /**
   * Renders header block preview
   */
  private renderHeaderBlock(config: any): string {
    const backgroundColor = config.backgroundColor || "#ffffff";
    const textColor = config.textColor || "#333333";
    const showTitle = config.showTitle !== false;
    const showSubtitle = config.showSubtitle !== false;

    return `
      <div class="preview-block preview-block--header" style="background-color: ${backgroundColor}; color: ${textColor};">
        <div class="preview-block__label">üìã Header</div>
        <div class="preview-block__content">
          ${showTitle ? '<h1 class="preview-title">Course Title</h1>' : ""}
          ${showSubtitle ? '<h2 class="preview-subtitle">Course Subtitle</h2>' : ""}
        </div>
      </div>
    `;
  }

  /**
   * Renders program block preview
   */
  private renderProgramBlock(config: any): string {
    const showObjectives = config.showObjectives !== false;
    const showOutcomes = config.showOutcomes !== false;
    const showPrerequisites = config.showPrerequisites === true;

    return `
      <div class="preview-block preview-block--program">
        <div class="preview-block__label">üéØ Program</div>
        <div class="preview-block__content">
          ${showObjectives ? '<div class="preview-section"><strong>Learning Objectives:</strong> <span class="preview-placeholder">Objectives will be displayed here</span></div>' : ""}
          ${showOutcomes ? '<div class="preview-section"><strong>Learning Outcomes:</strong> <span class="preview-placeholder">Outcomes will be displayed here</span></div>' : ""}
          ${showPrerequisites ? '<div class="preview-section"><strong>Prerequisites:</strong> <span class="preview-placeholder">Prerequisites will be displayed here</span></div>' : ""}
        </div>
      </div>
    `;
  }

  /**
   * Renders resources block preview
   */
  private renderResourcesBlock(config: any): string {
    const allowFiles = config.allowFiles !== false;
    const allowLinks = config.allowLinks !== false;
    const allowVideos = config.allowVideos !== false;
    const maxFiles = config.maxFiles || 10;

    return `
      <div class="preview-block preview-block--resources">
        <div class="preview-block__label">üìö Resources</div>
        <div class="preview-block__content">
          <div class="preview-section">
            ${allowFiles ? `<div class="preview-resource">üìé File uploads (max: ${maxFiles})</div>` : ""}
            ${allowLinks ? '<div class="preview-resource">üîó External links</div>' : ""}
            ${allowVideos ? '<div class="preview-resource">üé• Video embeds</div>' : ""}
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Renders content block preview
   */
  private renderContentBlock(config: any): string {
    const editor = config.editor || "rich-text";
    const allowMedia = config.allowMedia !== false;
    const allowTables = config.allowTables !== false;

    return `
      <div class="preview-block preview-block--content">
        <div class="preview-block__label">üìù Content</div>
        <div class="preview-block__content">
          <div class="preview-section">
            <div class="preview-editor">Editor: ${editor}</div>
            ${allowMedia ? '<div class="preview-feature">‚úì Media uploads enabled</div>' : ""}
            ${allowTables ? '<div class="preview-feature">‚úì Tables enabled</div>' : ""}
            <div class="preview-placeholder">Course content will be displayed here...</div>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Renders assignment block preview
   */
  private renderAssignmentBlock(config: any): string {
    const allowSubmissions = config.allowSubmissions !== false;
    const requireDueDate = config.requireDueDate !== false;
    const enableGrading = config.enableGrading !== false;
    const maxSubmissions = config.maxSubmissions || 1;

    return `
      <div class="preview-block preview-block--assignment">
        <div class="preview-block__label">‚úÖ Assignment</div>
        <div class="preview-block__content">
          <div class="preview-section">
            ${allowSubmissions ? `<div class="preview-feature">‚úì Student submissions (max: ${maxSubmissions})</div>` : ""}
            ${requireDueDate ? '<div class="preview-feature">‚úì Due date required</div>' : ""}
            ${enableGrading ? '<div class="preview-feature">‚úì Grading enabled</div>' : ""}
            <div class="preview-placeholder">Assignment details will be displayed here...</div>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Renders footer block preview
   */
  private renderFooterBlock(config: any): string {
    const showCredits = config.showCredits !== false;
    const showDate = config.showDate !== false;
    const showContact = config.showContact === true;

    return `
      <div class="preview-block preview-block--footer">
        <div class="preview-block__label">üîñ Footer</div>
        <div class="preview-block__content">
          <div class="preview-section">
            ${showCredits ? '<div class="preview-feature">‚úì Credits displayed</div>' : ""}
            ${showDate ? '<div class="preview-feature">‚úì Creation date displayed</div>' : ""}
            ${showContact ? '<div class="preview-feature">‚úì Contact information displayed</div>' : ""}
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Exports the current template configuration
   */
  exportTemplate(): void {
    // This would open an export modal or trigger a download
    // Implementation for template export functionality
  }
}

// Create global instance
declare global {
  interface Window {
    templatePreviewHandler: TemplatePreviewHandler;
  }
}

window.templatePreviewHandler = new TemplatePreviewHandler();
import { TEMPLATE_BLOCKS } from "./templateBlocks.js";

export class TemplateConfigHandler {
  private currentTemplate: any = null;
  private activeBlocks: string[] = [];

  /**
   * Initializes the template configuration interface
   */
  init(): void {
    this.renderBlockSelector();
    this.setupEventListeners();
  }

  /**
   * Renders the block selector interface
   */
  private renderBlockSelector(): void {
    const configContainer = document.querySelector(".template-config");
    if (!configContainer) return;

    const blockSelectorHtml = `
      <div class="template-blocks-selector">
        <h3 class="heading heading--tertiary">Template Blocks</h3>
        <div class="blocks-grid">
          ${TEMPLATE_BLOCKS.map(
            (block) => `
            <div class="block-option" data-block-type="${block.type}">
              <div class="block-option__icon">${block.icon}</div>
              <div class="block-option__label">${block.label}</div>
              <div class="block-option__toggle">
                <input type="checkbox" id="toggle-${block.type}" checked>
                <label for="toggle-${block.type}"></label>
              </div>
            </div>
          `,
          ).join("")}
        </div>
      </div>
      <div class="template-block-config">
        <h3 class="heading heading--tertiary">Block Configuration</h3>
        <div class="block-config-content">
          <p class="text">Select a block above to configure its settings.</p>
        </div>
      </div>
    `;

    configContainer.innerHTML = blockSelectorHtml;
  }

  /**
   * Sets up event listeners for the configuration interface
   */
  private setupEventListeners(): void {
    // Block toggle listeners
    document
      .querySelectorAll('.block-option input[type="checkbox"]')
      .forEach((checkbox) => {
        checkbox.addEventListener("change", (e) => {
          const target = e.target as HTMLInputElement;
          const blockType = target.id.replace("toggle-", "");
          this.toggleBlock(blockType, target.checked);
        });
      });

    // Block selection listeners
    document.querySelectorAll(".block-option").forEach((option) => {
      option.addEventListener("click", (e) => {
        // Avoid triggering when clicking the checkbox
        if ((e.target as HTMLElement).tagName !== "INPUT") {
          const blockType = option.getAttribute("data-block-type");
          if (blockType) {
            this.selectBlock(blockType);
          }
        }
      });
    });
  }

  /**
   * Toggles a block on/off
   */
  private toggleBlock(blockType: string, enabled: boolean): void {
    if (enabled) {
      if (!this.activeBlocks.includes(blockType)) {
        this.activeBlocks.push(blockType);
      }
    } else {
      this.activeBlocks = this.activeBlocks.filter(
        (type) => type !== blockType,
      );
    }

    this.updatePreview();
  }

  /**
   * Selects a block for configuration
   */
  private selectBlock(blockType: string): void {
    // Remove previous selection
    document.querySelectorAll(".block-option").forEach((option) => {
      option.classList.remove("block-option--selected");
    });

    // Add selection to current block
    const selectedOption = document.querySelector(
      `[data-block-type="${blockType}"]`,
    );
    if (selectedOption) {
      selectedOption.classList.add("block-option--selected");
    }

    // Load block configuration
    this.loadBlockConfig(blockType);
  }

  /**
   * Loads configuration form for a specific block
   */
  private loadBlockConfig(blockType: string): void {
    const blockConfig = TEMPLATE_BLOCKS.find(
      (block) => block.type === blockType,
    );
    if (!blockConfig) return;

    const configContent = document.querySelector(".block-config-content");
    if (!configContent) return;

    const configFormHtml = `
      <form class="form" data-block-type="${blockType}">
        <h4 class="heading heading--quaternary">${blockConfig.label} Settings</h4>
        ${blockConfig.configFields.map((field) => this.renderConfigField(field)).join("")}
        <div class="form__group">
          <button type="button" class="btn btn--secondary btn--small" onclick="templateConfigHandler.resetBlockConfig('${blockType}')">
            Reset to Default
          </button>
        </div>
      </form>
    `;

    configContent.innerHTML = configFormHtml;

    // Setup field change listeners
    configContent
      .querySelectorAll("input, select, textarea")
      .forEach((input) => {
        input.addEventListener("change", () => {
          this.updateBlockConfig(blockType);
        });
      });
  }

  /**
   * Renders a configuration field
   */
  private renderConfigField(field: any): string {
    switch (field.type) {
      case "checkbox":
        return `
          <div class="form__group">
            <label class="form__label form__label--checkbox">
              <input type="checkbox" name="${field.name}" ${field.defaultValue ? "checked" : ""}>
              ${field.label}
            </label>
          </div>
        `;
      case "select":
        return `
          <div class="form__group">
            <label class="form__label" for="${field.name}">${field.label}</label>
            <select class="form__input" name="${field.name}">
              ${
                field.options
                  ?.map(
                    (option: any) =>
                      `<option value="${option.value}" ${option.value === field.defaultValue ? "selected" : ""}>${option.label}</option>`,
                  )
                  .join("") || ""
              }
            </select>
          </div>
        `;
      case "color":
        return `
          <div class="form__group">
            <label class="form__label" for="${field.name}">${field.label}</label>
            <input type="color" class="form__input form__input--color" name="${field.name}" value="${field.defaultValue || "#000000"}">
          </div>
        `;
      case "number":
        return `
          <div class="form__group">
            <label class="form__label" for="${field.name}">${field.label}</label>
            <input type="number" class="form__input" name="${field.name}" value="${field.defaultValue || 0}">
          </div>
        `;
      case "textarea":
        return `
          <div class="form__group">
            <label class="form__label" for="${field.name}">${field.label}</label>
            <textarea class="form__input" name="${field.name}" rows="3">${field.defaultValue || ""}</textarea>
          </div>
        `;
      default:
        return `
          <div class="form__group">
            <label class="form__label" for="${field.name}">${field.label}</label>
            <input type="text" class="form__input" name="${field.name}" value="${field.defaultValue || ""}">
          </div>
        `;
    }
  }

  /**
   * Updates block configuration based on form values
   */
  private updateBlockConfig(blockType: string): void {
    const form = document.querySelector(
      `form[data-block-type="${blockType}"]`,
    ) as HTMLFormElement;
    if (!form) return;

    const formData = new FormData(form);
    const config: Record<string, any> = {};

    // Process form data
    for (const [key, value] of formData.entries()) {
      config[key] = value;
    }

    // Handle checkboxes (they don't appear in FormData when unchecked)
    form.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
      const input = checkbox as HTMLInputElement;
      config[input.name] = input.checked;
    });

    // Update the template configuration
    if (!this.currentTemplate) {
      this.currentTemplate = { blocks: [] };
    }

    const blockIndex = this.currentTemplate.blocks.findIndex(
      (block: any) => block.type === blockType,
    );
    if (blockIndex >= 0) {
      this.currentTemplate.blocks[blockIndex].config = config;
    } else {
      this.currentTemplate.blocks.push({
        type: blockType,
        config: config,
        order: this.activeBlocks.indexOf(blockType) + 1,
      });
    }

    this.updatePreview();
  }

  /**
   * Resets a block to its default configuration
   */
  resetBlockConfig(blockType: string): void {
    const blockConfig = TEMPLATE_BLOCKS.find(
      (block) => block.type === blockType,
    );
    if (!blockConfig) return;

    // Update form with default values
    const form = document.querySelector(
      `form[data-block-type="${blockType}"]`,
    ) as HTMLFormElement;
    if (form) {
      blockConfig.configFields.forEach((field) => {
        const input = form.querySelector(
          `[name="${field.name}"]`,
        ) as HTMLInputElement;
        if (input) {
          if (input.type === "checkbox") {
            input.checked = field.defaultValue || false;
          } else {
            input.value = field.defaultValue || "";
          }
        }
      });

      // Trigger update
      this.updateBlockConfig(blockType);
    }
  }

  /**
   * Updates the template preview
   */
  private updatePreview(): void {
    // This will trigger the preview update in the main template manager
    const event = new CustomEvent("templateConfigChanged", {
      detail: {
        template: this.currentTemplate,
        activeBlocks: this.activeBlocks,
      },
    });
    document.dispatchEvent(event);
  }
}

// Create global instance
declare global {
  interface Window {
    templateConfigHandler: TemplateConfigHandler;
  }
}

window.templateConfigHandler = new TemplateConfigHandler();
// ==========================================================================
// COURSE CREATION & CRUD OPERATIONS
// ==========================================================================

import { supabase } from "../supabase";

// Course creation interface
export interface CourseCreationData {
  course_name: string;
  course_description: string;
  course_language: string;
  course_image?: File | null;
  // teacher_id will be auto-filled from auth
  // Other fields will have defaults or be added later
}

// Course validation rules
export interface CourseValidation {
  course_name: boolean;
  course_description: boolean;
  course_language: boolean;
  course_image: boolean;
}

// ==========================================================================
// VALIDATION
// ==========================================================================

export function validateCourseData(
  data: Partial<CourseCreationData>,
): CourseValidation {
  return {
    course_name: Boolean(
      data.course_name && data.course_name.trim().length >= 3,
    ),
    course_description: Boolean(
      data.course_description && data.course_description.trim().length >= 10,
    ),
    course_language: Boolean(
      data.course_language && data.course_language.trim(),
    ),
    course_image: Boolean(data.course_image), // Course image is required
  };
}

export function isValidCourse(validation: CourseValidation): boolean {
  return Object.values(validation).every((isValid) => isValid);
}

// ==========================================================================
// IMAGE UPLOAD
// ==========================================================================

export async function uploadCourseImage(
  file: File,
  courseId: string,
): Promise<string | null> {
  try {
    const fileExt = file.name.split(".").pop();
    const fileName = `${courseId}/cover.${fileExt}`;
    const filePath = `course-images/${fileName}`;

    // Upload file to Supabase Storage
    const { error } = await supabase.storage
      .from("courses")
      .upload(filePath, file, {
        cacheControl: "3600",
        upsert: true,
      });

    if (error) {
      console.error("Error uploading image:", error);
      return null;
    }

    // Get public URL
    const {
      data: { publicUrl },
    } = supabase.storage.from("courses").getPublicUrl(filePath);

    return publicUrl;
  } catch (error) {
    console.error("Error in uploadCourseImage:", error);
    return null;
  }
}

// ==========================================================================
// COURSE CRUD OPERATIONS
// ==========================================================================

export async function createCourse(
  data: CourseCreationData,
): Promise<{ success: boolean; courseId?: string; error?: string }> {
  try {
    // Enhanced authentication check with session validation
    const {
      data: { session },
      error: sessionError,
    } = await supabase.auth.getSession();
    if (sessionError) {
      console.error("Session error:", sessionError);
      return { success: false, error: "Authentication session error" };
    }

    if (!session?.user) {
      console.error("No valid session or user found");
      return {
        success: false,
        error: "User not authenticated - please sign in again",
      };
    }

    const user = session.user;

    // Ensure user profile exists in users table
    await ensureUserProfile(user);

    // Validate data
    const validation = validateCourseData(data);
    if (!isValidCourse(validation)) {
      return { success: false, error: "Invalid course data" };
    }

    // Create course record with your actual schema
    const courseInsertData = {
      course_name: data.course_name.trim(),
      course_description: data.course_description.trim(),
      course_language: data.course_language.trim(),
      teacher_id: user.id, // Use teacher_id from your schema
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };


    const { data: courseData, error: courseError } = await supabase
      .from("courses")
      .insert(courseInsertData)
      .select("id")
      .single();

    if (courseError) {
      console.error("Error creating course:", courseError);
      return {
        success: false,
        error: `Failed to create course: ${courseError.message}`,
      };
    }

    const courseId = courseData.id;

    // Upload image if provided
    if (data.course_image) {
      const imageUrl = await uploadCourseImage(data.course_image, courseId);
      if (imageUrl) {
        // Update course with image URL using course_image field
        const { error: updateError } = await supabase
          .from("courses")
          .update({ course_image: imageUrl })
          .eq("id", courseId);

        if (updateError) {
          console.error("Error updating course with image:", updateError);
          // Don't fail the entire operation for image update failure
          console.warn("Course created but image update failed");
        }
      }
    }

    return { success: true, courseId };
  } catch (error) {
    console.error("Error in createCourse:", error);
    return { success: false, error: "Unexpected error occurred" };
  }
}

// Helper function to ensure user profile exists
async function ensureUserProfile(user: any): Promise<void> {
  try {
    // First try using the database function
    const { error: rpcError } = await supabase.rpc("ensure_user_profile", {
      user_id: user.id,
      user_email: user.email,
      user_role: "teacher",
    });

    if (rpcError) {
      console.warn("RPC call failed, using fallback method:", rpcError);
      // Fallback to direct upsert
      await ensureUserProfileFallback(user);
    }
  } catch (error) {
    console.warn("Error ensuring user profile, using fallback:", error);
    await ensureUserProfileFallback(user);
  }
}

// Fallback method to ensure user profile exists
async function ensureUserProfileFallback(user: any): Promise<void> {
  try {
    const userMetadata = user.user_metadata || {};
    const fullName =
      userMetadata.full_name || user.email?.split("@")[0] || "User";
    const userRole = userMetadata.user_role || "teacher";

    const nameParts = fullName.split(" ");
    const firstName = nameParts[0] || "";
    const lastName = nameParts.slice(1).join(" ") || "";

    const { error } = await supabase.from("users").upsert(
      {
        id: user.id,
        first_name: firstName,
        last_name: lastName,
        email: user.email,
        role: userRole,
        institution: "Independent",
      },
      {
        onConflict: "id",
      },
    );

    if (error) {
      console.error("Failed to create user profile:", error);
    } else {
    }
  } catch (error) {
    console.error("Error in ensureUserProfileFallback:", error);
  }
}

export async function updateCourse(
  courseId: string,
  data: Partial<CourseCreationData>,
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from("courses")
      .update({
        ...data,
        updated_at: new Date().toISOString(),
      })
      .eq("id", courseId);

    if (error) {
      console.error("Error updating course:", error);
      return { success: false, error: "Failed to update course" };
    }

    return { success: true };
  } catch (error) {
    console.error("Error in updateCourse:", error);
    return { success: false, error: "Unexpected error occurred" };
  }
}

export async function deleteCourse(
  courseId: string,
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase
      .from("courses")
      .delete()
      .eq("id", courseId);

    if (error) {
      console.error("Error deleting course:", error);
      return { success: false, error: "Failed to delete course" };
    }

    return { success: true };
  } catch (error) {
    console.error("Error in deleteCourse:", error);
    return { success: false, error: "Unexpected error occurred" };
  }
}

export async function getCourse(courseId: string) {
  try {
    const { data, error } = await supabase
      .from("courses")
      .select("*")
      .eq("id", courseId)
      .single();

    if (error) {
      console.error("Error fetching course:", error);
      return null;
    }

    return data;
  } catch (error) {
    console.error("Error in getCourse:", error);
    return null;
  }
}

export async function getUserCourses(userId?: string) {
  try {
    let query = supabase.from("courses").select("*");

    if (userId) {
      query = query.eq("teacher_id", userId); // Fixed: using teacher_id instead of user_id
    } else {
      // Get current user's courses
      const {
        data: { user },
        error: authError,
      } = await supabase.auth.getUser();
      if (authError || !user) return [];
      query = query.eq("teacher_id", user.id); // Fixed: using teacher_id instead of user_id
    }

    const { data, error } = await query.order("created_at", {
      ascending: false,
    });

    if (error) {
      console.error("Error fetching courses:", error);
      return [];
    }

    return data || [];
  } catch (error) {
    console.error("Error in getUserCourses:", error);
    return [];
  }
}
// ==========================================================================
// COURSE BUILDER MAIN CONTROLLER - Uses Generic Form Handler
// ==========================================================================

import { CourseFormHandler } from "./courseFormHandler";
import { ScheduleCourseManager } from "./scheduleCourse";
import { CurriculumManager } from "./curriculumManager";

// Re-export course creation and classification functions
export * from "./createCourse";
export * from "./classifyCourse";

// ==========================================================================
// COURSE BUILDER CLASS
// ==========================================================================

export class CourseBuilder {
  private currentFormHandler: CourseFormHandler | null = null;
  private scheduleManager: ScheduleCourseManager | null = null;
  private curriculumManager: CurriculumManager | null = null;
  private currentSection: string = "essentials";

  constructor() {
    this.initialize();
  }

  // ==========================================================================
  // INITIALIZATION
  // ==========================================================================

  private initialize(): void {
    this.initializeCurrentSection();
    this.setupSectionNavigation();
  }

  private initializeCurrentSection(): void {
    // Initialize the currently active section
    const activeSection = document.querySelector(".article--active");
    if (activeSection) {
      const sectionId = activeSection.id;
      this.loadSection(sectionId);
    }
  }

  private setupSectionNavigation(): void {
    // Listen for aside navigation clicks
    const asideLinks = document.querySelectorAll(".aside__link[data-section]");
    asideLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const section = (e.target as HTMLElement).getAttribute("data-section");
        if (section) {
          this.navigateToSection(section);
        }
      });
    });
  }

  // ==========================================================================
  // SECTION MANAGEMENT
  // ==========================================================================

  private navigateToSection(sectionId: string): void {
    // Hide all articles
    const articles = document.querySelectorAll(".article");
    articles.forEach((article) => {
      article.classList.remove("article--active");
    });

    // Show target article
    const targetArticle = document.getElementById(sectionId);
    if (targetArticle) {
      targetArticle.classList.add("article--active");
      this.currentSection = sectionId;
      this.loadSection(sectionId);
    }

    // Update aside navigation
    this.updateAsideNavigation(sectionId);
  }

  private loadSection(sectionId: string): void {
    try {
      // Clean up previous handlers
      this.currentFormHandler = null;
      this.scheduleManager = null;
      this.curriculumManager = null;

      // Initialize appropriate handler based on section
      if (sectionId === "schedule") {
        // Initialize schedule manager - it will auto-detect course ID from session storage
        this.scheduleManager = new ScheduleCourseManager();
      } else if (sectionId === "curriculum") {
        // Initialize curriculum manager - it will auto-detect course ID from session storage
        this.curriculumManager = new CurriculumManager();
      } else {
        // Initialize generic form handler for other sections
        this.currentFormHandler = new CourseFormHandler(sectionId);
      }
    } catch (error) {
      console.warn(`No handler available for section: ${sectionId}`, error);
    }
  }

  private updateAsideNavigation(activeSectionId: string): void {
    // Remove active class from all links
    const asideLinks = document.querySelectorAll(".aside__link");
    asideLinks.forEach((link) => {
      link.classList.remove("aside__link--active");
    });

    // Add active class to current link
    const activeLink = document.querySelector(
      `[data-section="${activeSectionId}"]`,
    );
    if (activeLink) {
      activeLink.classList.add("aside__link--active");
    }
  }

  // ==========================================================================
  // PUBLIC METHODS
  // ==========================================================================

  public getCurrentSection(): string {
    return this.currentSection;
  }

  public goToSection(sectionId: string): void {
    this.navigateToSection(sectionId);
  }
}

// ==========================================================================
// AUTO-INITIALIZATION
// ==========================================================================

// Initialize when DOM is ready - but only once
let courseBuilderInitialized = false;

document.addEventListener("DOMContentLoaded", () => {
  // Only initialize if we're on the coursebuilder page, in the setup section, and not already initialized
  const isInSetupSection =
    document.querySelector(".section#setup.section--active") ||
    window.location.hash === "#setup" ||
    window.location.hash === "";
  const hasSetupSection = document.querySelector(".section#setup");

  if (hasSetupSection && isInSetupSection && !courseBuilderInitialized) {
    courseBuilderInitialized = true;
    new CourseBuilder();
      "CourseBuilder (form handler) initialized from courses/index.ts",
    );
  }
});

// Also listen for hash changes to initialize when entering setup
window.addEventListener("hashchange", () => {
  const isInSetupSection =
    window.location.hash === "#setup" || window.location.hash === "";
  const hasSetupSection = document.querySelector(".section#setup");

  if (hasSetupSection && isInSetupSection && !courseBuilderInitialized) {
    courseBuilderInitialized = true;
    new CourseBuilder();
      "CourseBuilder (form handler) initialized on hash change to setup",
    );
  }
});
import { supabase } from "../../backend/supabase.js";

interface CurriculumLesson {
  lessonNumber: number;
  title: string;
  topics: CurriculumTopic[];
}

interface CurriculumTopic {
  title: string;
  objectives: string[];
  tasks: string[];
}

interface ContentLoadConfig {
  type: "mini" | "regular" | "double" | "triple" | "long";
  duration: number; // in minutes
  topicsPerLesson: number;
  objectivesPerTopic: number;
  tasksPerTopic: number;
}

type PreviewMode = "titles" | "topics" | "objectives";

export class CurriculumManager {
  private courseId: string;
  private curriculumConfigSection!: HTMLElement;
  private curriculumPreviewSection!: HTMLElement;
  private contentLoadDisplay!: HTMLElement;
  private currentCurriculum: CurriculumLesson[] = [];
  private contentLoadConfig: ContentLoadConfig | null = null;
  private currentPreviewMode: PreviewMode = "titles";

  constructor(courseId?: string) {
    // Get course ID from parameter or session storage
    this.courseId = courseId || sessionStorage.getItem("currentCourseId") || "";

    if (!this.courseId) {
      console.error("No course ID available for curriculum management");
      return;
    }

    this.initializeElements();
    this.bindEvents();
    this.initializeCurriculum();
  }

  private async initializeCurriculum(): Promise<void> {
    try {
      // Load schedule data first
      await this.loadScheduleData();

      // Load existing curriculum
      await this.loadExistingCurriculum();

      // Auto-generate curriculum if we have schedule data but no curriculum
      if (!this.currentCurriculum.length && this.contentLoadConfig) {
        await this.generateCurriculum();
      }

      // Always show preview if we have curriculum data
      if (this.currentCurriculum.length > 0) {
        this.showPreview();
      }
    } catch (error) {
      console.error("Error initializing curriculum:", error);
    }
  }

  private initializeElements(): void {
    this.curriculumConfigSection = document.getElementById(
      "curriculum-config",
    ) as HTMLElement;
    this.curriculumPreviewSection = document.getElementById(
      "curriculum-preview",
    ) as HTMLElement;
    this.contentLoadDisplay = document.getElementById(
      "content-load-display",
    ) as HTMLElement;

    // Check if all elements were found
    if (!this.curriculumConfigSection) {
      console.error("curriculum-config element not found");
      return;
    }
    if (!this.curriculumPreviewSection) {
      console.error("curriculum-preview element not found");
      return;
    }

  }

  private bindEvents(): void {
    if (!this.curriculumConfigSection) {
      console.error("Cannot bind events: required elements not found");
      return;
    }

    // Preview mode buttons
    const previewModeButtons =
      this.curriculumPreviewSection?.querySelectorAll(".preview-mode-btn");
    previewModeButtons?.forEach((button) => {
      button.addEventListener("click", (e) => {
        const mode = (e.target as HTMLElement).dataset.mode as PreviewMode;
        this.setPreviewMode(mode);
      });
    });

  }

  private async loadScheduleData(): Promise<void> {
    try {
      const { data, error } = await supabase
        .from("courses")
        .select("schedule_settings")
        .eq("id", this.courseId)
        .single();

      if (error) throw error;

      if (
        data?.schedule_settings &&
        Array.isArray(data.schedule_settings) &&
        data.schedule_settings.length > 0
      ) {
        // Get the first lesson to determine duration
        const firstLesson = data.schedule_settings[0];
        const duration = this.calculateLessonDuration(
          firstLesson.startTime,
          firstLesson.endTime,
        );
        this.contentLoadConfig = this.determineContentLoad(duration);
        this.displayContentLoad();
      } else {
        this.displayNoScheduleWarning();
      }
    } catch (error) {
      console.error("Error loading schedule data:", error);
      this.displayNoScheduleWarning();
    }
  }

  private calculateLessonDuration(startTime: string, endTime: string): number {
    const start = new Date(`2000-01-01T${startTime}`);
    const end = new Date(`2000-01-01T${endTime}`);
    return Math.abs(end.getTime() - start.getTime()) / (1000 * 60); // Convert to minutes
  }

  private determineContentLoad(duration: number): ContentLoadConfig {
    if (duration <= 30) {
      return {
        type: "mini",
        duration,
        topicsPerLesson: 1,
        objectivesPerTopic: 1,
        tasksPerTopic: 2,
      };
    } else if (duration <= 60) {
      return {
        type: "regular",
        duration,
        topicsPerLesson: 2,
        objectivesPerTopic: 2,
        tasksPerTopic: 2,
      };
    } else if (duration <= 120) {
      return {
        type: "double",
        duration,
        topicsPerLesson: 3,
        objectivesPerTopic: 2,
        tasksPerTopic: 3,
      };
    } else if (duration <= 180) {
      return {
        type: "triple",
        duration,
        topicsPerLesson: 4,
        objectivesPerTopic: 3,
        tasksPerTopic: 3,
      };
    } else {
      return {
        type: "long",
        duration,
        topicsPerLesson: 5,
        objectivesPerTopic: 3,
        tasksPerTopic: 4,
      };
    }
  }

  private displayContentLoad(): void {
    if (!this.contentLoadDisplay || !this.contentLoadConfig) return;

    this.contentLoadDisplay.innerHTML = `
            <div class="content-load-info">
                <div class="content-load-badge content-load-badge--${this.contentLoadConfig.type}">
                    ${this.contentLoadConfig.type.toUpperCase()}
                </div>
                <div class="content-load-details">
                    <div class="duration">${this.contentLoadConfig.duration} minutes per lesson</div>
                    <div class="structure">
                        ${this.contentLoadConfig.topicsPerLesson} topic(s) ‚Ä¢ 
                        ${this.contentLoadConfig.objectivesPerTopic} objective(s) per topic ‚Ä¢ 
                        ${this.contentLoadConfig.tasksPerTopic} task(s) per topic
                    </div>
                </div>
            </div>
        `;
  }

  private displayNoScheduleWarning(): void {
    if (!this.contentLoadDisplay) return;

    this.contentLoadDisplay.innerHTML = `
            <div class="content-load-warning">
                <div class="warning-icon">‚ö†Ô∏è</div>
                <div class="warning-text">
                    <strong>Schedule Required</strong>
                    <p>Please create a schedule first to determine content load.</p>
                </div>
            </div>
        `;
  }

  private async generateCurriculum(): Promise<void> {
    if (!this.contentLoadConfig) {
      console.warn(
        "Content load configuration not available. Please ensure you have a schedule.",
      );
      return;
    }


    try {
      // Get the number of lessons from schedule
      const { data: scheduleData } = await supabase
        .from("courses")
        .select("schedule_settings, course_days")
        .eq("id", this.courseId)
        .single();

      const numLessons = scheduleData?.course_days || 1;
      const curriculum = this.createCurriculumStructure(numLessons);

      await this.saveCurriculumToDatabase(curriculum);
      this.currentCurriculum = curriculum;
      this.renderCurriculumPreview();

    } catch (error) {
      console.error("Error generating curriculum:", error);
      alert("Failed to generate curriculum. Please try again.");
    }
  }

  private createCurriculumStructure(numLessons: number): CurriculumLesson[] {
    if (!this.contentLoadConfig) return [];

    const curriculum: CurriculumLesson[] = [];

    for (let i = 1; i <= numLessons; i++) {
      const lesson: CurriculumLesson = {
        lessonNumber: i,
        title: `Lesson ${i}`,
        topics: [],
      };

      for (let j = 1; j <= this.contentLoadConfig.topicsPerLesson; j++) {
        const topic: CurriculumTopic = {
          title: `Topic ${j}`,
          objectives: [],
          tasks: [],
        };

        // Add objectives
        for (let k = 1; k <= this.contentLoadConfig.objectivesPerTopic; k++) {
          topic.objectives.push(`Objective ${k}`);
        }

        // Add tasks
        for (let l = 1; l <= this.contentLoadConfig.tasksPerTopic; l++) {
          topic.tasks.push(`Task ${l}`);
        }

        lesson.topics.push(topic);
      }

      curriculum.push(lesson);
    }

    return curriculum;
  }

  private async saveCurriculumToDatabase(
    curriculum: CurriculumLesson[],
  ): Promise<void> {
    const { error } = await supabase
      .from("courses")
      .update({
        curriculum_data: curriculum,
      })
      .eq("id", this.courseId);

    if (error) {
      throw error;
    }
  }

  private setPreviewMode(mode: PreviewMode): void {
    this.currentPreviewMode = mode;

    // Update active button
    const previewModeButtons =
      this.curriculumPreviewSection.querySelectorAll(".preview-mode-btn");
    previewModeButtons.forEach((btn) => {
      btn.classList.toggle(
        "active",
        (btn as HTMLElement).dataset.mode === mode,
      );
    });

    // Re-render preview with new mode
    this.renderCurriculumPreview();
  }

  private renderCurriculumPreview(): void {
    const previewContainer = this.curriculumPreviewSection.querySelector(
      ".curriculum-preview-content",
    );
    if (!previewContainer || !Array.isArray(this.currentCurriculum)) return;

    let html = "";

    this.currentCurriculum.forEach((lesson) => {
      html += `<div class="curriculum-lesson">`;

      // Always show lesson title
      html += `<div class="lesson-title" contenteditable="true" data-lesson="${lesson.lessonNumber}" data-field="title">${lesson.title}</div>`;

      if (
        this.currentPreviewMode === "topics" ||
        this.currentPreviewMode === "objectives"
      ) {
        lesson.topics.forEach((topic, topicIndex) => {
          html += `<div class="lesson-topic">`;
          html += `<div class="topic-title" contenteditable="true" data-lesson="${lesson.lessonNumber}" data-topic="${topicIndex}" data-field="title">${topic.title}</div>`;

          if (this.currentPreviewMode === "objectives") {
            topic.objectives.forEach((objective, objIndex) => {
              html += `<div class="topic-objective" contenteditable="true" data-lesson="${lesson.lessonNumber}" data-topic="${topicIndex}" data-objective="${objIndex}">${objective}</div>`;
            });
          }

          html += `</div>`;
        });
      }

      html += `</div>`;
    });

    previewContainer.innerHTML = html;
    this.bindEditableEvents();
    this.curriculumPreviewSection.classList.remove("hidden");
  }

  private bindEditableEvents(): void {
    const editableElements = this.curriculumPreviewSection.querySelectorAll(
      '[contenteditable="true"]',
    );
    editableElements.forEach((element) => {
      element.addEventListener("blur", (e) =>
        this.updateCurriculumData(e.target as HTMLElement),
      );
    });
  }

  private updateCurriculumData(element: HTMLElement): void {
    const lessonNum = parseInt(element.dataset.lesson || "0");
    const topicIndex = element.dataset.topic
      ? parseInt(element.dataset.topic)
      : null;
    const objectiveIndex = element.dataset.objective
      ? parseInt(element.dataset.objective)
      : null;
    const field = element.dataset.field;
    const newValue = element.textContent || "";

    const lesson = this.currentCurriculum.find(
      (l) => l.lessonNumber === lessonNum,
    );
    if (!lesson) return;

    if (field === "title" && topicIndex === null) {
      // Lesson title
      lesson.title = newValue;
    } else if (topicIndex !== null && lesson.topics[topicIndex]) {
      if (field === "title") {
        // Topic title
        lesson.topics[topicIndex].title = newValue;
      } else if (objectiveIndex !== null) {
        // Objective
        lesson.topics[topicIndex].objectives[objectiveIndex] = newValue;
      }
    }

    // Auto-save to database
    this.saveCurriculumToDatabase(this.currentCurriculum);
  }

  private async loadExistingCurriculum(): Promise<void> {
    try {
      const { data, error } = await supabase
        .from("courses")
        .select("curriculum_data")
        .eq("id", this.courseId)
        .single();

      if (error) throw error;

      if (data?.curriculum_data && Array.isArray(data.curriculum_data)) {
        this.currentCurriculum = data.curriculum_data;
        this.renderCurriculumPreview();
      } else {
        this.hideCurriculumPreview();
      }
    } catch (error) {
      console.error("Error loading existing curriculum:", error);
      this.hideCurriculumPreview();
    }
  }

  private showPreview(): void {
    this.curriculumPreviewSection.classList.remove("hidden");
    this.renderCurriculumPreview();
  }

  private hideCurriculumPreview(): void {
    this.curriculumPreviewSection.classList.add("hidden");
  }
}

// Make CurriculumManager available globally for testing/debugging
declare global {
  interface Window {
    CurriculumManager: typeof CurriculumManager;
  }
}

if (typeof window !== "undefined") {
  window.CurriculumManager = CurriculumManager;
}
/**
 * Supabase Client Configuration
 * Backend configuration for database and authentication services
 */

import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  throw new Error(
    "Missing Supabase environment variables. Please check your .env file.",
  );
}

export const supabase = createClient(supabaseUrl, supabaseKey);
